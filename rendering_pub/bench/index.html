<html>
	<head>
		<script type="text/javascript" src="js/gjl.js"></script>
        <script type="text/javascript" src="js/jquery.js"></script>
		<script type="text/javascript" src="js/loadash.js"></script>
		<script type="text/javascript" src="js/benchmark.js"></script>
        <script type="text/javascript" src="js/ol2_2.13.1/OpenLayers.js"></script>
		<script type="text/javascript" src="js/ol3_3.19.1/ol-debug.js"></script>
		<link href="js/ol3_3.19.1/ol.css" rel="stylesheet">
		<script type="text/javascript" src="js/leaflet_1.0.2/leaflet.js"></script>
		<link href="js/leaflet_1.0.2/leaflet.css" rel="stylesheet">
		<style>
			.wrapper {
				width: 100%;
				height: 200px;
			}
			.benchmarkOutput {
    			width: 50%;
    			height: 100%;
    			border: 1px solid grey;
    			overflow-y: scroll;
    			white-space: pre-line;
				box-sizing: border-box;
				float: left;
				overflow-x: hidden;
			}
		</style>
	</head>
	<body>
        <p>CPU tools</p>
		<button id="ol2_cpu">OpenLayers 2</button>
		<button id="ol3_cpu">OpenLayers 3</button>
		<button id="l_cpu">Leaflet</button><br><br>
		<div class="wrapper">
			<div id="benchmarkOutput" class="benchmarkOutput"></div>
			<canvas id="chartPlot" class="chartPlot"></canvas>
		</div>
		<p>Memory tools</p>
		<p>OpenLayers 2</p>
		<button id="ol2_prepare">Prepare</button>
		<button id="ol2_run">Run</button>
		<p>OpenLayers 3</p>
		<button id="ol3_prepare">Prepare</button>
		<button id="ol3_run">Run</button>
		<p>Leaflet</p>
		<button id="l_prepare">Prepare</button>
		<button id="l_run">Run</button>
        <form id="settings">
        <p>Settings</p>
        Type: <input type="radio" name="type" value="Point">Point</input>
              <input type="radio" name="type" value="LineString" checked>LineString</input>
              <input type="radio" name="type" value="Polygon">Polygon</input><br>
        Variable: <input type="radio" name="varname" value="vertex" checked>Number of vertices</input>
                  <input type="radio" name="varname" value="feature">Number of features</input><br>
                   <li>From (inclusive): <input type="number" name="varfrom" value="50"></input></li>
                   <li>To (inclusive): <input type="number" name="varto" value="2000"></input></li>
                   <li>Increment: <input type="number" name="varinc" value="50"></input></li><br>
        Constant: <input type="number" name="constamount" value="1"></input><br>
        Async: <input type="checkbox" name="async" checked></input>
        </form>
        <p>NOTES:</p>
        Created exclusively to support the paper "A WebGL Powered Vector Rendering Engine for OpenLayers 3". There won't be further changes, nor more detailed description.<br>
        The tests cannot be stopped without reloading the page.<br>
        If you change the settings during a test, you will almost <b>definitely</b> end up with corrupted results (in case you get any results).<br>
        The output is always in milliseconds. The result should be interpreted as a CSV file with the pipe symbol (|) as field separator.<br>
        If the benchmark stops due to an error in GeoJSON Lite, it does not compromise the previous results, as the process automatically stops before running the next test with the erronous geometry.<br>
        The constant value is always the other one. If you choose the number of vertices as a variable, the number of features becomes the constant and vice versa.<br>
        The memory tools can be only used with one of your browser's profiling tools. Always prepare the data prior to running the tests.<br>
        If you change the settings after preparing the data, you will most likely have to prepare the data again.<br>
        <i>Lincensed under the MIT license. Author: GÃ¡bor Farkas</i>
		<script type="text/javascript">
			function ol3 (from, to, inc) {
                var settings = document.getElementById('settings');
				var bench = new Benchmark(from.toString(), function () {
					map.renderFrame_(Date.now());
				}, {
					'setup': function () {
                        var settings = document.getElementById('settings');
                        var vertices = settings.varname.value === 'vertex' ? parseInt(this.name) : parseInt(settings.constamount.value);
                        var featnum = settings.varname.value === 'feature' ? parseInt(this.name) : parseInt(settings.constamount.value);
						var mapDiv = document.createElement('div');
						mapDiv.style.width = '500px';
						mapDiv.style.height = '500px';
                        document.body.appendChild(mapDiv);
						var map = new ol.Map({
							target: mapDiv,
							view: new ol.View({
								projection: 'EPSG:4326',
								center: [0,0],
								zoom: 0
							})
						});
						var factory = new gjl.RandomFactory({type: settings.type.value, vertices: vertices});
						var geoJSON = factory.generateFeatures(featnum);
						var vectSource = new ol.source.Vector();
						map.addLayer(new ol.layer.Vector({
							source: vectSource
						}));
						var format = new ol.format.GeoJSON({
							defaultDataProjection: 'EPSG:4326'
						});
						var feats = format.readFeatures(geoJSON);
                        vectSource.addFeatures(feats);
                        document.body.removeChild(mapDiv);
					},
					'teardown': function () {
						vectSource = null;
						geoJSON = null;
						map.setTarget(null);
						map = null;
						mapDiv = null;
						feats = null;
						factory = null;
						format = null;
					},
					'onComplete': function(evt) {
                        var output = document.getElementById('benchmarkOutput');
                        if (output.innerHTML !== '') {
                            output.insertAdjacentHTML('beforeend', '<br>');
                        }
                        output.insertAdjacentHTML('beforeend', evt.target.name + '|' + ((1/evt.target.hz)*1000).toFixed(3));
                        output.scrollTop = output.scrollHeight - output.getBoundingClientRect().height;
						if (from < to) {
							setTimeout(ol3(from + inc, to, inc), 2000);
						}
                	}
				});
				bench.run({async: settings.async.checked});
			};
			
			function ol2 (from, to, inc) {
                var settings = document.getElementById('settings');
				var bench = new Benchmark(from.toString(), function () {
					vectLayer.moveTo(new OpenLayers.Bounds([-180, -90, 180, 90]), true);
				}, {
					'setup': function () {
                        var settings = document.getElementById('settings');
                        var vertices = settings.varname.value === 'vertex' ? parseInt(this.name) : parseInt(settings.constamount.value);
                        var featnum = settings.varname.value === 'feature' ? parseInt(this.name) : parseInt(settings.constamount.value);
						var mapDiv = document.createElement('div');
						mapDiv.style.width = '500px';
						mapDiv.style.height = '500px';
                        document.body.appendChild(mapDiv);
                        var renderer = new OpenLayers.Renderer.Canvas(mapDiv);
						var map = new OpenLayers.Map(mapDiv, {
							allOverlays: true,
							projection: 'EPSG:4326',
							center: [0,0],
							zoom: 0
						});
						var factory = new gjl.RandomFactory({type: settings.type.value, vertices: vertices});
						var geoJSON = factory.generateFeatures(featnum);
						var vectLayer = new OpenLayers.Layer.Vector('name', {renderer: renderer});
						map.addLayer(vectLayer);
						var feats = new OpenLayers.Format.GeoJSON().read(geoJSON);
                        vectLayer.addFeatures(feats);
                        document.body.removeChild(mapDiv);
					},
					'teardown': function () {
                        renderer = null;
						vectLayer = null;
						geoJSON = null;
						map.destroy();
						map = null;
						mapDiv = null;
						feats = null;
						factory = null;
					},
					'onComplete': function(evt) {
                        var output = document.getElementById('benchmarkOutput');
                        if (output.innerHTML !== '') {
                            output.insertAdjacentHTML('beforeend', '<br>');
                        }
                        output.insertAdjacentHTML('beforeend', evt.target.name + '|' + ((1/evt.target.hz)*1000).toFixed(3));
                        output.scrollTop = output.scrollHeight - output.getBoundingClientRect().height;
						if (from < to) {
							setTimeout(ol2(from + inc, to, inc), 2000);
						}
                	}
				});
				bench.run({async: settings.async.checked});
			};
			
			function l (from, to, inc) {
                var settings = document.getElementById('settings');
				var bench = new Benchmark(from.toString(), function () {
					renderer._update();
				}, {
					'setup': function () {
                        var settings = document.getElementById('settings');
                        var vertices = settings.varname.value === 'vertex' ? parseInt(this.name) : parseInt(settings.constamount.value);
                        var featnum = settings.varname.value === 'feature' ? parseInt(this.name) : parseInt(settings.constamount.value);
                        var renderer = L.canvas();
						var mapDiv = document.createElement('div');
						mapDiv.style.width = '500px';
						mapDiv.style.height = '500px';
                        document.body.appendChild(mapDiv);
						var map = L.map(mapDiv, {crs: L.CRS.EPSG4326, renderer: renderer}).setView([0,0],0);
						var factory = new gjl.RandomFactory({type: settings.type.value, vertices: vertices});
						var geoJSON = factory.generateFeatures(featnum);
						var geojsonMarkerOptions = {
							radius: 8,
							fillColor: "#ff7800",
							color: "#000",
							weight: 1,
							opacity: 1,
							fillOpacity: 0.8
						};
						var vectLayer = L.geoJson(geoJSON, {
							pointToLayer: function (feature, latlng) {
       			 				return L.circleMarker(latlng, geojsonMarkerOptions);
    						}
						});
                        map.addLayer(vectLayer);
                        document.body.removeChild(mapDiv);
					},
					'teardown': function () {
						vectLayer = null;
						geoJSON = null;
						map.remove();
						map = null;
						mapDiv = null;
						factory = null;
                        renderer = null;
					},
					'onComplete': function(evt) {
                        var output = document.getElementById('benchmarkOutput');
                        if (output.innerHTML !== '') {
                            output.insertAdjacentHTML('beforeend', '<br>');
                        }
                        output.insertAdjacentHTML('beforeend', evt.target.name + '|' + ((1/evt.target.hz)*1000).toFixed(3));
                        output.scrollTop = output.scrollHeight - output.getBoundingClientRect().height;
						if (from < to) {
							setTimeout(l(from + inc, to, inc), 2000);
						}
                	}
				});
				bench.run({async: settings.async.checked});
			};
			
			var preparedObj = {};
			function ol2_prepare (from, to, inc) {
                var settings = document.getElementById('settings');
                var vertices = settings.varname.value === 'vertex' ? from : parseInt(settings.constamount.value);
                var featnum = settings.varname.value === 'feature' ? from : parseInt(settings.constamount.value);
				preparedObj = {};
				preparedObj.format = new OpenLayers.Format.GeoJSON();
				var generator = new gjl.RandomFactory({type: settings.type.value});
				for (var i=from;i<=to;i+=inc) {
					generator.setVertices(vertices);
					preparedObj[i.toString()] = {};
					preparedObj[i.toString()].mapDiv = document.createElement('div');
					preparedObj[i.toString()].mapDiv.style.width = '500px';
					preparedObj[i.toString()].mapDiv.style.height = '500px';
					preparedObj[i.toString()].map = new OpenLayers.Map(preparedObj[i.toString()].mapDiv, {
						allOverlays: true,
						projection: 'EPSG:4326',
						center: [0,0],
						zoom: 0
					});
					preparedObj[i.toString()].vectLayer = new OpenLayers.Layer.Vector();
					preparedObj[i.toString()].map.addLayer(preparedObj[i.toString()].vectLayer);
					preparedObj[i.toString()].feats = generator.generateFeatures(featnum);
				}
			};
			function ol2_run (from, to, inc) {
				setTimeout(function () {
					preparedObj[from].vectLayer.addFeatures(preparedObj.format.read(preparedObj[from].feats));
					if (from < to) ol2_run(from + inc, to, inc);
				}, 500);
			};
			function ol3_prepare (from, to, inc) {
                var settings = document.getElementById('settings');
                var vertices = settings.varname.value === 'vertex' ? from : parseInt(settings.constamount.value);
                var featnum = settings.varname.value === 'feature' ? from : parseInt(settings.constamount.value);
				preparedObj = {};
				preparedObj.format = new ol.format.GeoJSON({
					defaultDataProjection: 'EPSG:4326'
				});
				var generator = new gjl.RandomFactory({type: settings.type.value});
				for (var i=from;i<=to;i+=inc) {
					generator.setVertices(vertices);
					preparedObj[i.toString()] = {};
					preparedObj[i.toString()].mapDiv = document.createElement('div');
					preparedObj[i.toString()].mapDiv.style.width = '500px';
					preparedObj[i.toString()].mapDiv.style.height = '500px';
					preparedObj[i.toString()].map = new ol.Map({
						target: preparedObj[i.toString()].mapDiv,
						view: new ol.View({
							projection: 'EPSG:4326',
							center: [0,0],
							zoom: 0
						})
					});
					preparedObj[i.toString()].vectSource = new ol.source.Vector();
					preparedObj[i.toString()].map.addLayer(new ol.layer.Vector({
						source: preparedObj[i.toString()].vectSource
					}));
					preparedObj[i.toString()].feats = generator.generateFeatures(featnum);
				}
			};
			function ol3_run (from, to, inc) {
				setTimeout(function () {
					preparedObj[from].vectSource.addFeatures(preparedObj.format.readFeatures(preparedObj[from].feats));
					if (from < to) ol3_run(from + inc, to, inc);
				}, 500);
			};
			function l_prepare (from, to, inc) {
                var settings = document.getElementById('settings');
                var vertices = settings.varname.value === 'vertex' ? from : parseInt(settings.constamount.value);
                var featnum = settings.varname.value === 'feature' ? from : parseInt(settings.constamount.value);
				preparedObj = {};
				preparedObj.options = {
					radius: 8,
					fillColor: "#ff7800",
					color: "#000",
					weight: 1,
					opacity: 1,
					fillOpacity: 0.8
				};
				var generator = new gjl.RandomFactory({type: settings.type.value});
				for (var i=from;i<=to+inc;i+=inc) {
					generator.setVertices(i);
					preparedObj[i] = {};
					preparedObj[i].mapDiv = document.createElement('div');
					preparedObj[i].mapDiv.style.width = '500px';
					preparedObj[i].mapDiv.style.height = '500px';
					preparedObj[i].map = L.map(preparedObj[i].mapDiv, {crs: L.CRS.EPSG4326, renderer: L.canvas()}).setView([0,0],0);
					preparedObj[i].feats = generator.generateFeatures(1);
				}
				l_run(to+inc, to+inc, inc);
			};
			function l_run (from, to, inc) {
				setTimeout(function () {
					L.geoJson(preparedObj[from].feats).addTo(preparedObj[from].map);
					if (from < to) l_run(from + inc, to, inc);
				}, 500);
			};
            
            document.getElementById('ol2_cpu').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               ol2(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('ol3_cpu').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               ol3(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('l_cpu').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               l(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('ol2_prepare').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               ol2_prepare(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('ol2_run').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               ol2_run(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('ol3_prepare').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               ol3_prepare(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('ol3_run').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               ol3_run(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('l_prepare').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               l_prepare(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
            document.getElementById('l_run').addEventListener('click', function() {
               var settings = document.getElementById('settings');
               l_run(parseInt(settings.varfrom.value), parseInt(settings.varto.value), parseInt(settings.varinc.value)); 
            });
		</script>
	</body>
</html>

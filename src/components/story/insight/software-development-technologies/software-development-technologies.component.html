<h1>Synopsis</h1>

<p class="pb-4">Software Development Technologies is a mandatory course in the Computer Science BSc program of the
    University of PÃ©cs, Institute of Mathematics and Informatics. This course was designed to expose our students to
    technologies widely used in high-tech business scenarios, such as organizations, companies, enterprises, or
    startups. During the past few years, I refined the concept to a simple form of showing what the future holds. But
    hold on! How can anyone be certain about the future of software development? We can't. However, we can forecast some
    rough and fairly safe approximations based on the trends of the past few decades.</p>

<p class="pb-2">Let's start with recent trends. We can see articles in mainstream tech media arguing and philosophizing
    about different trends, patterns, and technologies in software development. While most "tech evangelists" are
    currently preoccupied with AI, if we look close (or far) enough, we can see a shaded picture full of uncertainty and
    sometimes even anxiety. Some of the popular topics I find particularly interesting are the following:</p>
<ul class="list-disc pl-10 pb-4">
    <li>Platforms everywhere (SaaS, IaaS, PaaS), cloud computing is the future.</li>
    <li>We need to revolutionize finance with cryptography. Blockchains are the future.</li>
    <li>We have working software packages for everything, we just have to connect them together. Infrastructure and
        DevOps are the future.</li>
    <li>Soon enough AI will be able to create quality code. Data science is the future.</li>
</ul>

<p class="pb-4">While there are bits of wisdom in these and other hot tech topics (e.g. expert systems, low-code), I
    consider most of them noise. If I look at these topics with smaller, more hands-on developments on a timeline, I can
    see two significant trends I firmly believe in.</p>

<p class="pb-4">Programming, as in the capability of automatizing processes, will become part of basic literacy. With
    gradually lowering entry skill requirements (scripting languages, low-code environments, frameworks) and gradually
    increasing digital proficiency in newer generations, automatizing is reaching an ever wider audience. I like to use
    the analogy of literacy in medieval times as an example. People capable of reading and writing had better job
    opportunities, stronger positions, more influence, better chances, and a better quality of life. Slowly, more
    families had this skill to pass down, primary education became more available, and it stopped being the privilege of
    nobility. Now, most of us possess it. I believe, considering programming, we are dealing with a similar tendency.
</p>

<p class="pb-4">The second trend is an organic restructuring of software development we are in the middle of. The
    development of the Internet proved that standardization is beneficial for software development as well. From then
    on, the whole field moved towards standard (e.g. RFCs) or de-facto standard patterns and solutions (e.g. MVC, IoC,
    OAuth, GraphQL). This standardization process and proper governance are two requisites for a software engineering
    field to rise (not the self-proclaimed one we can see under every second IT expert's LinkedIn profile). With such a
    field having a self-contained guarantee system, we can have better-defined responsibility chains, build trust
    effortlessly, and have a more compatible and better plannable world of software and infrastructure. I believe that
    soon the level of standardization will enable higher education to build well-defined cross-compatible university
    programs internationally, and after that, governance can follow. If we have mature standards and institutes teaching
    them, we can form boards, issue permits, and develop a credit system to ensure up-to-date knowledge, all the
    necessary bad coming with a regular engineering field.</p>

<p class="pb-4">Considering these two trends and their progress on a timeline, I have chosen to stress modern
    architecture and domain-driven development. I hope that even if everything else changes, the perspectives found
    behind these patterns will last. Modern architectural patterns, especially in Web development, are de-facto
    standards and unlikely to change, contrary to languages, frameworks, and language-specific patterns.</p>

<p class="pb-8">To finish in 3 hours per week, we build an MVC application with an API back-end and a reactive front-end
    using frameworks. The technology stack is always up to student preference as long as I'm proficient enough with the
    chosen technologies to scale the difficulty on the go. Additionally, we practice proper version control, code
    documentation, unit testing, and a bit of project management as well.</p>

<h1>Technology stack</h1>

<p class="pb-4">Since we are mimicking a real-life business scenario, the technology stack always starts with proper version control. That is not changeable, not debatable. We are using git and GitHub. There are three main reasons behind this: it is the most popular VCS, it allows free private repositories to practice on, and finally, it has an integrated project management system. That leaves us to use GitHub for practicing project management techniques as well.</p>

<p class="pb-8">The rest of the stack is more or less up to the students. There are two constraints. I need to be proficient in the selected technologies and we must choose a separate back-end and front-end framework. By default, my preferred choice is a Laravel back-end with an Angular front-end. Laravel is a convenient choice as students learn Web programming through PHP earlier in their studies, and it is a flexible system in terms of used features. Angular is mostly a personal preference. Alternatives can be Vue, React, ASP.NET MVC, or NestJS.</p>

<h1>Traveling in time with a hint of bureaucracy</h1>

<p class="pb-4">We start the course by practicing proper teamwork using git and GitHub. In the first two weeks, we learn the basic terms (e.g. commit, staging, branch, origin, remote), visualize branches to see what's happening under the hood, and practice git CLI (command line interface) commands. In this phase, students are only allowed to work in CLIs to understand and memorize each git command more easily by parametrizing them over and over again.</p>

<p class="pb-4">When everybody is familiar with the environment, the basic commands, navigating through the local git structure, and validating the remote state on GitHub, we proceed by forming groups working together. That is the exciting part, as we are getting into branching, merging, and rebasing with the necessary underlying concepts. We learn by making mistakes when possible. We create conflicts, try to solve them, and even end up in situations where a hard reset is the only way forward at this skill level. In the end, students learn about the typical pitfalls and how to avoid them.</p>

<img class="w-full pb-2" src="/assets/stories/software-development-technologies/git.jpg" />
<p class="pb-8 text-center text-sm">We are talking about and visualizing workflows, graphs and commands until most students have a basic idea about proper version control techniques.</p>

<p class="pb-4">While we are dealing with GitHub, I think it's better to stay a bit longer and learn some basic project management techniques. First, we talk about Agile. We discuss what Agile is (a software developer attitude recommendation), what Agile is not (Scrum), and how (and why) a lot of companies understand and misuse it (dogmatically enforced Scrum). The key point I try to convey here is there is no universal optimal management solution in IT, however, if we understand the different techniques (Agile, Waterfall, and even Impact engineering), understand the current requirements, and only utilize the right mix afterward, we cannot fall far from the target.</p>

<p class="pb-8">With all these theories behind us, we can delve into the practical realm of GitHub Projects. We learn to use the Kanban board and the Gantt roadmap views of GitHub's integrated project management system and start to create user stories and formulate development tasks from them. At this point, students have already composed a list of themes for the class project we can choose one from by voting. This article is based on the class of 2024, which voted for a job platform called GetHired. While we know we can only implement a limited set of features during the semester, we go wild and create tasks for a complete application.</p>

<h1>Design-first</h1>

<p class="pb-4">The user stories and the related issues provide us with a great starting point in architecture. We can use all that information to prioritize features necessary for the application to work in its simplest form. The next phase is system planning, which we start with the back-end. The back-end always contains more business logic, layers, and complexity than the front-end, thus we can practice creating different plan documentation and understand the backbone of our software.</p>

<p class="pb-4">In the following weeks, we go through a basic CRUD back-end system layer by layer. Every layer is a new milestone. We start every milestone by discussing key concepts, like design patterns, conventions, and best practices. The first milestone, the database, is a prime example. We design a table structure for the theme at hand and create ERDs (entity-relation diagrams) if we have time. We discuss database normalization, relationships, code-first and database-first approaches, mapping tables, and migrations. When everything is clear, we create the table structure for the first few tables we would like to use in our application, author some migrations, and continue with the next layer.</p>

<img class="w-full pb-2" src="/assets/stories/software-development-technologies/db.jpeg" />
<p class="pb-8 text-center text-sm">We try to discuss as many conceptual aspects of planning a single layer in our application as possible. 3 and 5 are the normal forms I recommend to strive for with different database design approaches.</p>

<p class="pb-4">The rest of the back-end heavily relies on language-specific patterns, therefore, the other layers usually change yearly. For the Laravel application, we go into environments, controllers, routes, models, middlewares, JWTs (JSON Web Tokens), database transactions, and the Eloquent ORM (object-relational mapping). If we have time, we can also discuss service providers and facades. For ASP.NET MVC applications, we usually cover configurations, services, and IoC (inversion of control) related concepts, as they are hard to avoid. Commonly, we always draw a lot of class diagrams and sequence diagrams. Sometimes flowcharts as well.</p>

<img class="w-full pb-2" src="/assets/stories/software-development-technologies/seq.jpeg" />
<p class="pb-8 text-center text-sm">Sequece diagrams describing some facets of a typical Laravel application.</p>

<h1>Graphical complexity</h1>

<p class="pb-4">When the back-end becomes sufficiently complex to provide some data to display, we switch to the front-end temporarily. In this phase, we focus on the GUI until we get a decently-looking web application. After that, we continue developing both sides in parallel until the end of the semester. We need to choose two things at this point: a template and a framework.</p>

<p class="pb-4">Choosing a framework to create a front-end for an API back-end might sound like an overshoot for a class, but every framework holds a degree of architectural uniqueness, usable to understand better how modern web applications work. Experience from years of this class tells me that learning a front-end framework after understanding core concepts in a back-end framework is much easier for students, as they are relatively similar.</p>

<p class="pb-4">My preference for Angular has two aspects. First, it gives me the best DX (developer experience) from the available front-end frameworks. It is a robust, clean, elegant, well-designed, and scalable technology. Second, it adheres to SOLID principles so well, that its SRP (single responsibility principle) design makes it an outstanding candidate to learn about IoC through it. We can go through the whole DI (dependency injection) pipeline just like links in a chain. I emphasize this single concept because it is the most complicated to understand for students new to IoC and modern frameworks. The easier I can demonstrate what happens under the hood, the better. Angular is a real treasure here, especially with standalone components.</p>

<img class="w-full pb-2" src="/assets/stories/software-development-technologies/ioc.jpeg" />
<p class="pb-8 text-center text-sm">Understanding IoC is no easy feat. We draw pipelines and examine providers (buckets as an analogy) and injectors. Finally, we demonstrate by making errors and debugging them.</p>

<p class="pb-8">The rest of the front-end phase is about reactivity and framework-specific design patterns. Nothing special, just pages, components, and services. We focus on getting familiar with TypeScript and we discuss patterns we come across during development. Usually, we use forms, we end up with a modular application, but sometimes we deal with rxjs classes directly or create guards or interceptors.</p>

<h1>And the rest</h1>

<p class="pb-4">Course requirements include clean code, proper code documentation, and unit tests. We are picking up clean code patterns throughout development, but the other two need additional time to explain. I usually take some time from the middle of the course to discuss code documentation. Preferably when we already have some classes, methods, and properties to decorate in both frameworks. It is mostly about syntax and sources. We look for websites showing examples of the de-facto standard code documentation syntax for the selected languages and see how the IDE is getting more competent with every documented symbol, even in weakly typed environments.</p>

<p class="pb-4">Unit testing is usually the last lessons' topic. The main reason is that writing unit tests is not my favorite part of software development and students are more eager to develop features as well. Still, this is so important, that we need to talk about it for at least a week. I like to focus on patterns in unit testing, like AAA (arrange, act, assert, not the other one). Once there, we also discuss the three-letter software design approaches, especially TDD (test-driven design). While not a big fan of TDD, I like to show students scenarios where it is feasible to use and strengthen the idea in them that there are no bad patterns, just inappropriate situations to apply them.</p>

<h1>Source code</h1>

<p class="pb-4">The source code for a sample Software Development Technologies course can be found in the following respositories: <a href="https://github.com/GaborFarkas/sw-dev-tech-sample-front-end">https://github.com/GaborFarkas/sw-dev-tech-sample-front-end</a> for the front-end and <a href="https://github.com/GaborFarkas/sw-dev-tech-sample-back-end">https://github.com/GaborFarkas/sw-dev-tech-sample-back-end</a> for the back-end.</p>

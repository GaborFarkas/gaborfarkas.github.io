<h1>Synopsis</h1>

<p class="pb-4">Software Development Technologies is a mandatory course in the Computer Science BSc program of the
    University of PÃ©cs, Institute of Mathematics and Informatics. This course was designed to expose our students to
    technologies widely used in high-tech business scenarios, such as organizations, companies, enterprises, or
    startups. During the past few years, we refined the concept to a simple form of showing what the future holds. But
    hold on! How can anyone be certain about the future of software development? We can't. However, we can forecast some
    rough and fairly safe approximations based on the trends of the past few decades.</p>

<p class="pb-2">Let's start with recent trends. We can see articles in mainstream tech media arguing and philosophizing
    about different trends, patterns, and technologies in software development. While most "tech evangelists" are
    currently preoccupied with AI, if we look close (or far) enough, we can see a shaded picture full of uncertainty and
    sometimes even anxiety. Some of the popular topics I find particularly interesting are the following:</p>
<ul class="list-disc pl-10 pb-4">
    <li>Platforms everywhere (SaaS, IaaS, PaaS), cloud computing is the future.</li>
    <li>We need to revolutionize finance with cryptography. Blockchains are the future.</li>
    <li>We have working software packages for everything, we just have to connect them together. Infrastructure and
        DevOps are the future.</li>
    <li>Soon enough AI will be able to create quality code. Data engineering is the future.</li>
</ul>

<p class="pb-4">While there are bits of wisdom in these and other hot tech topics (e.g. expert systems, low-code), I
    consider most of them noise. If I look at these topics with smaller, more hands-on developments on a timeline, I can
    see two significant trends I firmly believe in.</p>

<p class="pb-4">Programming, as in the capability of automatizing processes, will become part of basic literacy. With
    gradually lowering entry skill requirements (scripting languages, low-code environments, frameworks) and gradually
    increasing digital proficiency in newer generations, automatizing is reaching an ever wider audience. I like to use
    the analogy of literacy in medieval times as an example. People capable of reading and writing had better job
    opportunities, stronger positions, more influence, better chances, and a better quality of life. Slowly, more
    families had this skill to pass down, primary education became more available, and it stopped being the privilege of
    nobility. Now, most of us possess it. I believe, considering programming, we are dealing with a similar tendency.
</p>

<p class="pb-4">The second trend is an organic restructuring of software development we are in the middle of. The
    development of the Internet proved that standardization is beneficial for software development as well. From then
    on, the whole field moved towards standard (e.g. RFCs) or de-facto standard patterns and solutions (e.g. MVC, IoC,
    OAuth, GraphQL). This standardization process and proper governance are two requisites for a software engineering
    field to rise (not the self-proclaimed one we can see under every second IT expert's LinkedIn profile). With such a
    field having a self-contained guarantee system, we can have better-defined responsibility chains, build trust
    effortlessly, and have a more compatible and better plannable world of software and infrastructure. I believe that
    soon the level of standardization will enable higher education to build well-defined cross-compatible university
    programs internationally, and after that, governance can follow. If we have mature standards and institutes teaching
    them, we can form boards, issue permits, and develop a credit system to ensure up-to-date knowledge, all the
    necessary bad coming with a regular engineering field.</p>

<p class="pb-4">Considering these two trends and their progress on a timeline, I have chosen to stress modern
    architecture and domain-driven development. I hope that even if everything else changes, the perspectives found
    behind these patterns will last. Modern architectural patterns, especially in Web development, are de-facto
    standards and unlikely to change, contrary to languages, frameworks, and language-specific patterns.</p>

<p class="pb-4">To finish in 3 hours per week, we build an MVC application with an API back-end and a reactive front-end
    using frameworks. The technology stack is always up to student preference as long as I'm proficient enough with the
    chosen technologies to scale the difficulty on the go. Additionally, we practice proper version control, code
    documentation, unit testing, and a bit of project management as well.</p>

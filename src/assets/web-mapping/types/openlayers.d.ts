declare namespace ol {



/**
 * @module ol/events/Event
 */
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
declare class BaseEvent {
    /**
     * @param {string} type Type.
     */
    constructor(type: string);
    /**
     * @type {boolean}
     */
    propagationStopped: boolean;
    /**
     * @type {boolean}
     */
    defaultPrevented: boolean;
    /**
     * The event type.
     * @type {string}
     * @api
     */
    type: string;
    /**
     * The event target.
     * @type {Object}
     * @api
     */
    target: any;
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */
    preventDefault(): void;
    /**
     * Stop event propagation.
     * @api
     */
    stopPropagation(): void;
}

/**
 * @module ol/Disposable
 */
/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
declare class Disposable {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    protected disposed: boolean;
    /**
     * Clean up.
     */
    dispose(): void;
    /**
     * Extension point for disposable objects.
     * @protected
     */
    protected disposeInternal(): void;
}
//# sourceMappingURL=Disposable.d.ts.map

type EventTargetLike = EventTarget | Target;
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */
/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
declare class Target extends Disposable {
    /**
     * @param {*} [target] Default event target for dispatched events.
     */
    constructor(target?: any);
    /**
     * @private
     * @type {*}
     */
    private eventTarget_;
    /**
     * @private
     * @type {Object<string, number>|null}
     */
    private pendingRemovals_;
    /**
     * @private
     * @type {Object<string, number>|null}
     */
    private dispatching_;
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */
    private listeners_;
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    addEventListener(type: string, listener: Listener): void;
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
    dispatchEvent(event: BaseEvent | string): boolean | undefined;
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
    getListeners(type: string): Array<Listener> | undefined;
    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
    hasListener(type?: string): boolean;
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    removeEventListener(type: string, listener: Listener): void;
}

/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */
/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */
/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */
/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */
/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
declare function listen(target: EventTargetLike, type: string, listener: ListenerFunction, thisArg?: any, once?: boolean): EventsKey;
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
declare function listenOnce(target: EventTargetLike, type: string, listener: ListenerFunction, thisArg?: any): EventsKey;
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
declare function unlistenByKey(key: EventsKey): void;
/**
 * Key to use with {@link module :ol/Observable.unByKey}.
 */
type EventsKey = {
    /**
     * Listener.
     */
    listener: ListenerFunction;
    /**
     * Target.
     */
    target: EventTargetLike;
    /**
     * Type.
     */
    type: string;
};
/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 */
type ListenerFunction = (arg0: (Event | BaseEvent)) => (void | boolean);
type ListenerObject = {
    /**
     * HandleEvent listener function.
     */
    handleEvent: ListenerFunction;
};
type Listener = ListenerFunction | ListenerObject;

type Types$2 = "propertychange";

/**
 * *
 */
type OnSignature<Type extends string, EventClass extends Event | BaseEvent, Return> = (type: Type, listener: (event: EventClass) => unknown) => Return;
/**
 * *
 */
type CombinedOnSignature<Type extends string, Return> = (type: Type[], listener: (event: Event | BaseEvent) => unknown) => Return extends void ? void : Return[];
type EventTypes = "change" | "error";
/**
 * *
 */
type ObservableOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & CombinedOnSignature<EventTypes, Return>;
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */
/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */
/**
 * @typedef {'change'|'error'} EventTypes
 */
/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
declare class Observable extends Target {
    constructor();
    on: ObservableOnSignature<EventsKey>;
    once: ObservableOnSignature<EventsKey>;
    un: ObservableOnSignature<void>;
    /**
     * @private
     * @type {number}
     */
    private revision_;
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */
    changed(): void;
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
    getRevision(): number;
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    protected onInternal(type: string | Array<string>, listener: (arg0: (Event | BaseEvent)) => unknown): EventsKey | Array<EventsKey>;
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    protected onceInternal(type: string | Array<string>, listener: (arg0: (Event | BaseEvent)) => unknown): EventsKey | Array<EventsKey>;
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
    protected unInternal(type: string | Array<string>, listener: (arg0: (Event | BaseEvent)) => unknown): void;
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
declare class ObjectEvent extends BaseEvent {
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    constructor(type: string, key: string, oldValue: any);
    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    key: string;
    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    oldValue: any;
}

/**
 * *
 */
type ObjectOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2, ObjectEvent, Return> & CombinedOnSignature<EventTypes | Types$2, Return>;

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
declare class BaseObject extends Observable {
    /**
     * @param {Object<string, *>} [values] An object with key-value pairs.
     */
    constructor(values?: {
        [x: string]: any;
    });
    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    on: ObjectOnSignature<EventsKey>;
    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    once: ObjectOnSignature<EventsKey>;
    /***
     * @type {ObjectOnSignature<void>}
     */
    un: ObjectOnSignature<void>;
    /**
     * @private
     * @type {Object<string, *>|null}
     */
    private values_;
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */
    get(key: string): any;
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
    getKeys(): Array<string>;
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
    getProperties(): {
        [x: string]: any;
    };
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal(): {
        [x: string]: any;
    } | null;
    /**
     * @return {boolean} The object has properties.
     */
    hasProperties(): boolean;
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
    notify(key: string, oldValue: any): void;
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    addChangeListener(key: string, listener: Listener): void;
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    removeChangeListener(key: string, listener: Listener): void;
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    set(key: string, value: any, silent?: boolean): void;
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    setProperties(values: {
        [x: string]: any;
    }, silent?: boolean): void;
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
    protected applyProperties(source: BaseObject): void;
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */
    unset(key: string, silent?: boolean): void;
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */
declare class CollectionEvent<T> extends BaseEvent {
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {T} element Element.
     * @param {number} index The index of the added or removed element.
     */
    constructor(type: any, element: T, index: number);
    /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */
    element: T;
    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */
    index: number;
}

/**
 * *
 */
type CollectionOnSignature<T, Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:length", ObjectEvent, Return> & OnSignature<"add" | "remove", CollectionEvent<T>, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:length" | "add" | "remove", Return>;
type Options$1T = {
    /**
     * Disallow the same item from being added to
     * the collection twice.
     */
    unique?: boolean | undefined;
};

/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */
/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
declare class Collection<T> extends BaseObject {
    /**
     * @param {Array<T>} [array] Array.
     * @param {Options} [options] Collection options.
     */
    constructor(array?: Array<T>, options?: Options$1T);
    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    on: CollectionOnSignature<T, EventsKey>;
    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    once: CollectionOnSignature<T, EventsKey>;
    /***
     * @type {CollectionOnSignature<T, void>}
     */
    un: CollectionOnSignature<T, void>;
    /**
     * @private
     * @type {boolean}
     */
    private unique_;
    /**
     * @private
     * @type {!Array<T>}
     */
    private array_;
    /**
     * Remove all elements from the collection.
     * @api
     */
    clear(): void;
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
    extend(arr: Array<T>): Collection<T>;
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
    forEach(f: (arg0: T, arg1: number, arg2: Array<T>) => any): void;
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
    getArray(): Array<T>;
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
    item(index: number): T;
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
    getLength(): number;
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    insertAt(index: number, elem: T): void;
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
    pop(): T | undefined;
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
    push(elem: T): number;
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
    remove(elem: T): T | undefined;
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
    removeAt(index: number): T | undefined;
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    setAt(index: number, elem: T): void;
    /**
     * @private
     */
    private updateLength_;
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */
    private assertUnique_;
}

/**
 * @module ol/size
 */
/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */
/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */
declare function buffer$1(size: Size, num: number, dest?: Size): Size;
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
declare function hasArea(size: Size): boolean;
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */
declare function scale$4(size: Size, ratio: number, dest?: Size): Size;
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
declare function toSize(size: number | Size, dest?: Size): Size;
/**
 * An array of numbers representing a size: `[width, height]`.
 */
type Size = Array<number>;

/**
 * @module ol/array
 */
/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
declare function binarySearch(haystack: Array<any>, needle: any, comparator?: Function): number;
/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
declare function ascending(a: any, b: any): number;
/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */
declare function descending(a: any, b: any): number;
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */
/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
declare function linearFindNearest(arr: Array<number>, target: number, direction: number | NearestDirectionFunction): number;
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
declare function reverseSubArray(arr: Array<any>, begin: number, end: number): void;
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
declare function extend$1<VALUE>(arr: Array<VALUE>, data: Array<VALUE> | VALUE): void;
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
declare function remove$1<VALUE>(arr: Array<VALUE>, obj: VALUE): boolean;
/**
 * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
declare function equals$2(arr1: Array<any> | Uint8ClampedArray, arr2: Array<any> | Uint8ClampedArray): boolean;
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
declare function stableSort(arr: Array<any>, compareFnc: (arg0: any, arg1: any) => number): void;
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
declare function isSorted(arr: Array<any>, func?: Function, strict?: boolean): boolean;
/**
 * {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 */
type NearestDirectionFunction = (arg0: number, arg1: number, arg2: number) => number;

/**
 * @module ol/TileRange
 */
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
declare class TileRange {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */
    constructor(minX: number, maxX: number, minY: number, maxY: number);
    /**
     * @type {number}
     */
    minX: number;
    /**
     * @type {number}
     */
    maxX: number;
    /**
     * @type {number}
     */
    minY: number;
    /**
     * @type {number}
     */
    maxY: number;
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */
    contains(tileCoord: TileCoord): boolean;
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
    containsTileRange(tileRange: TileRange): boolean;
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
    containsXY(x: number, y: number): boolean;
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
    equals(tileRange: TileRange): boolean;
    /**
     * @param {TileRange} tileRange Tile range.
     */
    extend(tileRange: TileRange): void;
    /**
     * @return {number} Height.
     */
    getHeight(): number;
    /**
     * @return {import("./size.js").Size} Size.
     */
    getSize(): Size;
    /**
     * @return {number} Width.
     */
    getWidth(): number;
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */
    intersects(tileRange: TileRange): boolean;
}

/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
declare function fromCode(code: number): Units$1;
/**
 * @typedef {Object} MetersPerUnitLookup
 * @property {number} radians Radians
 * @property {number} degrees Degrees
 * @property {number} ft  Feet
 * @property {number} m Meters
 * @property {number} us-ft US feet
 */
/**
 * Meters per unit lookup table.
 * @const
 * @type {MetersPerUnitLookup}
 * @api
 */
declare const METERS_PER_UNIT$1: MetersPerUnitLookup;
/**
 * Projection units.
 */
type Units$1 = "radians" | "degrees" | "ft" | "m" | "pixels" | "tile-pixels" | "us-ft";
type MetersPerUnitLookup = {
    /**
     * Radians
     */
    radians: number;
    /**
     * Degrees
     */
    degrees: number;
    /**
     * Feet
     */
    ft: number;
    /**
     * Meters
     */
    m: number;
    /**
     * US feet
     */
    "us-ft": number;
};

/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */
declare function disableCoordinateWarning(disable?: boolean): void;
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
declare function cloneTransform(input: Array<number>, output?: Array<number>): Array<number>;
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
declare function identityTransform(input: Array<number>, output?: Array<number>): Array<number>;
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
declare function addProjection(projection: Projection): void;
/**
 * @param {Array<Projection>} projections Projections.
 */
declare function addProjections(projections: Array<Projection>): void;
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */
declare function get$2(projectionLike: ProjectionLike): Projection | null;
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
declare function getPointResolution(projection: ProjectionLike, resolution: number, point: Coordinate, units?: Units$1): number;
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
declare function addEquivalentProjections(projections: Array<Projection>): void;
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
declare function addEquivalentTransforms(projections1: Array<Projection>, projections2: Array<Projection>, forwardTransform: TransformFunction, inverseTransform: TransformFunction): void;
/**
 * Clear all cached projections and transforms.
 */
declare function clearAllProjections(): void;
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
declare function createProjection(projection: Projection | string | undefined, defaultCode: string): Projection;
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
declare function createTransformFromCoordinateTransform(coordTransform: (arg0: Coordinate) => Coordinate): TransformFunction;
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */
declare function addCoordinateTransforms(source: ProjectionLike, destination: ProjectionLike, forward: (arg0: Coordinate) => Coordinate, inverse: (arg0: Coordinate) => Coordinate): void;
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
declare function fromLonLat(coordinate: Coordinate, projection?: ProjectionLike): Coordinate;
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
declare function toLonLat(coordinate: Coordinate, projection?: ProjectionLike): Coordinate;
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
declare function equivalent(projection1: Projection, projection2: Projection): boolean;
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} source Source Projection object.
 * @param {Projection} destination Destination Projection
 *     object.
 * @return {TransformFunction|null} Transform function.
 */
declare function getTransformFromProjections(source: Projection, destination: Projection): TransformFunction | null;
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
declare function getTransform(source: ProjectionLike, destination: ProjectionLike): TransformFunction;
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original). If there
 * is no available transform between the two projection, the function will throw
 * an error.
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
declare function transform(coordinate: Coordinate, source: ProjectionLike, destination: ProjectionLike): Coordinate;
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
declare function transformExtent(extent: Extent$1, source: ProjectionLike, destination: ProjectionLike, stops?: number): Extent$1;
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
declare function transformWithProjections(point: Coordinate, sourceProjection: Projection, destinationProjection: Projection): Coordinate;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */
declare function setUserProjection(projection: ProjectionLike): void;
/**
 * Clear the user projection if set.
 * @api
 */
declare function clearUserProjection(): void;
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */
declare function getUserProjection(): Projection | null;
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */
declare function useGeographic(): void;
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
declare function toUserCoordinate(coordinate: Array<number>, sourceProjection: ProjectionLike): Array<number>;
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
declare function fromUserCoordinate(coordinate: Array<number>, destProjection: ProjectionLike): Array<number>;
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
declare function toUserExtent(extent: Extent$1, sourceProjection: ProjectionLike): Extent$1;
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
declare function fromUserExtent(extent: Extent$1, destProjection: ProjectionLike): Extent$1;
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
declare function toUserResolution(resolution: number, sourceProjection: ProjectionLike): number;
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
declare function fromUserResolution(resolution: number, destProjection: ProjectionLike): number;
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */
declare function createSafeCoordinateTransform(sourceProj: Projection, destProj: Projection, transform: (arg0: Coordinate) => Coordinate): (arg0: Coordinate) => Coordinate;
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
declare function addCommon(): void;
/**
 * A projection as {@link module :ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 */
type ProjectionLike = Projection | string | undefined;
type Transforms = {
    /**
     * The forward transform (from geographic).
     */
    forward: TransformFunction;
    /**
     * The inverse transform (to geographic).
     */
    inverse: TransformFunction;
};
/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 */
type TransformFunction = (input: Array<number>, output?: number[] | undefined, dimension?: number | undefined, stride?: number | undefined) => Array<number>;

/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */
/**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */
/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
declare function boundingExtent(coordinates: Array<Coordinate>): Extent$1;
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */
declare function buffer(extent: Extent$1, value: number, dest?: Extent$1): Extent$1;
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */
declare function clone(extent: Extent$1, dest?: Extent$1): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
declare function closestSquaredDistanceXY(extent: Extent$1, x: number, y: number): number;
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
declare function containsCoordinate(extent: Extent$1, coordinate: Coordinate): boolean;
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
declare function containsExtent(extent1: Extent$1, extent2: Extent$1): boolean;
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
declare function containsXY(extent: Extent$1, x: number, y: number): boolean;
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
declare function coordinateRelationship(extent: Extent$1, coordinate: Coordinate): any;
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
declare function createEmpty(): Extent$1;
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
declare function createOrUpdate$1(minX: number, minY: number, maxX: number, maxY: number, dest?: Extent$1): Extent$1;
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
declare function createOrUpdateEmpty(dest?: Extent$1): Extent$1;
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
declare function createOrUpdateFromCoordinate(coordinate: Coordinate, dest?: Extent$1): Extent$1;
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
declare function createOrUpdateFromCoordinates(coordinates: Array<Coordinate>, dest?: Extent$1): Extent$1;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
declare function createOrUpdateFromFlatCoordinates(flatCoordinates: Array<number>, offset: number, end: number, stride: number, dest?: Extent$1): Extent$1;
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
declare function createOrUpdateFromRings(rings: Array<Array<Coordinate>>, dest?: Extent$1): Extent$1;
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
declare function equals$1(extent1: Extent$1, extent2: Extent$1): boolean;
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
declare function approximatelyEquals(extent1: Extent$1, extent2: Extent$1, tolerance: number): boolean;
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
declare function extend(extent1: Extent$1, extent2: Extent$1): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
declare function extendCoordinate(extent: Extent$1, coordinate: Coordinate): void;
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
declare function extendCoordinates(extent: Extent$1, coordinates: Array<Coordinate>): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
declare function extendFlatCoordinates(extent: Extent$1, flatCoordinates: Array<number>, offset: number, end: number, stride: number): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
declare function extendRings(extent: Extent$1, rings: Array<Array<Coordinate>>): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
declare function extendXY(extent: Extent$1, x: number, y: number): void;
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
declare function forEachCorner<S>(extent: Extent$1, callback: (arg0: Coordinate) => S): S | boolean;
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
declare function getArea$1(extent: Extent$1): number;
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
declare function getBottomLeft(extent: Extent$1): Coordinate;
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
declare function getBottomRight(extent: Extent$1): Coordinate;
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
declare function getCenter(extent: Extent$1): Coordinate;
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
declare function getCorner(extent: Extent$1, corner: Corner): Coordinate;
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
declare function getEnlargedArea(extent1: Extent$1, extent2: Extent$1): number;
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
declare function getForViewAndSize(center: Coordinate, resolution: number, rotation: number, size: Size, dest?: Extent$1): Extent$1;
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */
declare function getRotatedViewport(center: Coordinate, resolution: number, rotation: number, size: Size): Array<number>;
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
declare function getHeight(extent: Extent$1): number;
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
declare function getIntersectionArea(extent1: Extent$1, extent2: Extent$1): number;
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
declare function getIntersection(extent1: Extent$1, extent2: Extent$1, dest?: Extent$1): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
declare function getMargin(extent: Extent$1): number;
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
declare function getSize(extent: Extent$1): Size;
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
declare function getTopLeft(extent: Extent$1): Coordinate;
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
declare function getTopRight(extent: Extent$1): Coordinate;
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
declare function getWidth(extent: Extent$1): number;
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
declare function intersects$1(extent1: Extent$1, extent2: Extent$1): boolean;
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
declare function isEmpty$1(extent: Extent$1): boolean;
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
declare function returnOrUpdate(extent: Extent$1, dest?: Extent$1): Extent$1;
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
declare function scaleFromCenter(extent: Extent$1, value: number): void;
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
declare function intersectsSegment(extent: Extent$1, start: Coordinate, end: Coordinate): boolean;
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
declare function applyTransform(extent: Extent$1, transformFn: TransformFunction, dest?: Extent$1, stops?: number): Extent$1;
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
declare function wrapX$2(extent: Extent$1, projection: Projection): Extent$1;
/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @param {boolean} [multiWorld] Return all worlds
 * @return {Array<Extent>} The extent within the real world extent.
 */
declare function wrapAndSliceX(extent: Extent$1, projection: Projection, multiWorld?: boolean): Array<Extent$1>;
/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 */
type Extent$1 = Array<number>;
/**
 * Extent corner.
 */
type Corner = "bottom-left" | "bottom-right" | "top-left" | "top-right";

type Options$1S = {
    /**
     * The SRS identifier code, e.g. `EPSG:4326`.
     */
    code: string;
    /**
     * Units. Required unless a
     * proj4 projection is defined for `code`.
     */
    units?: Units$1 | undefined;
    /**
     * The validity extent for the SRS.
     */
    extent?: Extent$1 | undefined;
    /**
     * The axis orientation as specified in Proj4.
     */
    axisOrientation?: string | undefined;
    /**
     * Whether the projection is valid for the whole globe.
     */
    global?: boolean | undefined;
    /**
     * The meters per unit for the SRS.
     * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}lookup table.
     */
    metersPerUnit?: number | undefined;
    /**
     * The world extent for the SRS.
     */
    worldExtent?: Extent$1 | undefined;
    /**
     * Function to determine resolution at a point. The function is called with a
     * `number` view resolution and a {@link module :ol/coordinate~Coordinate} as arguments, and returns
     * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
     * the default {@link module :ol/proj.getPointResolution} function will be used.
     */
    getPointResolution?: ((arg0: number, arg1: Coordinate) => number) | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */
/**
 * @classdesc
 * In most cases, you should not need to create instances of this class.
 * Instead, where projection information is required, you can use a string
 * projection code or identifier (e.g. `EPSG:4326`) instead of a projection
 * instance.
 *
 * The library includes support for transforming coordinates between the following
 * projections:
 *
 *  * WGS 84 / Geographic - Using codes `EPSG:4326`, `CRS:84`, `urn:ogc:def:crs:EPSG:6.6:4326`,
 *    `urn:ogc:def:crs:OGC:1.3:CRS84`, `urn:ogc:def:crs:OGC:2:84`, `http://www.opengis.net/gml/srs/epsg.xml#4326`,
 *    or `urn:x-ogc:def:crs:EPSG:4326`
 *  * WGS 84 / Spherical Mercator - Using codes `EPSG:3857`, `EPSG:102100`, `EPSG:102113`, `EPSG:900913`,
 *    `urn:ogc:def:crs:EPSG:6.18:3:3857`, or `http://www.opengis.net/gml/srs/epsg.xml#3857`
 *  * WGS 84 / UTM zones - Using codes `EPSG:32601` through `EPSG:32660` for northern zones
 *    and `EPSG:32701` through `EPSG:32760` for southern zones. Note that the built-in UTM transforms
 *    are lower accuracy (with errors on the order of 0.1 m) than those that you might get in a
 *    library like [proj4js](https://github.com/proj4js/proj4js).
 *
 * For additional projection support, or to use higher accuracy transforms than the built-in ones, you can use
 * the [proj4js](https://github.com/proj4js/proj4js) library. With `proj4js`, after adding any new projection
 * definitions, call the {@link module:ol/proj/proj4.register} function.
 *
 * You can use the {@link module:ol/proj.get} function to retrieve a projection instance
 * for one of the registered projections.
 *
 * @api
 */
declare class Projection {
    /**
     * @param {Options} options Projection options.
     */
    constructor(options: Options$1S);
    /**
     * @private
     * @type {string}
     */
    private code_;
    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */
    private units_;
    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    private extent_;
    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    private worldExtent_;
    /**
     * @private
     * @type {string}
     */
    private axisOrientation_;
    /**
     * @private
     * @type {boolean}
     */
    private global_;
    /**
     * @private
     * @type {boolean}
     */
    private canWrapX_;
    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */
    private getPointResolutionFunc_;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    private defaultTileGrid_;
    /**
     * @private
     * @type {number|undefined}
     */
    private metersPerUnit_;
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    canWrapX(): boolean;
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    getCode(): string;
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(): Extent$1;
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */
    getUnits(): Units$1;
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    getMetersPerUnit(): number | undefined;
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getWorldExtent(): Extent$1;
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    getAxisOrientation(): string;
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    isGlobal(): boolean;
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    setGlobal(global: boolean): void;
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    getDefaultTileGrid(): TileGrid;
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    setDefaultTileGrid(tileGrid: TileGrid): void;
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    setExtent(extent: Extent$1): void;
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    setWorldExtent(worldExtent: Extent$1): void;
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    setGetPointResolution(func: (arg0: number, arg1: Coordinate) => number): void;
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    getPointResolutionFunc(): (arg0: number, arg1: Coordinate) => number | undefined;
}

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */
type GeometryLayout = "XY" | "XYZ" | "XYM" | "XYZM";
/**
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */
type Type$5 = "Point" | "LineString" | "LinearRing" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection" | "Circle";
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
declare class Geometry$1 extends BaseObject {
    constructor();
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private extent_;
    /**
     * @private
     * @type {number}
     */
    private extentRevision_;
    /**
     * @protected
     * @type {number}
     */
    protected simplifiedGeometryMaxMinSquaredTolerance: number;
    /**
     * @protected
     * @type {number}
     */
    protected simplifiedGeometryRevision: number;
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    simplifyTransformedInternal: (...arg0: any[]) => Geometry$1;
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    simplifyTransformed(squaredTolerance: number, transform?: TransformFunction): Geometry$1;
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
    clone(): Geometry$1;
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x: number, y: number, closestPoint: Coordinate, minSquaredDistance: number): number;
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(x: number, y: number): boolean;
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
    getClosestPoint(point: Coordinate, closestPoint?: Coordinate): Coordinate;
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
    intersectsCoordinate(coordinate: Coordinate): boolean;
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    protected computeExtent(extent: Extent$1): Extent$1;
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
    getExtent(extent?: Extent$1): Extent$1;
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(angle: number, anchor: Coordinate): void;
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(sx: number, sy?: number, anchor?: Coordinate): void;
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
    simplify(tolerance: number): Geometry$1;
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
    getSimplifiedGeometry(squaredTolerance: number): Geometry$1;
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */
    getType(): Type$5;
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
    applyTransform(transformFn: TransformFunction): void;
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
    intersectsExtent(extent: Extent$1): boolean;
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(deltaX: number, deltaY: number): void;
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {this} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
    transform(source: ProjectionLike, destination: ProjectionLike): this;
}

/**
 * An array with two elements, representing a pixel. The first element is the
 * x-coordinate, the second the y-coordinate of the pixel.
 */
type Pixel = Array<number>;

/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
declare function create$1(): Transform;
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
declare function reset(transform: Transform): Transform;
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
declare function multiply(transform1: Transform, transform2: Transform): Transform;
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
declare function set(transform: Transform, a: number, b: number, c: number, d: number, e: number, f: number): Transform;
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
declare function setFromArray(transform1: Transform, transform2: Transform): Transform;
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
declare function apply(transform: Transform, coordinate: Coordinate | Pixel): Coordinate | Pixel;
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
declare function rotate$2(transform: Transform, angle: number): Transform;
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
declare function scale$3(transform: Transform, x: number, y: number): Transform;
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
declare function makeScale(target: Transform, x: number, y: number): Transform;
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
declare function translate$2(transform: Transform, dx: number, dy: number): Transform;
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
declare function compose(transform: Transform, dx1: number, dy1: number, sx: number, sy: number, angle: number, dx2: number, dy2: number): Transform;
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
declare function composeCssTransform(dx1: number, dy1: number, sx: number, sy: number, angle: number, dx2: number, dy2: number): string;
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
declare function invert(source: Transform): Transform;
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
declare function makeInverse(target: Transform, source: Transform): Transform;
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
declare function determinant(mat: Transform): number;
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
declare function toString$1(mat: Transform): string;
/**
 * An array representing an affine 2d transformation for use with
 * {@link module :ol/transform} functions. The array has 6 elements.
 */
type Transform = Array<number>;

/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
declare class SimpleGeometry extends Geometry$1 {
    /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */
    protected layout: GeometryLayout;
    /**
     * @protected
     * @type {number}
     */
    protected stride: number;
    /**
     * @protected
     * @type {Array<number>}
     */
    protected flatCoordinates: Array<number>;
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
    getCoordinates(): Array<any> | null;
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
    getFirstCoordinate(): Coordinate;
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getFlatCoordinates(): Array<number>;
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
    getLastCoordinate(): Coordinate;
    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */
    getLayout(): GeometryLayout;
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @override
     */
    override getSimplifiedGeometry(squaredTolerance: number): SimpleGeometry;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
    protected getSimplifiedGeometryInternal(squaredTolerance: number): SimpleGeometry;
    /**
     * @return {number} Stride.
     */
    getStride(): number;
    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
    setFlatCoordinates(layout: GeometryLayout, flatCoordinates: Array<number>): void;
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    setCoordinates(coordinates: Array<any>, layout?: GeometryLayout): void;
    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
    protected setLayout(layout: GeometryLayout | undefined, coordinates: Array<any>, nesting: number): void;
}

/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
declare class Circle extends SimpleGeometry {
    /**
     * @param {!import("../coordinate.js").Coordinate} center Center.
     *     For internal use, flat coordinates in combination with `layout` and no
     *     `radius` are also accepted.
     * @param {number} [radius] Radius in units of the projection.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(center: Coordinate, radius?: number, layout?: GeometryLayout);
    /**
     * Make a complete copy of the geometry.
     * @return {!Circle} Clone.
     * @api
     * @override
     */
    override clone(): Circle;
    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */
    getCenter(): Coordinate;
    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */
    getRadius(): number;
    /**
     * @private
     * @return {number} Radius squared.
     */
    private getRadiusSquared_;
    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */
    setCenter(center: Coordinate): void;
    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCenterAndRadius(center: Coordinate, radius: number, layout?: GeometryLayout): void;
    /**
     * @override
     */
    override getCoordinates(): null;
    /**
     * @override
     */
    override setCoordinates(coordinates: any, layout: any): void;
    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */
    setRadius(radius: number): void;
}
//# sourceMappingURL=Circle.d.ts.map

/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */
/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */
/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
declare function add$2(coordinate: Coordinate, delta: Coordinate): Coordinate;
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
declare function closestOnCircle(coordinate: Coordinate, circle: Circle): Coordinate;
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
declare function closestOnSegment(coordinate: Coordinate, segment: Array<Coordinate>): Coordinate;
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
declare function createStringXY(fractionDigits?: number): CoordinateFormat;
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
declare function degreesToStringHDMS(hemispheres: string, degrees: number, fractionDigits?: number): string;
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
declare function format(coordinate: Coordinate, template: string, fractionDigits?: number): string;
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
declare function equals(coordinate1: Coordinate, coordinate2: Coordinate): boolean;
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
declare function rotate$1(coordinate: Coordinate, angle: number): Coordinate;
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
declare function scale$2(coordinate: Coordinate, scale: number): Coordinate;
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
declare function squaredDistance$1(coord1: Coordinate, coord2: Coordinate): number;
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
declare function distance(coord1: Coordinate, coord2: Coordinate): number;
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
declare function squaredDistanceToSegment(coordinate: Coordinate, segment: Array<Coordinate>): number;
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
declare function toStringHDMS(coordinate: Coordinate, fractionDigits?: number): string;
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
declare function toStringXY(coordinate: Coordinate, fractionDigits?: number): string;
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
declare function wrapX$1(coordinate: Coordinate, projection: Projection): Coordinate;
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
declare function getWorldsAway(coordinate: Coordinate, projection: Projection, sourceExtentWidth?: number): number;
/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 */
type Coordinate = Array<number>;
/**
 * A function that takes a {@link module :ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 */
type CoordinateFormat = (arg0: (Coordinate | undefined)) => string;

type Options$1R = {
    /**
     * Extent for the tile grid. No tiles outside this
     * extent will be requested by {@link module :ol/source/Tile~TileSource} sources. When no `origin` or
     * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * Minimum zoom.
     */
    minZoom?: number | undefined;
    /**
     * The tile grid origin, i.e. where the `x`
     * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
     * specified, `extent` or `origins` must be provided.
     */
    origin?: Coordinate | undefined;
    /**
     * Tile grid origins, i.e. where
     * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
     * should match the length of the `resolutions` array, i.e. each resolution can have a different
     * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
     * `origin` must be provided.
     */
    origins?: Coordinate[] | undefined;
    /**
     * Resolutions. The array index of each resolution needs
     * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
     * array will have a length of `maxZoom + 1`.
     */
    resolutions: Array<number>;
    /**
     * Number of tile rows and columns
     * of the grid for each zoom level. If specified the values
     * define each zoom level's extent together with the `origin` or `origins`.
     * A grid `extent` can be configured in addition, and will further limit the extent
     * for which tile requests are made by sources. If the bottom-left corner of
     * an extent is used as `origin` or `origins`, then the `y` value must be
     * negative because OpenLayers tile coordinates use the top left as the origin.
     */
    sizes?: Size[] | undefined;
    /**
     * Tile size.
     * Default is `[256, 256]`.
     */
    tileSize?: number | Size | undefined;
    /**
     * Tile sizes. If given, the array length
     * should match the length of the `resolutions` array, i.e. each resolution can have a different
     * tile size.
     */
    tileSizes?: (number | Size)[] | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */
/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
declare class TileGrid {
    /**
     * @param {Options} options Tile grid options.
     */
    constructor(options: Options$1R);
    /**
     * @protected
     * @type {number}
     */
    protected minZoom: number;
    /**
     * @private
     * @type {!Array<number>}
     */
    private resolutions_;
    /**
     * @private
     * @type {number|undefined}
     */
    private zoomFactor_;
    /**
     * @protected
     * @type {number}
     */
    protected maxZoom: number;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    private origin_;
    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */
    private origins_;
    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */
    private tileSizes_;
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    private tileSize_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private extent_;
    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */
    private fullTileRanges_;
    /**
     * @private
     * @type {import("../size.js").Size}
     */
    private tmpSize_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private tmpExtent_;
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */
    forEachTileCoord(extent: Extent$1, zoom: number, callback: (arg0: TileCoord) => void): void;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */
    forEachTileCoordParentTileRange(tileCoord: TileCoord, callback: (arg0: number, arg1: TileRange) => boolean, tempTileRange?: TileRange, tempExtent?: Extent$1): boolean;
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(): Extent$1;
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
    getMaxZoom(): number;
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
    getMinZoom(): number;
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */
    getOrigin(z: number): Coordinate;
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
    getResolution(z: number): number;
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */
    getResolutions(): Array<number>;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileCoordChildTileRange(tileCoord: TileCoord, tempTileRange?: TileRange, tempExtent?: Extent$1): TileRange | null;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileRangeForTileCoordAndZ(tileCoord: TileCoord, z: number, tempTileRange?: TileRange): TileRange | null;
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    getTileRangeForExtentAndZ(extent: Extent$1, z: number, tempTileRange?: TileRange): TileRange;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */
    getTileCoordCenter(tileCoord: TileCoord): Coordinate;
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getTileCoordExtent(tileCoord: TileCoord, tempExtent?: Extent$1): Extent$1;
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndResolution(coordinate: Coordinate, resolution: number, opt_tileCoord?: TileCoord): TileCoord;
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    private getTileCoordForXYAndResolution_;
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    private getTileCoordForXYAndZ_;
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndZ(coordinate: Coordinate, z: number, opt_tileCoord?: TileCoord): TileCoord;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
    getTileCoordResolution(tileCoord: TileCoord): number;
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */
    getTileSize(z: number): number | Size;
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
     */
    getFullTileRange(z: number): TileRange | null;
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */
    getZForResolution(resolution: number, opt_direction?: number | NearestDirectionFunction): number;
    /**
     * The tile with the provided tile coordinate intersects the given viewport.
     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
     */
    tileCoordIntersectsViewport(tileCoord: TileCoord, viewport: Array<number>): boolean;
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */
    private calculateTileRanges_;
}

/**
 * @module ol/tilecoord
 */
/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
declare function createOrUpdate(z: number, x: number, y: number, tileCoord?: TileCoord): TileCoord;
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
declare function getKeyZXY(z: number, x: number, y: number): string;
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
declare function getKey(tileCoord: TileCoord): string;
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */
declare function getCacheKeyForTileKey(tileKey: string): string;
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
declare function fromKey(key: string): TileCoord;
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
declare function hash(tileCoord: TileCoord): number;
/**
 * @param {number} z The tile z coordinate.
 * @param {number} x The tile x coordinate.
 * @param {number} y The tile y coordinate.
 * @return {number} Hash.
 */
declare function hashZXY(z: number, x: number, y: number): number;
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
declare function withinExtentAndZ(tileCoord: TileCoord, tileGrid: TileGrid): boolean;
/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 */
type TileCoord = Array<number>;

/**
 * A function that takes a {@link module :ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 */
type LoadFunction$1 = (arg0: Tile$1, arg1: string) => void;
/**
 * {@link module :ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes a {@link module :ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module :ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 */
type UrlFunction = (arg0: TileCoord, arg1: number, arg2: Projection) => (string | undefined);
type Options$1Q = {
    /**
     * A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     */
    transition?: number | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
};
/**
 * A function that takes a {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */
/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */
/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */
/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
declare class Tile$1 extends Target {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [options] Tile options.
     */
    constructor(tileCoord: TileCoord, state: any, options?: Options$1Q);
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    tileCoord: TileCoord;
    /**
     * @protected
     * @type {import("./TileState.js").default}
     */
    protected state: any;
    /**
     * A key assigned to the tile. This is used in conjunction with a source key
     * to determine if a cached version of this tile may be used by the renderer.
     * @type {string}
     */
    key: string;
    /**
     * The duration for the opacity transition.
     * @private
     * @type {number}
     */
    private transition_;
    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @private
     * @type {Object<string, number>}
     */
    private transitionStarts_;
    /**
     * @type {boolean}
     */
    interpolate: boolean;
    /**
     * @protected
     */
    protected changed(): void;
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */
    release(): void;
    /**
     * @return {string} Key.
     */
    getKey(): string;
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */
    getTileCoord(): TileCoord;
    /**
     * @return {import("./TileState.js").default} State.
     */
    getState(): any;
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */
    setState(state: any): void;
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */
    load(): void;
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */
    getAlpha(id: string, time: number): number;
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */
    inTransition(id: string): boolean;
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */
    endTransition(id: string): void;
}

type ImageLike = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;
type ArrayLike = Uint8Array | Uint8ClampedArray | Float32Array | DataView;
/**
 * Data that can be used with a DataTile.
 */
type Data = ArrayLike | ImageLike;
type Options$1P = {
    /**
     * Tile coordinate.
     */
    tileCoord: TileCoord;
    /**
     * Data loader.  For loaders that generate images,
     * the promise should not resolve until the image is loaded.
     */
    loader: () => Promise<Data>;
    /**
     * A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     */
    transition?: number | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
    /**
     * Tile size.
     */
    size?: Size | undefined;
    /**
     * An abort controller.
     */
    controller?: AbortController | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,
 * the promise should not resolve until the image is loaded.
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {import('./size.js').Size} [size=[256, 256]] Tile size.
 * @property {AbortController} [controller] An abort controller.
 * @api
 */
declare class DataTile extends Tile$1 {
    /**
     * @param {Options} options Tile options.
     */
    constructor(options: Options$1P);
    /**
     * @type {function(): Promise<Data>}
     * @private
     */
    private loader_;
    /**
     * @type {Data}
     * @private
     */
    private data_;
    /**
     * @type {Error}
     * @private
     */
    private error_;
    /**
     * @type {import('./size.js').Size|null}
     * @private
     */
    private size_;
    /**
     * @type {AbortController|null}
     * @private
     */
    private controller_;
    /**
     * Get the tile size.
     * @return {import('./size.js').Size} Tile size.
     */
    getSize(): Size;
    /**
     * Get the data for the tile.
     * @return {Data} Tile data.
     * @api
     */
    getData(): Data;
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @api
     */
    getError(): Error;
}

/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
declare function asString(color: Color | string): string;
/**
 * @param {Color} color A color that may or may not have an alpha channel.
 * @return {Color} The input color with an alpha channel.  If the input color has
 * an alpha channel, the input color will be returned unchanged.  Otherwise, a new
 * array will be returned with the input color and an alpha channel of 1.
 */
declare function withAlpha(color: Color): Color;
/**
 * @param {Color} color RGBA color.
 * @return {Color} LCHuv color with alpha.
 */
declare function rgbaToLcha(color: Color): Color;
/**
 * @param {Color} color LCHuv color with alpha.
 * @return {Color} RGBA color.
 */
declare function lchaToRgba(color: Color): Color;
/**
 * @param {string} s String.
 * @return {Color} Color.
 */
declare function fromString(s: string): Color;
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
declare function asArray(color: Color | string): Color;
/**
 * Exported for the tests.
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
declare function normalize(color: Color): Color;
/**
 * @param {Color} color Color.
 * @return {string} String.
 */
declare function toString(color: Color): string;
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */
declare function isStringColor(s: string): boolean;
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */
/**
 * Color to indicate that no color should be rendered. This is meant to be used for per-reference
 * comparisons only.
 * @type {Color}
 */
declare const NO_COLOR: Color;
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 */
type Color = Array<number>;

/**
 * @typedef {Object} PatternDescriptor
 * @property {string} src Pattern image URL
 * @property {import("./color.js").Color|string} [color] Color to tint the pattern with.
 * @property {import("./size.js").Size} [size] Size of the desired slice from the pattern image.
 * Use this together with `offset` when the pattern image is a sprite sheet.
 * @property {import("./size.js").Size} [offset] Offset of the desired slice from the pattern image.
 * Use this together with `size` when the pattern image is a sprite sheet.
 */
/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, [CanvasPattern](https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern),
 * or [CanvasGradient](https://developer.mozilla.org/en-US/docs/Web/API/CanvasGradient). The origin for
 * patterns and gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */
/**
 * @param {import("./color.js").Color|ColorLike|PatternDescriptor|null} color Color.
 * @return {ColorLike|null} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
declare function asColorLike(color: Color | ColorLike | PatternDescriptor | null): ColorLike | null;
type PatternDescriptor = {
    /**
     * Pattern image URL
     */
    src: string;
    /**
     * Color to tint the pattern with.
     */
    color?: string | Color | undefined;
    /**
     * Size of the desired slice from the pattern image.
     * Use this together with `offset` when the pattern image is a sprite sheet.
     */
    size?: Size | undefined;
    /**
     * Offset of the desired slice from the pattern image.
     * Use this together with `size` when the pattern image is a sprite sheet.
     */
    offset?: Size | undefined;
};
/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, [CanvasPattern](https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern),
 * or [CanvasGradient](https://developer.mozilla.org/en-US/docs/Web/API/CanvasGradient). The origin for
 * patterns and gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 */
type ColorLike = string | CanvasPattern | CanvasGradient;

type Options$1O = {
    /**
     * A color, gradient or pattern.
     * See {@link module :ol/color~Color} and {@link module :ol/colorlike~ColorLike} for possible formats.
     * Default null; if null, the Canvas/renderer default black will be used.
     */
    color?: Color | ColorLike | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    lineCap?: CanvasLineCap | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    lineJoin?: CanvasLineJoin | undefined;
    /**
     * Line dash pattern. Default is `null` (no dash).
     */
    lineDash?: number[] | undefined;
    /**
     * Line dash offset.
     */
    lineDashOffset?: number | undefined;
    /**
     * Miter limit.
     */
    miterLimit?: number | undefined;
    /**
     * Width.
     */
    width?: number | undefined;
};
/**
 * @module ol/style/Stroke
 */
/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */
/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
declare class Stroke {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1O);
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */
    private color_;
    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */
    private lineCap_;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private lineDash_;
    /**
     * @private
     * @type {number|undefined}
     */
    private lineDashOffset_;
    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */
    private lineJoin_;
    /**
     * @private
     * @type {number|undefined}
     */
    private miterLimit_;
    /**
     * @private
     * @type {number|undefined}
     */
    private width_;
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */
    clone(): Stroke;
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
    getColor(): Color | ColorLike;
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
    getLineCap(): CanvasLineCap | undefined;
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */
    getLineDash(): Array<number> | null;
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    getLineDashOffset(): number | undefined;
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
    getLineJoin(): CanvasLineJoin | undefined;
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    getMiterLimit(): number | undefined;
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    getWidth(): number | undefined;
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
    setColor(color: Color | ColorLike): void;
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
    setLineCap(lineCap: CanvasLineCap | undefined): void;
    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */
    setLineDash(lineDash: Array<number> | null): void;
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    setLineDashOffset(lineDashOffset: number | undefined): void;
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
    setLineJoin(lineJoin: CanvasLineJoin | undefined): void;
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    setMiterLimit(miterLimit: number | undefined): void;
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    setWidth(width: number | undefined): void;
}

type Options$1N = {
    /**
     * A color,
     * gradient or pattern.
     * See {@link module :ol/color~Color} and {@link module :ol/colorlike~ColorLike} for possible formats. For polygon fills (not for {@link import ("./RegularShape.js").default} fills),
     * a pattern can also be provided as {@link module :ol/colorlike~PatternDescriptor}.
     * Default null; if null, the Canvas/renderer default black will be used.
     */
    color?: Color | ColorLike | PatternDescriptor | null | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} [color=null] A color,
 * gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats. For polygon fills (not for {@link import("./RegularShape.js").default} fills),
 * a pattern can also be provided as {@link module:ol/colorlike~PatternDescriptor}.
 * Default null; if null, the Canvas/renderer default black will be used.
 */
/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
declare class Fill {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1N);
    /**
     * @private
     * @type {import("./IconImage.js").default|null}
     */
    private patternImage_;
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null}
     */
    private color_;
    /**
     * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */
    clone(): Fill;
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
     * @api
     */
    getColor(): Color | ColorLike | PatternDescriptor | null;
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
     * @api
     */
    setColor(color: Color | ColorLike | PatternDescriptor | null): void;
    /**
     * @return {string} Key of the fill for cache lookup.
     */
    getKey(): string;
    /**
     * @return {boolean} The fill style is loading an image pattern.
     */
    loading(): boolean;
    /**
     * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
     */
    ready(): Promise<void>;
}

/**
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module :ol/geom/LineString~LineString},
 * {@link module :ol/geom/Polygon~Polygon}, {@link module :ol/geom/MultiLineString~MultiLineString} or
 * {@link module :ol/geom/MultiPolygon~MultiPolygon}.
 */
type TextPlacement = "point" | "line";
type TextJustify = "left" | "center" | "right";
type Options$1M = {
    /**
     * Font style as CSS `font` value, see:
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
     */
    font?: string | undefined;
    /**
     * When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
     * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
     */
    maxAngle?: number | undefined;
    /**
     * Horizontal text offset in pixels. A positive will shift the text right.
     */
    offsetX?: number | undefined;
    /**
     * Vertical text offset in pixels. A positive will shift the text down.
     */
    offsetY?: number | undefined;
    /**
     * For polygon labels or when `placement` is set to `'line'`, allow text to exceed
     * the width of the polygon at the label position or the length of the path that it follows.
     */
    overflow?: boolean | undefined;
    /**
     * Text placement.
     */
    placement?: TextPlacement | undefined;
    /**
     * Repeat interval. When set, the text will be repeated at this interval, which specifies
     * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
     */
    repeat?: number | undefined;
    /**
     * Scale.
     */
    scale?: number | Size | undefined;
    /**
     * Whether to rotate the text with the view.
     */
    rotateWithView?: boolean | undefined;
    /**
     * Whether the text can be rotated 180° to prevent being rendered upside down.
     */
    keepUpright?: boolean | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    rotation?: number | undefined;
    /**
     * Text content or rich text content. For plain text provide a string, which can
     * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
     * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
     * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
     * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
     */
    text?: string | string[] | undefined;
    /**
     * Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
     * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
     * placement where `maxAngle` is not exceeded.
     */
    textAlign?: CanvasTextAlign | undefined;
    /**
     * Text justification within the text box.
     * If not set, text is justified towards the `textAlign` anchor.
     * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
     * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
     */
    justify?: TextJustify | undefined;
    /**
     * Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
     * `'hanging'`, `'ideographic'`.
     */
    textBaseline?: CanvasTextBaseline | undefined;
    /**
     * Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
     */
    fill?: Fill | null | undefined;
    /**
     * Stroke style.
     */
    stroke?: Stroke | undefined;
    /**
     * Fill style for the text background when `placement` is
     * `'point'`. Default is no fill.
     */
    backgroundFill?: Fill | undefined;
    /**
     * Stroke style for the text background  when `placement`
     * is `'point'`. Default is no stroke.
     */
    backgroundStroke?: Stroke | undefined;
    /**
     * Padding in pixels around the text for decluttering and background. The order of
     * values in the array is `[top, right, bottom, left]`.
     */
    padding?: number[] | undefined;
    /**
     * Declutter mode: `declutter`, `obstacle`, `none`
     */
    declutterMode?: DeclutterMode | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {boolean} [keepUpright=true] Whether the text can be rotated 180° to prevent being rendered upside down.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default|null} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {import('../style/Style.js').DeclutterMode} [declutterMode] Declutter mode: `declutter`, `obstacle`, `none`
 */
/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */
declare class Text$1 {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1M);
    /**
     * @private
     * @type {string|undefined}
     */
    private font_;
    /**
     * @private
     * @type {number|undefined}
     */
    private rotation_;
    /**
     * @private
     * @type {boolean|undefined}
     */
    private rotateWithView_;
    /**
     * @private
     * @type {boolean|undefined}
     */
    private keepUpright_;
    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */
    private scale_;
    /**
     * @private
     * @type {import("../size.js").Size}
     */
    private scaleArray_;
    /**
     * @private
     * @type {string|Array<string>|undefined}
     */
    private text_;
    /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */
    private textAlign_;
    /**
     * @private
     * @type {TextJustify|undefined}
     */
    private justify_;
    /**
     * @private
     * @type {number|undefined}
     */
    private repeat_;
    /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */
    private textBaseline_;
    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    private fill_;
    /**
     * @private
     * @type {number}
     */
    private maxAngle_;
    /**
     * @private
     * @type {TextPlacement}
     */
    private placement_;
    /**
     * @private
     * @type {boolean}
     */
    private overflow_;
    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    private stroke_;
    /**
     * @private
     * @type {number}
     */
    private offsetX_;
    /**
     * @private
     * @type {number}
     */
    private offsetY_;
    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    private backgroundFill_;
    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    private backgroundStroke_;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private padding_;
    /**
     * @private
     * @type {import('../style/Style.js').DeclutterMode}
     */
    private declutterMode_;
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */
    clone(): Text$1;
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
    getOverflow(): boolean;
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
    getFont(): string | undefined;
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
    getMaxAngle(): number;
    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */
    getPlacement(): TextPlacement;
    /**
     * Get the repeat interval of the text.
     * @return {number|undefined} Repeat interval in pixels.
     * @api
     */
    getRepeat(): number | undefined;
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
    getOffsetX(): number;
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
    getOffsetY(): number;
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill(): Fill | null;
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
    getRotateWithView(): boolean | undefined;
    /**
     * Determine whether the text can be rendered upside down.
     * @return {boolean|undefined} Keep text upright.
     * @api
     */
    getKeepUpright(): boolean | undefined;
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
    getRotation(): number | undefined;
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
    getScale(): number | Size | undefined;
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray(): Size;
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke(): Stroke | null;
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
    getText(): string | Array<string> | undefined;
    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */
    getTextAlign(): CanvasTextAlign | undefined;
    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */
    getJustify(): TextJustify | undefined;
    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */
    getTextBaseline(): CanvasTextBaseline | undefined;
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getBackgroundFill(): Fill | null;
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getBackgroundStroke(): Stroke | null;
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
    getPadding(): Array<number> | null;
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode(): DeclutterMode;
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
    setOverflow(overflow: boolean): void;
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
    setFont(font: string | undefined): void;
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
    setMaxAngle(maxAngle: number): void;
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
    setOffsetX(offsetX: number): void;
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
    setOffsetY(offsetY: number): void;
    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */
    setPlacement(placement: TextPlacement): void;
    /**
     * Set the repeat interval of the text.
     * @param {number|undefined} [repeat] Repeat interval in pixels.
     * @api
     */
    setRepeat(repeat?: number | undefined): void;
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(rotateWithView: boolean): void;
    /**
     * Set whether the text can be rendered upside down.
     *
     * @param {boolean} keepUpright Keep text upright.
     * @api
     */
    setKeepUpright(keepUpright: boolean): void;
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(fill: Fill | null): void;
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
    setRotation(rotation: number | undefined): void;
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
    setScale(scale: number | Size | undefined): void;
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(stroke: Stroke | null): void;
    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */
    setText(text: string | Array<string> | undefined): void;
    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */
    setTextAlign(textAlign: CanvasTextAlign | undefined): void;
    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */
    setJustify(justify: TextJustify | undefined): void;
    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */
    setTextBaseline(textBaseline: CanvasTextBaseline | undefined): void;
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setBackgroundFill(fill: Fill | null): void;
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setBackgroundStroke(stroke: Stroke | null): void;
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
    setPadding(padding: Array<number> | null): void;
}

type Options$1L = {
    /**
     * Opacity.
     */
    opacity: number;
    /**
     * If the image should get rotated with the view.
     */
    rotateWithView: boolean;
    /**
     * Rotation.
     */
    rotation: number;
    /**
     * Scale.
     */
    scale: number | Size;
    /**
     * Displacement.
     */
    displacement: Array<number>;
    /**
     * Declutter mode: `declutter`, `obstacle`, `none`.
     */
    declutterMode: DeclutterMode;
};
/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {import('../style/Style.js').DeclutterMode} declutterMode Declutter mode: `declutter`, `obstacle`, `none`.
 */
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
declare class ImageStyle {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options$1L);
    /**
     * @private
     * @type {number}
     */
    private opacity_;
    /**
     * @private
     * @type {boolean}
     */
    private rotateWithView_;
    /**
     * @private
     * @type {number}
     */
    private rotation_;
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    private scale_;
    /**
     * @private
     * @type {import("../size.js").Size}
     */
    private scaleArray_;
    /**
     * @private
     * @type {Array<number>}
     */
    private displacement_;
    /**
     * @private
     * @type {import('../style/Style.js').DeclutterMode}
     */
    private declutterMode_;
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */
    clone(): ImageStyle;
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
    getOpacity(): number;
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
    getRotateWithView(): boolean;
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
    getRotation(): number;
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
    getScale(): number | Size;
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray(): Size;
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
    getDisplacement(): Array<number>;
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode(): DeclutterMode;
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
    getAnchor(): Array<number>;
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getImage(pixelRatio: number): ImageLike;
    /**
     * @abstract
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getHitDetectionImage(): ImageLike;
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    getPixelRatio(pixelRatio: number): number;
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState(): any;
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize(): Size;
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
    getOrigin(): Array<number>;
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
    getSize(): Size;
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
    setDisplacement(displacement: Array<number>): void;
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
    setOpacity(opacity: number): void;
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(rotateWithView: boolean): void;
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
    setRotation(rotation: number): void;
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    setScale(scale: number | Size): void;
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(listener: (arg0: BaseEvent) => void): void;
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    load(): void;
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(listener: (arg0: BaseEvent) => void): void;
    /**
     * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
     */
    ready(): Promise<void>;
}

/**
 * @module ol/resolution
 */
/**
 * @typedef {number|Array<number>} ResolutionLike
 */
/**
 * @param {ResolutionLike} resolution Resolution.
 * @return {number} Resolution.
 */
declare function fromResolutionLike(resolution: ResolutionLike): number;
type ResolutionLike = number | Array<number>;

/**
 * A function that takes an {@link module :ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module :ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 */
type LoadFunction = (arg0: ImageWrapper, arg1: string) => void;
type ImageObject = {
    /**
     * Extent, if different from the requested one.
     */
    extent?: Extent$1 | undefined;
    /**
     * Resolution, if different from the requested one.
     * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
     */
    resolution?: ResolutionLike | undefined;
    /**
     * Pixel ratio, if different from the requested one.
     */
    pixelRatio?: number | undefined;
    /**
     * Image.
     */
    image: ImageLike;
};
/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import ("./DataTile.js").ImageLike image}, an
 * {@link import ("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import ("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 */
type Loader$3 = (arg0: Extent$1, arg1: number, arg2: number, arg3: ((arg0: HTMLImageElement, arg1: string) => void) | undefined) => ImageLike | ImageObject | Promise<ImageLike | ImageObject>;
/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import ("./Image.js").ImageObject image object}.
 */
type ImageObjectPromiseLoader = (arg0: Extent$1, arg1: number, arg2: number, arg3: ((arg0: HTMLImageElement, arg1: string) => void) | undefined) => ImageLike | ImageObject | Promise<ImageLike | ImageObject>;
/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */
/**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */
/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */
/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */
declare class ImageWrapper extends Target {
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
     * resolution will be assumed.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
     */
    constructor(extent: Extent$1, resolution: number | Array<number> | undefined, pixelRatio: number, stateOrLoader: any | Loader$3);
    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    protected extent: Extent$1;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @protected
     * @type {number|Array<number>|undefined}
     */
    protected resolution: number | Array<number> | undefined;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    protected state: any;
    /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */
    private image_;
    /**
     * @protected
     * @type {import("./Image.js").Loader}
     */
    protected loader: Loader$3;
    /**
     * @protected
     */
    protected changed(): void;
    /**
     * @return {import("./extent.js").Extent} Extent.
     */
    getExtent(): Extent$1;
    /**
     * @return {import('./DataTile.js').ImageLike} Image.
     */
    getImage(): ImageLike;
    /**
     * @return {number} PixelRatio.
     */
    getPixelRatio(): number;
    /**
     * @return {number|Array<number>} Resolution.
     */
    getResolution(): number | Array<number>;
    /**
     * @return {import("./ImageState.js").default} State.
     */
    getState(): any;
    /**
     * Load not yet loaded URI.
     */
    load(): void;
    /**
     * @param {import('./DataTile.js').ImageLike} image The image.
     */
    setImage(image: ImageLike): void;
    /**
     * @param {number|Array<number>} resolution Resolution.
     */
    setResolution(resolution: number | Array<number>): void;
}

/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
declare class LayerRenderer<LayerType extends Layer> extends Observable {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(layer: LayerType);
    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */
    ready: boolean;
    /** @private */
    private boundHandleImageChange_;
    /**
     * @private
     * @type {LayerType}
     */
    private layer_;
    /**
     * @type {Array<string>}
     * @private
     */
    private staleKeys_;
    /**
     * @type {number}
     * @protected
     */
    protected maxStaleKeys: number;
    /**
     * @return {Array<string>} Get the list of stale keys.
     */
    getStaleKeys(): Array<string>;
    /**
     * @param {string} key The new stale key.
     */
    prependStaleKey(key: string): void;
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(pixel: Pixel): Promise<Array<FeatureLike>>;
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(pixel: Pixel): Uint8ClampedArray | Uint8Array | Float32Array | DataView | null;
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    prepareFrame(frameState: FrameState): boolean;
    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
    renderFrame(frameState: FrameState, target: HTMLElement | null): HTMLElement | null;
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate<T>(coordinate: Coordinate, frameState: FrameState, hitTolerance: number, callback: FeatureCallback<T>, matches: Array<HitMatch<T>>): T | undefined;
    /**
     * @return {LayerType} Layer.
     */
    getLayer(): LayerType;
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
    handleFontsChanged(): void;
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
    private handleImageChange_;
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../Image.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
    protected loadImage(image: ImageWrapper): boolean;
    /**
     * @protected
     */
    protected renderIfReadyAndVisible(): void;
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    renderDeferred(frameState: FrameState): void;
}
//# sourceMappingURL=Layer.d.ts.map

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
declare function disable(rotation: number | undefined): number | undefined;
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
declare function none$1(rotation: number | undefined): number | undefined;
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
declare function createSnapToN(n: number): Type$4;
/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */
declare function createSnapToZero(tolerance?: number): Type$4;
type Type$4 = (arg0: (number | undefined), arg1: boolean | undefined) => (number | undefined);

/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
declare function createSnapToResolutions(resolutions: Array<number>, smooth?: boolean, maxExtent?: Extent$1, showFullExtent?: boolean): Type$3;
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
declare function createSnapToPower(power: number, maxResolution: number, minResolution?: number, smooth?: boolean, maxExtent?: Extent$1, showFullExtent?: boolean): Type$3;
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
declare function createMinMaxResolution(maxResolution: number, minResolution: number, smooth?: boolean, maxExtent?: Extent$1, showFullExtent?: boolean): Type$3;
type Type$3 = (arg0: (number | undefined), arg1: number, arg2: Size, arg3: boolean | undefined) => (number | undefined);

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
declare function createExtent(extent: Extent$1, onlyCenter: boolean, smooth: boolean): Type$2;
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
declare function none(center?: Coordinate): Coordinate | undefined;
type Type$2 = (arg0: (Coordinate | undefined), arg1: number, arg2: Size, arg3: boolean | undefined, arg4: Array<number> | undefined) => (Coordinate | undefined);

type Constraints = {
    /**
     * Center.
     */
    center: Type$2;
    /**
     * Resolution.
     */
    resolution: Type$3;
    /**
     * Rotation.
     */
    rotation: Type$4;
};
type FitOptions = {
    /**
     * The size in pixels of the box to
     * fit the extent into. Defaults to the size of the map the view is associated with.
     * If no map or multiple maps are connected to the view, provide the desired box size
     * (e.g. `map.getSize()`).
     */
    size?: Size | undefined;
    /**
     * Padding (in pixels) to be
     * cleared inside the view. Values in the array are top, right, bottom and left
     * padding.
     */
    padding?: number[] | undefined;
    /**
     * If the view `constrainResolution` option is `true`,
     * get the nearest extent instead of the closest that actually fits the view.
     */
    nearest?: boolean | undefined;
    /**
     * Minimum resolution that we zoom to.
     */
    minResolution?: number | undefined;
    /**
     * Maximum zoom level that we zoom to. If
     * `minResolution` is given, this property is ignored.
     */
    maxZoom?: number | undefined;
    /**
     * The duration of the animation in milliseconds.
     * By default, there is no animation to the target extent.
     */
    duration?: number | undefined;
    /**
     * The easing function used during
     * the animation (defaults to {@link module :ol/easing.inAndOut}).
     * The function will be called for each frame with a number representing a
     * fraction of the animation's duration.  The function should return a number
     * between 0 and 1 representing the progress toward the destination state.
     */
    easing?: ((arg0: number) => number) | undefined;
    /**
     * Function called when the view is in
     * its final position. The callback will be called with `true` if the animation
     * series completed on its own or `false` if it was cancelled.
     */
    callback?: ((arg0: boolean) => void) | undefined;
};
type ViewOptions = {
    /**
     * The initial center for
     * the view. If a user projection is not set, the coordinate system for the center is
     * specified with the `projection` option. Layer sources will not be fetched if this
     * is not set, but the center can be set later with {@link  #setCenter}.
     */
    center?: Coordinate | undefined;
    /**
     * Rotation constraint.
     * `false` means no constraint. `true` means no constraint, but snap to zero
     * near zero. A number constrains the rotation to that number of values. For
     * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
     */
    constrainRotation?: number | boolean | undefined;
    /**
     * Enable rotation.
     * If `false`, a rotation constraint that always sets the rotation to zero is
     * used. The `constrainRotation` option has no effect if `enableRotation` is
     * `false`.
     */
    enableRotation?: boolean | undefined;
    /**
     * The extent that constrains the
     * view, in other words, nothing outside of this extent can be visible on the map.
     */
    extent?: Extent$1 | undefined;
    /**
     * If true, the extent
     * constraint will only apply to the view center and not the whole extent.
     */
    constrainOnlyCenter?: boolean | undefined;
    /**
     * If true, the extent
     * constraint will be applied smoothly, i.e. allow the view to go slightly outside
     * of the given `extent`.
     */
    smoothExtentConstraint?: boolean | undefined;
    /**
     * The maximum resolution used to determine
     * the resolution constraint. It is used together with `minResolution` (or
     * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
     * that the projection's validity extent fits in a 256x256 px tile. If the
     * projection is Spherical Mercator (the default) then `maxResolution` defaults
     * to `40075016.68557849 / 256 = 156543.03392804097`.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum resolution used to determine
     * the resolution constraint.  It is used together with `maxResolution` (or
     * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
     * zoom levels (with a factor of 2). If the projection is Spherical Mercator
     * (the default) then `minResolution` defaults to
     * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
     */
    minResolution?: number | undefined;
    /**
     * The maximum zoom level used to determine the
     * resolution constraint. It is used together with `minZoom` (or
     * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
     * provided, it is given precedence over `maxZoom`.
     */
    maxZoom?: number | undefined;
    /**
     * The minimum zoom level used to determine the
     * resolution constraint. It is used together with `maxZoom` (or
     * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
     * provided, it is given precedence over `minZoom`.
     */
    minZoom?: number | undefined;
    /**
     * If `false` the view is constrained so
     * only one world is visible, and you cannot pan off the edge.  If `true` the map
     * may show multiple worlds at low zoom levels.  Only used if the `projection` is
     * global.  Note that if `extent` is also provided it is given precedence.
     */
    multiWorld?: boolean | undefined;
    /**
     * If true, the view will always
     * animate to the closest zoom level after an interaction; false means
     * intermediary zoom levels are allowed.
     */
    constrainResolution?: boolean | undefined;
    /**
     * If true, the resolution
     * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
     * the given resolution or zoom bounds.
     */
    smoothResolutionConstraint?: boolean | undefined;
    /**
     * Allow the view to be zoomed out to
     * show the full configured extent. By default, when a view is configured with an
     * extent, users will not be able to zoom out so the viewport exceeds the extent in
     * either dimension. This means the full extent may not be visible if the viewport
     * is taller or wider than the aspect ratio of the configured extent. If
     * showFullExtent is true, the user will be able to zoom out so that the viewport
     * exceeds the height or width of the configured extent, but not both, allowing the
     * full extent to be shown.
     */
    showFullExtent?: boolean | undefined;
    /**
     * The
     * projection. The default is Spherical Mercator.
     */
    projection?: ProjectionLike;
    /**
     * The initial resolution for the view. The
     * units are `projection` units per pixel (e.g. meters per pixel). An
     * alternative to setting this is to set `zoom`. Layer sources will not be
     * fetched if neither this nor `zoom` are defined, but they can be set later
     * with {@link  #setZoom} or {@link  #setResolution}.
     */
    resolution?: number | undefined;
    /**
     * Resolutions that determine the
     * zoom levels if specified. The index in the array corresponds to the zoom level,
     * therefore the resolution values have to be in descending order. It also constrains
     * the resolution by the minimum and maximum value. If set the `maxResolution`,
     * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
     */
    resolutions?: number[] | undefined;
    /**
     * The initial rotation for the view in radians
     * (positive rotation clockwise, 0 means North).
     */
    rotation?: number | undefined;
    /**
     * Only used if `resolution` is not defined. Zoom
     * level used to calculate the initial resolution for the view.
     */
    zoom?: number | undefined;
    /**
     * The zoom factor used to compute the
     * corresponding resolution.
     */
    zoomFactor?: number | undefined;
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from
     * that content. The order of the values is top, right, bottom, left.
     */
    padding?: number[] | undefined;
};
type AnimationOptions = {
    /**
     * The center of the view at the end of
     * the animation.
     */
    center?: Coordinate | undefined;
    /**
     * The zoom level of the view at the end of the
     * animation. This takes precedence over `resolution`.
     */
    zoom?: number | undefined;
    /**
     * The resolution of the view at the end
     * of the animation.  If `zoom` is also provided, this option will be ignored.
     */
    resolution?: number | undefined;
    /**
     * The rotation of the view at the end of
     * the animation.
     */
    rotation?: number | undefined;
    /**
     * Optional anchor to remain fixed
     * during a rotation or resolution animation.
     */
    anchor?: Coordinate | undefined;
    /**
     * The duration of the animation in milliseconds.
     */
    duration?: number | undefined;
    /**
     * The easing function used
     * during the animation (defaults to {@link module :ol/easing.inAndOut}).
     * The function will be called for each frame with a number representing a
     * fraction of the animation's duration.  The function should return a number
     * between 0 and 1 representing the progress toward the destination state.
     */
    easing?: ((arg0: number) => number) | undefined;
};
type State$3 = {
    /**
     * Center (in view projection coordinates).
     */
    center: Coordinate;
    /**
     * Projection.
     */
    projection: Projection;
    /**
     * Resolution.
     */
    resolution: number;
    /**
     * The next center during an animation series.
     */
    nextCenter?: Coordinate | undefined;
    /**
     * The next resolution during an animation series.
     */
    nextResolution?: number | undefined;
    /**
     * The next rotation during an animation series.
     */
    nextRotation?: number | undefined;
    /**
     * Rotation.
     */
    rotation: number;
    /**
     * Zoom.
     */
    zoom: number;
};
/**
 * Like {@link import ("./Map.js").FrameState}, but just `viewState` and `extent`.
 */
type ViewStateLayerStateExtent = {
    /**
     * View state.
     */
    viewState: State$3;
    /**
     * Extent (in user projection coordinates).
     */
    extent: Extent$1;
    /**
     * Layer states.
     */
    layerStatesArray?: State$1[] | undefined;
};
type ViewObjectEventTypes = Types$2 | "change:center" | "change:resolution" | "change:rotation";
/**
 * *
 */
type ViewOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<ViewObjectEventTypes, ObjectEvent, Return> & CombinedOnSignature<EventTypes | ViewObjectEventTypes, Return>;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */
/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */
declare class View extends BaseObject {
    /**
     * @param {ViewOptions} [options] View options.
     */
    constructor(options?: ViewOptions);
    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    on: ViewOnSignature<EventsKey>;
    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    once: ViewOnSignature<EventsKey>;
    /***
     * @type {ViewOnSignature<void>}
     */
    un: ViewOnSignature<void>;
    /**
     * @private
     * @type {Array<number>}
     */
    private hints_;
    /**
     * @private
     * @type {Array<Array<Animation>>}
     */
    private animations_;
    /**
     * @private
     * @type {number|undefined}
     */
    private updateAnimationKey_;
    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */
    private projection_;
    /**
     * @private
     * @type {import("./size.js").Size}
     */
    private viewportSize_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    private targetCenter_;
    /**
     * @private
     * @type {number|undefined}
     */
    private targetResolution_;
    /**
     * @private
     * @type {number|undefined}
     */
    private targetRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */
    private nextCenter_;
    /**
     * @private
     * @type {number}
     */
    private nextResolution_;
    /**
     * @private
     * @type {number}
     */
    private nextRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    private cancelAnchor_;
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */
    applyOptions_(options: ViewOptions): void;
    /**
     * @private
     * @type {number}
     */
    private maxResolution_;
    /**
     * @private
     * @type {number}
     */
    private minResolution_;
    /**
     * @private
     * @type {number}
     */
    private zoomFactor_;
    /**
     * @private
     * @type {Array<number>|undefined}
     */
    private resolutions_;
    /**
     * @type {Array<number>|undefined}
     * @private
     */
    private padding_;
    /**
     * @private
     * @type {number}
     */
    private minZoom_;
    /**
     * @private
     * @type {Constraints}
     */
    private constraints_;
    set padding(padding: Array<number> | undefined);
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
    get padding(): Array<number> | undefined;
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
    getUpdatedOptions_(newOptions: ViewOptions): ViewOptions;
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
    animate(...args: (AnimationOptions | ((arg0: boolean) => void))[]): void;
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
    animateInternal(...args: (AnimationOptions | ((arg0: boolean) => void))[]): void;
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
    getAnimating(): boolean;
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
    getInteracting(): boolean;
    /**
     * Cancel any ongoing animations.
     * @api
     */
    cancelAnimations(): void;
    /**
     * Update all animations.
     */
    updateAnimations_(): void;
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
    calculateCenterRotate(rotation: number, anchor: Coordinate): Coordinate | undefined;
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
    calculateCenterZoom(resolution: number, anchor: Coordinate): Coordinate | undefined;
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
    private getViewportSize_;
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */
    setViewportSize(size?: Size): void;
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
    getCenter(): Coordinate | undefined;
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
    getCenterInternal(): Coordinate | undefined;
    /**
     * @return {Constraints} Constraints.
     */
    getConstraints(): Constraints;
    /**
     * @return {boolean} Resolution constraint is set
     */
    getConstrainResolution(): boolean;
    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */
    getHints(hints?: Array<number>): Array<number>;
    /**
     * Calculate the extent for the current view state and the passed box size.
     * @param {import("./size.js").Size} [size] The pixel dimensions of the box
     * into which the calculated extent should fit. Defaults to the size of the
     * map the view is associated with.
     * If no map or multiple maps are connected to the view, provide the desired
     * box size (e.g. `map.getSize()`).
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
    calculateExtent(size?: Size): Extent$1;
    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
    calculateExtentInternal(size?: Size): Extent$1;
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
    getMaxResolution(): number;
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
    getMinResolution(): number;
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
    getMaxZoom(): number;
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
    setMaxZoom(zoom: number): void;
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
    getMinZoom(): number;
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
    setMinZoom(zoom: number): void;
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
    setConstrainResolution(enabled: boolean): void;
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
    getProjection(): Projection;
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
    getResolution(): number | undefined;
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
    getResolutions(): Array<number> | undefined;
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
    getResolutionForExtent(extent: Extent$1, size?: Size): number;
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
    getResolutionForExtentInternal(extent: Extent$1, size?: Size): number;
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */
    getResolutionForValueFunction(power?: number): (arg0: number) => number;
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
    getRotation(): number;
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */
    getValueForResolutionFunction(power?: number): (arg0: number) => number;
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
    private getViewportSizeMinusPadding_;
    /**
     * @return {State} View state.
     */
    getState(): State$3;
    /**
     * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
     */
    getViewStateAndExtent(): ViewStateLayerStateExtent;
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
    getZoom(): number | undefined;
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
    getZoomForResolution(resolution: number): number | undefined;
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
    getResolutionForZoom(zoom: number): number;
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */
    fit(geometryOrExtent: SimpleGeometry | Extent$1, options?: FitOptions): void;
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
    rotatedExtentForGeometry(geometry: SimpleGeometry): Extent$1;
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */
    fitInternal(geometry: SimpleGeometry, options?: FitOptions): void;
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
    centerOn(coordinate: Coordinate, size: Size, position: Pixel): void;
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
    centerOnInternal(coordinate: Coordinate, size: Size, position: Pixel): void;
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
    calculateCenterShift(center: Coordinate, resolution: number, rotation: number, size: Size): Array<number> | undefined;
    /**
     * @return {boolean} Is defined.
     */
    isDef(): boolean;
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
    adjustCenter(deltaCoordinates: Coordinate): void;
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
    adjustCenterInternal(deltaCoordinates: Coordinate): void;
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustResolution(ratio: number, anchor?: Coordinate): void;
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    adjustResolutionInternal(ratio: number, anchor?: Coordinate): void;
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustZoom(delta: number, anchor?: Coordinate): void;
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */
    adjustRotation(delta: number, anchor?: Coordinate): void;
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */
    adjustRotationInternal(delta: number, anchor?: Coordinate): void;
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
    setCenter(center: Coordinate | undefined): void;
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
    setCenterInternal(center: Coordinate | undefined): void;
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
    setHint(hint: any, delta: number): number;
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
    setResolution(resolution: number | undefined): void;
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
    setRotation(rotation: number): void;
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
    setZoom(zoom: number): void;
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */
    private applyTargetState_;
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    resolveConstraints(duration?: number, resolutionDirection?: number, anchor?: Coordinate): void;
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
    beginInteraction(): void;
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    endInteraction(duration?: number, resolutionDirection?: number, anchor?: Coordinate): void;
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    endInteractionInternal(duration?: number, resolutionDirection?: number, anchor?: Coordinate): void;
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
    getConstrainedCenter(targetCenter: Coordinate | undefined, targetResolution?: number): Coordinate | undefined;
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
    getConstrainedZoom(targetZoom: number | undefined, direction?: number): number | undefined;
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
    getConstrainedResolution(targetResolution: number | undefined, direction?: number): number | undefined;
}

/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
type State$2 = "undefined" | "loading" | "ready" | "error";
/**
 * A function that takes a {@link import ("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 */
type Attribution$1 = (arg0: ViewStateLayerStateExtent) => (string | Array<string>);
/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module :ol/source/Source~Attribution})
 */
type AttributionLike = string | Array<string> | Attribution$1;
type Options$1K = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * State.
     */
    state?: State$2 | undefined;
    /**
     * WrapX.
     */
    wrapX?: boolean | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
};
/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */
/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */
/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
declare class Source extends BaseObject {
    /**
     * @param {Options} options Source options.
     */
    constructor(options: Options$1K);
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */
    protected projection: Projection | null;
    /**
     * @private
     * @type {?Attribution}
     */
    private attributions_;
    /**
     * @private
     * @type {boolean}
     */
    private attributionsCollapsible_;
    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    loading: boolean;
    /**
     * @private
     * @type {import("./Source.js").State}
     */
    private state_;
    /**
     * @private
     * @type {boolean}
     */
    private wrapX_;
    /**
     * @private
     * @type {boolean}
     */
    private interpolate_;
    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */
    protected viewResolver: (arg0: ViewOptions) => void;
    /**
     * @protected
     * @type {function(Error):void}
     */
    protected viewRejector: (arg0: Error) => void;
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */
    private viewPromise_;
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */
    getAttributions(): Attribution$1 | null;
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
    getAttributionsCollapsible(): boolean;
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */
    getProjection(): Projection | null;
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
    getResolutions(projection?: Projection): Array<number> | null;
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
    getView(): Promise<ViewOptions>;
    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */
    getState(): State$2;
    /**
     * @return {boolean|undefined} Wrap X.
     */
    getWrapX(): boolean | undefined;
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
    getInterpolate(): boolean;
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
    refresh(): void;
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
    setAttributions(attributions: AttributionLike | undefined): void;
    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */
    setState(state: State$2): void;
}

type MapRenderEventTypes = "postrender" | "precompose" | "postcompose" | "rendercomplete";
type LayerRenderEventTypes = "postrender" | "prerender";

/**
 * A css color, or a function called with a view resolution returning a css color.
 */
type BackgroundColor = string | ((arg0: number) => string);
type BaseLayerObjectEventTypes = Types$2 | "change:extent" | "change:maxResolution" | "change:maxZoom" | "change:minResolution" | "change:minZoom" | "change:opacity" | "change:visible" | "change:zIndex";
/**
 * *
 */
type BaseLayerOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<BaseLayerObjectEventTypes, ObjectEvent, Return> & CombinedOnSignature<EventTypes | BaseLayerObjectEventTypes, Return>;
type Options$1J = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Background color for the layer. If not specified, no background
     * will be rendered.
     */
    background?: BackgroundColor | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */
/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
declare class BaseLayer extends BaseObject {
    /**
     * @param {Options} options Layer options.
     */
    constructor(options: Options$1J);
    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    on: BaseLayerOnSignature<EventsKey>;
    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    once: BaseLayerOnSignature<EventsKey>;
    /***
     * @type {BaseLayerOnSignature<void>}
     */
    un: BaseLayerOnSignature<void>;
    /**
     * @type {BackgroundColor|false}
     * @private
     */
    private background_;
    /**
     * @type {string}
     * @private
     */
    private className_;
    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    private state_;
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */
    getBackground(): BackgroundColor | false;
    /**
     * @return {string} CSS class name.
     */
    getClassName(): string;
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
    getLayerState(managed?: boolean): State$1;
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(array?: Array<Layer>): Array<Layer>;
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(states?: Array<State$1>): Array<State$1>;
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
    getExtent(): Extent$1 | undefined;
    /**
     * Return the maximum resolution of the layer. Returns Infinity if
     * the layer has no maximum resolution set.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
    getMaxResolution(): number;
    /**
     * Return the minimum resolution of the layer. Returns 0 if
     * the layer has no minimum resolution set.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
    getMinResolution(): number;
    /**
     * Return the minimum zoom level of the layer. Returns -Infinity if
     * the layer has no minimum zoom set.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
    getMinZoom(): number;
    /**
     * Return the maximum zoom level of the layer. Returns Infinity if
     * the layer has no maximum zoom set.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
    getMaxZoom(): number;
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
    getOpacity(): number;
    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState(): State$2;
    /**
     * Return the value of this layer's `visible` property. To find out whether the layer
     * is visible on a map, use `isVisible()` instead.
     * @return {boolean} The value of the `visible` property of the layer.
     * @observable
     * @api
     */
    getVisible(): boolean;
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. Returns undefined if the layer is unmanaged.
     * @return {number|undefined} The Z-index of the layer.
     * @observable
     * @api
     */
    getZIndex(): number | undefined;
    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */
    setBackground(background?: BackgroundColor): void;
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
    setExtent(extent: Extent$1 | undefined): void;
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
    setMaxResolution(maxResolution: number): void;
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
    setMinResolution(minResolution: number): void;
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
    setMaxZoom(maxZoom: number): void;
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
    setMinZoom(minZoom: number): void;
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
    setOpacity(opacity: number): void;
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
    setVisible(visible: boolean): void;
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
    setZIndex(zindex: number): void;
}

type RenderFunction$1 = (arg0: FrameState) => HTMLElement;
type LayerEventType = "sourceready" | "change:source";
/**
 * *
 */
type LayerOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<BaseLayerObjectEventTypes | LayerEventType, ObjectEvent, Return> & OnSignature<LayerRenderEventTypes, RenderEvent, Return> & CombinedOnSignature<EventTypes | BaseLayerObjectEventTypes | LayerEventType | LayerRenderEventTypes, Return>;
type Options$1I<SourceType extends Source = Source> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Source for this layer.  If not provided to the constructor,
     * the source can be set by calling {@link module :ol/layer/Layer~Layer#setSource layer.setSource(source)} after
     * construction.
     */
    source?: SourceType | undefined;
    /**
     * Map.
     */
    map?: Map | null | undefined;
    /**
     * Render function. Takes the frame state as input and is expected to return an
     * HTML element. Will overwrite the default rendering for the layer.
     */
    render?: RenderFunction$1 | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
type State$1 = {
    /**
     * Layer.
     */
    layer: Layer;
    /**
     * Opacity, the value is rounded to two digits to appear after the decimal point.
     */
    opacity: number;
    /**
     * Visible.
     */
    visible: boolean;
    /**
     * Managed.
     */
    managed: boolean;
    /**
     * Extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * ZIndex.
     */
    zIndex: number;
    /**
     * Maximum resolution.
     */
    maxResolution: number;
    /**
     * Minimum resolution.
     */
    minResolution: number;
    /**
     * Minimum zoom.
     */
    minZoom: number;
    /**
     * Maximum zoom.
     */
    maxZoom: number;
};
/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */
/**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */
/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */
/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */
declare class Layer<SourceType extends Source = Source, RendererType extends LayerRenderer<any> = LayerRenderer<any>> extends BaseLayer {
    /**
     * @param {Options<SourceType>} options Layer options.
     */
    constructor(options: Options$1I<SourceType>);
    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    on: LayerOnSignature<EventsKey>;
    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    once: LayerOnSignature<EventsKey>;
    /***
     * @type {LayerOnSignature<void>}
     */
    un: LayerOnSignature<void>;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    private mapPrecomposeKey_;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    private mapRenderKey_;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    private sourceChangeKey_;
    /**
     * @private
     * @type {RendererType}
     */
    private renderer_;
    /**
     * @private
     * @type {boolean}
     */
    private sourceReady_;
    /**
     * @protected
     * @type {boolean}
     */
    protected rendered: boolean;
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement|null} The rendered element.
     */
    render(frameState: FrameState | null, target: HTMLElement): HTMLElement | null;
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
    getSource(): SourceType | null;
    /**
     * @return {SourceType|null} The source being rendered.
     */
    getRenderSource(): SourceType | null;
    /**
     * @private
     */
    private handleSourceChange_;
    /**
     * @private
     */
    private handleSourcePropertyChange_;
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(pixel: Pixel): Promise<Array<FeatureLike>>;
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(pixel: Pixel): Uint8ClampedArray | Uint8Array | Float32Array | DataView | null;
    /**
     * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
     * extent, not set to `visible: false`, and not inside a layer group that is set
     * to `visible: false`.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {boolean} The layer is visible in the map view.
     * @api
     */
    isVisible(view?: View | ViewStateLayerStateExtent): boolean;
    /**
     * Get the attributions of the source of this layer for the given view.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {Array<string>} Attributions for this layer at the given view.
     * @api
     */
    getAttributions(view?: View | ViewStateLayerStateExtent): Array<string>;
    /**
     * Called when a layer is not visible during a map render.
     */
    unrender(): void;
    /** @return {string} Declutter */
    getDeclutter(): string;
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     */
    renderDeclutter(frameState: FrameState, layerState: State$1): void;
    /**
     * When the renderer follows a layout -> render approach, do the final rendering here.
     * @param {import('../Map.js').FrameState} frameState Frame state
     */
    renderDeferred(frameState: FrameState): void;
    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMapInternal(map: Map | null): void;
    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */
    getMapInternal(): Map | null;
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(map: Map | null): void;
    /**
     * @param {import("../events/Event.js").default} renderEvent Render event
     * @private
     */
    private handlePrecompose_;
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
    setSource(source: SourceType | null): void;
    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */
    getRenderer(): RendererType | null;
    /**
     * @return {boolean} The layer has a renderer.
     */
    hasRenderer(): boolean;
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
    protected createRenderer(): RendererType;
    /**
     * This will clear the renderer so that a new one can be created next time it is needed
     */
    clearRenderer(): void;
}

interface BBox$1 {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
}

declare class RBush$1<T> {
    /**
     * Constructs an `RBush`, a high-performance 2D spatial index for points and
     * rectangles. Based on an optimized __R-tree__ data structure with
     * __bulk-insertion__ support.
     *
     * @param maxEntries An optional argument to RBush defines the maximum
     *                   number of entries in a tree node. `9` (used by default)
     *                   is a reasonable choice for most applications. Higher
     *                   value means faster insertion and slower search, and
     *                   vice versa.
     */
    constructor(maxEntries?: number);

    /**
     * Inserts an item. To insert many items at once, use `load()`.
     *
     * @param item The item to insert.
     */
    insert(item: T): RBush$1<T>;

    /**
     * Bulk-inserts the given items into the tree.
     *
     * Bulk insertion is usually ~2-3 times faster than inserting items one by
     * one. After bulk loading (bulk insertion into an empty tree), subsequent
     * query performance is also ~20-30% better.
     *
     * Note that when you do bulk insertion into an existing tree, it bulk-loads
     * the given data into a separate tree and inserts the smaller tree into the
     * larger tree. This means that bulk insertion works very well for clustered
     * data (where items in one update are close to each other), but makes query
     * performance worse if the data is scattered.
     *
     * @param items The items to load.
     */
    load(items: readonly T[]): RBush$1<T>;

    /**
     * Removes a previously inserted item, comparing by reference.
     *
     * To remove all items, use `clear()`.
     *
     * @param item The item to remove.
     * @param equals A custom function that allows comparing by value instead.
     *               Useful when you have only a copy of the object you need
     *               removed (e.g. loaded from server).
     */
    remove(item: T, equals?: (a: T, b: T) => boolean): RBush$1<T>;

    /**
     * Removes all items.
     */
    clear(): RBush$1<T>;

    /**
     * Returns an array of data items (points or rectangles) that the given
     * bounding box intersects.
     *
     * Note that the search method accepts a bounding box in `{minX, minY, maxX,
     * maxY}` format regardless of the data format.
     *
     * @param box The bounding box in which to search.
     */
    search(box: BBox$1): T[];

    /**
     * Returns all items contained in the tree.
     */
    all(): T[];

    /**
     * Returns `true` if there are any items intersecting the given bounding
     * box, otherwise `false`.
     *
     * @param box The bounding box in which to search.
     */
    collides(box: BBox$1): boolean;

    /**
     * Returns the bounding box for the provided item.
     *
     * By default, `RBush` assumes the format of data points to be an object
     * with `minX`, `minY`, `maxX`, and `maxY`. However, you can specify a
     * custom item format by overriding `toBBox()`, `compareMinX()`, and
     * `compareMinY()`.
     *
     * @example
     * class MyRBush<T> extends RBush<T> {
     *   toBBox([x, y]) { return { minX: x, minY: y, maxX: x, maxY: y }; }
     *   compareMinX(a, b) { return a.x - b.x; }
     *   compareMinY(a, b) { return a.y - b.y; }
     * }
     * const tree = new MyRBush<[number, number]>();
     * tree.insert([20, 50]); // accepts [x, y] points
     *
     * @param item The item whose bounding box should be returned.
     */
    toBBox(item: T): BBox$1;

    /**
     * Compares the minimum x coordinate of two items. Returns -1 if `a`'s
     * x-coordinate is smaller, 1 if `b`'s x coordinate is smaller, or 0 if
     * they're equal.
     *
     * By default, `RBush` assumes the format of data points to be an object
     * with `minX`, `minY`, `maxX`, and `maxY`. However, you can specify a
     * custom item format by overriding `toBBox()`, `compareMinX()`, and
     * `compareMinY()`.
     *
     * @example
     * class MyRBush<T> extends RBush<T> {
     *   toBBox([x, y]) { return { minX: x, minY: y, maxX: x, maxY: y }; }
     *   compareMinX(a, b) { return a.x - b.x; }
     *   compareMinY(a, b) { return a.y - b.y; }
     * }
     * const tree = new MyRBush<[number, number]>();
     * tree.insert([20, 50]); // accepts [x, y] points
     *
     * @param a The first item to compare.
     * @param b The second item to compare.
     */
    compareMinX(a: T, b: T): number;

    /**
     * Compares the minimum y coordinate of two items. Returns -1 if `a`'s
     * x-coordinate is smaller, 1 if `b`'s x coordinate is smaller, or 0 if
     * they're equal.
     *
     * By default, `RBush` assumes the format of data points to be an object
     * with `minX`, `minY`, `maxX`, and `maxY`. However, you can specify a
     * custom item format by overriding `toBBox()`, `compareMinX()`, and
     * `compareMinY()`.
     *
     * @example
     * class MyRBush<T> extends RBush<T> {
     *   toBBox([x, y]) { return { minX: x, minY: y, maxX: x, maxY: y }; }
     *   compareMinX(a, b) { return a.x - b.x; }
     *   compareMinY(a, b) { return a.y - b.y; }
     * }
     * const tree = new MyRBush<[number, number]>();
     * tree.insert([20, 50]); // accepts [x, y] points
     *
     * @param a The first item to compare.
     * @param b The second item to compare.
     */
    compareMinY(a: T, b: T): number;

    /**
     * Exports the tree's contents as a JSON object.
     *
     * Importing and exporting as JSON allows you to use RBush on both the
     * server (using Node.js) and the browser combined, e.g. first indexing the
     * data on the server and and then importing the resulting tree data on the
     * client for searching.
     *
     * Note that the `maxEntries` option from the constructor must be the same
     * in both trees for export/import to work properly.
     */
    toJSON(): any;

    /**
     * Imports previously exported data into the tree (i.e., data that was
     * emitted by `toJSON()`).
     *
     * Importing and exporting as JSON allows you to use RBush on both the
     * server (using Node.js) and the browser combined, e.g. first indexing the
     * data on the server and and then importing the resulting tree data on the
     * client for searching.
     *
     * Note that the `maxEntries` option from the constructor must be the same
     * in both trees for export/import to work properly.
     *
     * @param data The previously exported JSON data.
     */
    fromJSON(data: any): RBush$1<T>;
}

type Entry<T> = BBox$1 & {
    value: T;
};
/**
 * @typedef {import("rbush").BBox & {value: T}} Entry
 * @template T
 */
/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template {Object} T
 */
declare class RBush<T extends unknown> {
    /**
     * @param {number} [maxEntries] Max entries.
     */
    constructor(maxEntries?: number);
    /**
     * @private
     * @type {RBush_<Entry<T>>}
     */
    private rbush_;
    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry<T>>}
     */
    private items_;
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    insert(extent: Extent$1, value: T): void;
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
    load(extents: Array<Extent$1>, values: Array<T>): void;
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    remove(value: T): boolean;
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    update(extent: Extent$1, value: T): void;
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
    getAll(): Array<T>;
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
    getInExtent(extent: Extent$1): Array<T>;
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEach<R>(callback: (arg0: T) => R): R | undefined;
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEachInExtent<R>(extent: Extent$1, callback: (arg0: T) => R): R | undefined;
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     * @private
     */
    private forEach_;
    /**
     * @return {boolean} Is empty.
     */
    isEmpty(): boolean;
    /**
     * Remove all values from the RBush.
     */
    clear(): void;
    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
    getExtent(extent?: Extent$1): Extent$1;
    /**
     * @param {RBush<T>} rbush R-Tree.
     */
    concat(rbush: RBush<T>): void;
}

type ZIndexContextProxy = CanvasRenderingContext2D & {
    globalAlpha: any;
};
/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */
/**
 * @extends {CanvasRenderingContext2D}
 */
declare class ZIndexContext {
    /**
     * @private
     * @type {Array<Array<*>>}
     */
    private instructions_;
    /**
     * @type {number}
     */
    zIndex: number;
    /**
     * @private
     * @type {number}
     */
    private offset_;
    /**
     * @private
     * @type {ZIndexContextProxy}
     */
    private context_;
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    private pushMethodArgs_;
    /**
     * Push a function that renders to the context directly.
     * @param {function(CanvasRenderingContext2D): void} render Function.
     */
    pushFunction(render: (arg0: CanvasRenderingContext2D) => void): void;
    /**
     * Get a proxy for CanvasRenderingContext2D which does not support getting state
     * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
     * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
     * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
     * @return {ZIndexContextProxy} Context.
     */
    getContext(): ZIndexContextProxy;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     */
    draw(context: CanvasRenderingContext2D): void;
    clear(): void;
    /**
     * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
     * avoid conflicting context.clip() or context.save()/restore() calls.
     */
    offset(): void;
}

type DeclutterEntry = Entry<FeatureLike>;
type ImageOrLabelDimensions = {
    /**
     * DrawImageX.
     */
    drawImageX: number;
    /**
     * DrawImageY.
     */
    drawImageY: number;
    /**
     * DrawImageW.
     */
    drawImageW: number;
    /**
     * DrawImageH.
     */
    drawImageH: number;
    /**
     * OriginX.
     */
    originX: number;
    /**
     * OriginY.
     */
    originY: number;
    /**
     * Scale.
     */
    scale: Array<number>;
    /**
     * DeclutterBox.
     */
    declutterBox: DeclutterEntry;
    /**
     * CanvasTransform.
     */
    canvasTransform: Transform;
};
type ReplayImageOrLabelArgs = {
    0: CanvasRenderingContext2D;
    1: Size;
    2: Label | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;
    3: ImageOrLabelDimensions;
    4: number;
    5: Array<any>;
    6: Array<any>;
};
type FeatureCallback$1<T> = (arg0: FeatureLike, arg1: SimpleGeometry, arg2: DeclutterMode) => T;
declare class Executor {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
     * @param {boolean} [deferredRendering] Enable deferred rendering.
     */
    constructor(resolution: number, pixelRatio: number, overlaps: boolean, instructions: SerializableInstructions, deferredRendering?: boolean);
    /**
     * @protected
     * @type {boolean}
     */
    protected overlaps: boolean;
    /**
     * @protected
     * @type {number}
     */
    protected pixelRatio: number;
    /**
     * @protected
     * @const
     * @type {number}
     */
    protected resolution: number;
    /**
     * @private
     * @type {number}
     */
    private alignAndScaleFill_;
    /**
     * @protected
     * @type {Array<*>}
     */
    protected instructions: Array<any>;
    /**
     * @protected
     * @type {Array<number>}
     */
    protected coordinates: Array<number>;
    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */
    private coordinateCache_;
    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */
    private renderedTransform_;
    /**
     * @protected
     * @type {Array<*>}
     */
    protected hitDetectionInstructions: Array<any>;
    /**
     * @private
     * @type {Array<number>}
     */
    private pixelCoordinates_;
    /**
     * @private
     * @type {number}
     */
    private viewRotation_;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    fillStates: {
        [x: string]: FillState;
    };
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    strokeStates: {
        [x: string]: StrokeState;
    };
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    textStates: {
        [x: string]: TextState;
    };
    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    private widths_;
    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */
    private labels_;
    /**
     * @private
     * @type {import("../canvas/ZIndexContext.js").default}
     */
    private zIndexContext_;
    /**
     * @return {ZIndexContext} ZIndex context.
     */
    getZIndexContext(): ZIndexContext;
    /**
     * @param {string|Array<string>} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */
    createLabel(text: string | Array<string>, textKey: string, fillKey: string, strokeKey: string): Label;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
    replayTextBackground_(context: CanvasRenderingContext2D, p1: Coordinate, p2: Coordinate, p3: Coordinate, p4: Coordinate, fillInstruction: Array<any>, strokeInstruction: Array<any>): void;
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
    private calculateImageOrLabelDimensions_;
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
    private replayImageOrLabel_;
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
    private fill_;
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
    private setStrokeStyle_;
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
    private drawLabelWithPointPlacement_;
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
    private execute_;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     */
    execute(context: CanvasRenderingContext2D, scaledCanvasSize: Size, transform: Transform, viewRotation: number, snapToPixel: boolean, declutterTree?: RBush$1<DeclutterEntry>): void;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
    executeHitDetection<T>(context: CanvasRenderingContext2D, transform: Transform, viewRotation: number, featureCallback?: FeatureCallback$1<T>, hitExtent?: Extent$1): T | undefined;
}

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
declare function measureTextWidth(font: string, text: string): number;
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */
declare function measureAndCacheTextWidth(font: string, text: string, cache: {
    [x: string]: number;
}): number;
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */
declare function getTextDimensions(baseStyle: TextState, chunks: Array<string>): {
    width: number;
    height: number;
    widths: Array<number>;
    heights: Array<number>;
    lineWidths: Array<number>;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
declare function rotateAtOffset(context: CanvasRenderingContext2D, rotation: number, offsetX: number, offsetY: number): void;
/**
 * @param {CanvasRenderingContext2D|import("../render/canvas/ZIndexContext.js").ZIndexContextProxy} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */
declare function drawImageOrLabel(context: CanvasRenderingContext2D | ZIndexContextProxy, transform: Transform | null, opacity: number, labelOrImage: Label | HTMLCanvasElement | HTMLImageElement | HTMLVideoElement, originX: number, originY: number, w: number, h: number, x: number, y: number, scale: Size): void;
/**
 * @typedef {'Circle' | 'Image' | 'LineString' | 'Polygon' | 'Text' | 'Default'} BuilderType
 */
/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */
/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */
/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 * @property {number} [fillPatternScale] Fill pattern scale.
 */
/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */
/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {CanvasTextAlign} [textAlign] TextAlign.
 * @property {number} [repeat] Repeat.
 * @property {import("../style/Text.js").TextJustify} [justify] Justify.
 * @property {CanvasTextBaseline} textBaseline TextBaseline.
 * @property {import("../style/Text.js").TextPlacement} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */
/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */
/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */
/**
 * @const
 * @type {string}
 */
declare const defaultFont: string;
/**
 * @const
 * @type {string}
 */
declare const defaultFillStyle: string;
/**
 * @const
 * @type {CanvasLineCap}
 */
declare const defaultLineCap: CanvasLineCap;
/**
 * @const
 * @type {Array<number>}
 */
declare const defaultLineDash: Array<number>;
/**
 * @const
 * @type {number}
 */
declare const defaultLineDashOffset: number;
/**
 * @const
 * @type {CanvasLineJoin}
 */
declare const defaultLineJoin: CanvasLineJoin;
/**
 * @const
 * @type {number}
 */
declare const defaultMiterLimit: number;
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */
declare const defaultStrokeStyle: ColorLike;
/**
 * @const
 * @type {CanvasTextAlign}
 */
declare const defaultTextAlign: CanvasTextAlign;
/**
 * @const
 * @type {CanvasTextBaseline}
 */
declare const defaultTextBaseline: CanvasTextBaseline;
/**
 * @const
 * @type {Array<number>}
 */
declare const defaultPadding: Array<number>;
/**
 * @const
 * @type {number}
 */
declare const defaultLineWidth: number;
/**
 * @type {BaseObject}
 */
declare const checkedFonts: BaseObject;
/**
 * @type {!Object<string, number>}
 */
declare const textHeights: {
    [x: string]: number;
};
declare function registerFont(fontSpec: any): void;
declare function measureTextHeight(fontSpec: any): number;
type BuilderType = "Circle" | "Image" | "LineString" | "Polygon" | "Text" | "Default";
type FillState = {
    /**
     * FillStyle.
     */
    fillStyle: ColorLike;
};
type Label = {
    /**
     * Width.
     */
    width: number;
    /**
     * Height.
     */
    height: number;
    /**
     * ContextInstructions.
     */
    contextInstructions: Array<string | number>;
};
type FillStrokeState = {
    /**
     * Current FillStyle.
     */
    currentFillStyle?: ColorLike | undefined;
    /**
     * Current StrokeStyle.
     */
    currentStrokeStyle?: ColorLike | undefined;
    /**
     * Current LineCap.
     */
    currentLineCap?: CanvasLineCap | undefined;
    /**
     * Current LineDash.
     */
    currentLineDash: Array<number>;
    /**
     * Current LineDashOffset.
     */
    currentLineDashOffset?: number | undefined;
    /**
     * Current LineJoin.
     */
    currentLineJoin?: CanvasLineJoin | undefined;
    /**
     * Current LineWidth.
     */
    currentLineWidth?: number | undefined;
    /**
     * Current MiterLimit.
     */
    currentMiterLimit?: number | undefined;
    /**
     * Last stroke.
     */
    lastStroke?: number | undefined;
    /**
     * FillStyle.
     */
    fillStyle?: ColorLike | undefined;
    /**
     * StrokeStyle.
     */
    strokeStyle?: ColorLike | undefined;
    /**
     * LineCap.
     */
    lineCap?: CanvasLineCap | undefined;
    /**
     * LineDash.
     */
    lineDash: Array<number>;
    /**
     * LineDashOffset.
     */
    lineDashOffset?: number | undefined;
    /**
     * LineJoin.
     */
    lineJoin?: CanvasLineJoin | undefined;
    /**
     * LineWidth.
     */
    lineWidth?: number | undefined;
    /**
     * MiterLimit.
     */
    miterLimit?: number | undefined;
    /**
     * Fill pattern scale.
     */
    fillPatternScale?: number | undefined;
};
type StrokeState = {
    /**
     * LineCap.
     */
    lineCap: CanvasLineCap;
    /**
     * LineDash.
     */
    lineDash: Array<number>;
    /**
     * LineDashOffset.
     */
    lineDashOffset: number;
    /**
     * LineJoin.
     */
    lineJoin: CanvasLineJoin;
    /**
     * LineWidth.
     */
    lineWidth: number;
    /**
     * MiterLimit.
     */
    miterLimit: number;
    /**
     * StrokeStyle.
     */
    strokeStyle: ColorLike;
};
type TextState = {
    /**
     * Font.
     */
    font: string;
    /**
     * TextAlign.
     */
    textAlign?: CanvasTextAlign | undefined;
    /**
     * Repeat.
     */
    repeat?: number | undefined;
    /**
     * Justify.
     */
    justify?: TextJustify | undefined;
    /**
     * TextBaseline.
     */
    textBaseline: CanvasTextBaseline;
    /**
     * Placement.
     */
    placement?: TextPlacement | undefined;
    /**
     * MaxAngle.
     */
    maxAngle?: number | undefined;
    /**
     * Overflow.
     */
    overflow?: boolean | undefined;
    /**
     * BackgroundFill.
     */
    backgroundFill?: Fill | undefined;
    /**
     * BackgroundStroke.
     */
    backgroundStroke?: Stroke | undefined;
    /**
     * Scale.
     */
    scale?: Size | undefined;
    /**
     * Padding.
     */
    padding?: number[] | undefined;
};
type SerializableInstructions = {
    /**
     * The rendering instructions.
     */
    instructions: Array<any>;
    /**
     * The rendering hit detection instructions.
     */
    hitDetectionInstructions: Array<any>;
    /**
     * The array of all coordinates.
     */
    coordinates: Array<number>;
    /**
     * The text states (decluttering).
     */
    textStates?: {
        [x: string]: TextState;
    } | undefined;
    /**
     * The fill states (decluttering).
     */
    fillStates?: {
        [x: string]: FillState;
    } | undefined;
    /**
     * The stroke states (decluttering).
     */
    strokeStates?: {
        [x: string]: StrokeState;
    } | undefined;
};
type DeclutterImageWithText = {
    [x: number]: ReplayImageOrLabelArgs;
};

/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
declare class LinearRing extends SimpleGeometry {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates: Array<Coordinate> | Array<number>, layout?: GeometryLayout);
    /**
     * @private
     * @type {number}
     */
    private maxDelta_;
    /**
     * @private
     * @type {number}
     */
    private maxDeltaRevision_;
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     * @override
     */
    override clone(): LinearRing;
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea(): number;
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(): Array<Coordinate>;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     * @override
     */
    protected override getSimplifiedGeometryInternal(squaredTolerance: number): LinearRing;
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    override setCoordinates(coordinates: Array<Coordinate>, layout?: GeometryLayout): void;
}
//# sourceMappingURL=LinearRing.d.ts.map

/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
declare class Point$1 extends SimpleGeometry {
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates: Coordinate, layout?: GeometryLayout);
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     * @override
     */
    override clone(): Point$1;
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(): Coordinate;
}
//# sourceMappingURL=Point.d.ts.map

/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
declare class Polygon$1 extends SimpleGeometry {
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
     */
    constructor(coordinates: Array<Array<Coordinate>> | Array<number>, layout?: GeometryLayout, ends?: Array<number>);
    /**
     * @type {Array<number>}
     * @private
     */
    private ends_;
    /**
     * @private
     * @type {number}
     */
    private flatInteriorPointRevision_;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    private flatInteriorPoint_;
    /**
     * @private
     * @type {number}
     */
    private maxDelta_;
    /**
     * @private
     * @type {number}
     */
    private maxDeltaRevision_;
    /**
     * @private
     * @type {number}
     */
    private orientedRevision_;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private orientedFlatCoordinates_;
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */
    appendLinearRing(linearRing: LinearRing): void;
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     * @override
     */
    override clone(): Polygon$1;
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea(): number;
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(right?: boolean): Array<Array<Coordinate>>;
    /**
     * @return {Array<number>} Ends.
     */
    getEnds(): Array<number>;
    /**
     * @return {Array<number>} Interior point.
     */
    getFlatInteriorPoint(): Array<number>;
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoint(): Point$1;
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
    getLinearRingCount(): number;
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
    getLinearRing(index: number): LinearRing | null;
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
    getLinearRings(): Array<LinearRing>;
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates(): Array<number>;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     * @override
     */
    protected override getSimplifiedGeometryInternal(squaredTolerance: number): Polygon$1;
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    override setCoordinates(coordinates: Array<Array<Coordinate>>, layout?: GeometryLayout): void;
}

/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
declare class MultiPoint$1 extends SimpleGeometry {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates: Array<Coordinate> | Array<number>, layout?: GeometryLayout);
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */
    appendPoint(point: Point$1): void;
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     * @override
     */
    override clone(): MultiPoint$1;
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(): Array<Coordinate>;
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
    getPoint(index: number): Point$1;
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
    getPoints(): Array<Point$1>;
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    override setCoordinates(coordinates: Array<Coordinate>, layout?: GeometryLayout): void;
}
//# sourceMappingURL=MultiPoint.d.ts.map

/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
declare class MultiPolygon$1 extends SimpleGeometry {
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
     */
    constructor(coordinates: Array<Array<Array<Coordinate>> | Polygon$1> | Array<number>, layout?: GeometryLayout, endss?: Array<Array<number>>);
    /**
     * @type {Array<Array<number>>}
     * @private
     */
    private endss_;
    /**
     * @private
     * @type {number}
     */
    private flatInteriorPointsRevision_;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private flatInteriorPoints_;
    /**
     * @private
     * @type {number}
     */
    private maxDelta_;
    /**
     * @private
     * @type {number}
     */
    private maxDeltaRevision_;
    /**
     * @private
     * @type {number}
     */
    private orientedRevision_;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private orientedFlatCoordinates_;
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */
    appendPolygon(polygon: Polygon$1): void;
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     * @override
     */
    override clone(): MultiPolygon$1;
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea(): number;
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(right?: boolean): Array<Array<Array<Coordinate>>>;
    /**
     * @return {Array<Array<number>>} Endss.
     */
    getEndss(): Array<Array<number>>;
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints(): Array<number>;
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoints(): MultiPoint$1;
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates(): Array<number>;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     * @override
     */
    protected override getSimplifiedGeometryInternal(squaredTolerance: number): MultiPolygon$1;
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
    getPolygon(index: number): Polygon$1;
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
    getPolygons(): Array<Polygon$1>;
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    override setCoordinates(coordinates: Array<Array<Array<Coordinate>>>, layout?: GeometryLayout): void;
}
//# sourceMappingURL=MultiPolygon.d.ts.map

/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
declare class LineString$1 extends SimpleGeometry {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates: Array<Coordinate> | Array<number>, layout?: GeometryLayout);
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    private flatMidpoint_;
    /**
     * @private
     * @type {number}
     */
    private flatMidpointRevision_;
    /**
     * @private
     * @type {number}
     */
    private maxDelta_;
    /**
     * @private
     * @type {number}
     */
    private maxDeltaRevision_;
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */
    appendCoordinate(coordinate: Coordinate): void;
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     * @override
     */
    override clone(): LineString$1;
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
    forEachSegment<T, S>(callback: (this: S, arg1: Coordinate, arg2: Coordinate) => T): T | boolean;
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(m: number, extrapolate?: boolean): Coordinate | null;
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(): Array<Coordinate>;
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
    getCoordinateAt(fraction: number, dest?: Coordinate): Coordinate;
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
    getLength(): number;
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint(): Array<number>;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     * @override
     */
    protected override getSimplifiedGeometryInternal(squaredTolerance: number): LineString$1;
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    override setCoordinates(coordinates: Array<Coordinate>, layout?: GeometryLayout): void;
}
//# sourceMappingURL=LineString.d.ts.map

/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
declare class MultiLineString$1 extends SimpleGeometry {
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Flat coordinate ends for internal use.
     */
    constructor(coordinates: Array<Array<Coordinate> | LineString$1> | Array<number>, layout?: GeometryLayout, ends?: Array<number>);
    /**
     * @type {Array<number>}
     * @private
     */
    private ends_;
    /**
     * @private
     * @type {number}
     */
    private maxDelta_;
    /**
     * @private
     * @type {number}
     */
    private maxDeltaRevision_;
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */
    appendLineString(lineString: LineString$1): void;
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     * @override
     */
    override clone(): MultiLineString$1;
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(m: number, extrapolate?: boolean, interpolate?: boolean): Coordinate | null;
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    override getCoordinates(): Array<Array<Coordinate>>;
    /**
     * @return {Array<number>} Ends.
     */
    getEnds(): Array<number>;
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
    getLineString(index: number): LineString$1;
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
    getLineStrings(): Array<LineString$1>;
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints(): Array<number>;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     * @override
     */
    protected override getSimplifiedGeometryInternal(squaredTolerance: number): MultiLineString$1;
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    override setCoordinates(coordinates: Array<Array<Coordinate>>, layout?: GeometryLayout): void;
}
//# sourceMappingURL=MultiLineString.d.ts.map

/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */
declare class GeometryCollection$1 extends Geometry$1 {
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    constructor(geometries: Array<Geometry$1>);
    /**
     * @private
     * @type {Array<Geometry>}
     */
    private geometries_;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    private changeEventsKeys_;
    /**
     * @private
     */
    private unlistenGeometriesChange_;
    /**
     * @private
     */
    private listenGeometriesChange_;
    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     * @override
     */
    override clone(): GeometryCollection$1;
    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
    getGeometries(): Array<Geometry$1>;
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArray(): Array<Geometry$1>;
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArrayRecursive(): Array<Geometry$1>;
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     * @override
     */
    override getSimplifiedGeometry(squaredTolerance: number): GeometryCollection$1;
    /**
     * @return {boolean} Is empty.
     */
    isEmpty(): boolean;
    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
    setGeometries(geometries: Array<Geometry$1>): void;
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    setGeometriesArray(geometries: Array<Geometry$1>): void;
}
//# sourceMappingURL=GeometryCollection.d.ts.map

/**
 * @module ol/render/VectorContext
 */
/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
declare class VectorContext {
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     */
    drawCustom(geometry: SimpleGeometry, feature: FeatureLike, renderer: Function, hitDetectionRenderer: Function, index?: number): void;
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
    drawGeometry(geometry: Geometry$1): void;
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
    setStyle(style: Style$2): void;
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawCircle(circleGeometry: Circle, feature: Feature$2, index?: number): void;
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     * @param {number} [index] Render order index.
     */
    drawFeature(feature: Feature$2, style: Style$2, index?: number): void;
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawGeometryCollection(geometryCollectionGeometry: GeometryCollection$1, feature: Feature$2, index?: number): void;
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawLineString(lineStringGeometry: LineString$1 | RenderFeature, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiLineString(multiLineStringGeometry: MultiLineString$1 | RenderFeature, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPoint(multiPointGeometry: MultiPoint$1 | RenderFeature, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPolygon(multiPolygonGeometry: MultiPolygon$1, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPoint(pointGeometry: Point$1 | RenderFeature, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPolygon(polygonGeometry: Polygon$1 | RenderFeature, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawText(geometry: SimpleGeometry | RenderFeature, feature: FeatureLike, index?: number): void;
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(fillStyle: Fill, strokeStyle: Stroke): void;
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */
    setImageStyle(imageStyle: ImageStyle, declutterImageWithText?: DeclutterImageWithText): void;
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */
    setTextStyle(textStyle: Text$1, declutterImageWithText?: DeclutterImageWithText): void;
}
//# sourceMappingURL=VectorContext.d.ts.map

declare class BuilderGroup {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance: number, maxExtent: Extent$1, resolution: number, pixelRatio: number);
    /**
     * @private
     * @type {number}
     */
    private tolerance_;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    private maxExtent_;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @private
     * @type {number}
     */
    private resolution_;
    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */
    private buildersByZIndex_;
    /**
     * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */
    finish(): {
        [x: string]: any;
    };
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
    getBuilder(zIndex: number | undefined, builderType: BuilderType): VectorContext;
}
//# sourceMappingURL=BuilderGroup.d.ts.map

/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
declare function defaultOrder(feature1: FeatureLike, feature2: FeatureLike): number;
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
declare function getSquaredTolerance(resolution: number, pixelRatio: number): number;
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
declare function getTolerance(resolution: number, pixelRatio: number): number;
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {boolean} [declutter] Enable decluttering.
 * @param {number} [index] Render order index..
 * @return {boolean} `true` if style is loading.
 */
declare function renderFeature(replayGroup: BuilderGroup, feature: FeatureLike, style: Style$2, squaredTolerance: number, listener: (arg0: BaseEvent) => void, transform?: TransformFunction, declutter?: boolean, index?: number): boolean;
/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module :ol/Feature~Feature feature} or {@link module :ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module :ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module :ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 */
type FeatureCallback<T> = (arg0: FeatureLike, arg1: Layer<Source>, arg2: SimpleGeometry) => T;

type HitMatch<T> = {
    /**
     * Feature.
     */
    feature: FeatureLike;
    /**
     * Layer.
     */
    layer: Layer;
    /**
     * Geometry.
     */
    geometry: SimpleGeometry;
    /**
     * Squared distance.
     */
    distanceSq: number;
    /**
     * Callback.
     */
    callback: FeatureCallback<T>;
};
/**
 * @template T
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 */
/**
 * @abstract
 */
declare class MapRenderer extends Disposable {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(map: Map);
    /**
     * @private
     * @type {import("../Map.js").default}
     */
    private map_;
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    dispatchRenderEvent(type: any, frameState: FrameState): void;
    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */
    protected calculateMatrices2D(frameState: FrameState): void;
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
    forEachFeatureAtCoordinate<S, T, U>(coordinate: Coordinate, frameState: FrameState, hitTolerance: number, checkWrapped: boolean, callback: FeatureCallback<T>, thisArg: S, layerFilter: (this: U, arg1: Layer) => boolean, thisArg2: U): T | undefined;
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
    hasFeatureAtCoordinate<U>(coordinate: Coordinate, frameState: FrameState, hitTolerance: number, checkWrapped: boolean, layerFilter: (this: U, arg1: Layer) => boolean, thisArg: U): boolean;
    /**
     * @return {import("../Map.js").default} Map.
     */
    getMap(): Map;
    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    renderFrame(frameState: FrameState | null): void;
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected scheduleExpireIconCache(frameState: FrameState): void;
}

/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */
declare class MapEvent extends BaseEvent {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {?import("./Map.js").FrameState} [frameState] Frame state.
     */
    constructor(type: string, map: Map, frameState?: FrameState | null);
    /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */
    map: Map;
    /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */
    frameState: FrameState | null;
}
//# sourceMappingURL=MapEvent.d.ts.map

/**
 * *
 */
type Types$1 = "postrender" | "movestart" | "moveend" | "loadstart" | "loadend";

/**
 * *
 */
type Types = "singleclick" | "click" | "dblclick" | "pointerdrag" | "pointermove";

/**
 * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, or `'top-right'`.
 */
type Positioning = "bottom-left" | "bottom-center" | "bottom-right" | "center-left" | "center-center" | "center-right" | "top-left" | "top-center" | "top-right";
type Options$1H = {
    /**
     * Set the overlay id. The overlay id can be used
     * with the {@link module :ol/Map~Map#getOverlayById} method.
     */
    id?: string | number | undefined;
    /**
     * The overlay element.
     */
    element?: HTMLElement | undefined;
    /**
     * Offsets in pixels used when positioning
     * the overlay. The first element in the
     * array is the horizontal offset. A positive value shifts the overlay right.
     * The second element in the array is the vertical offset. A positive value
     * shifts the overlay down.
     */
    offset?: number[] | undefined;
    /**
     * The overlay position
     * in map projection.
     */
    position?: Coordinate | undefined;
    /**
     * Defines how
     * the overlay is actually positioned with respect to its `position` property.
     * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
     * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
     * `'top-center'`, and `'top-right'`.
     */
    positioning?: Positioning | undefined;
    /**
     * Whether event propagation to the map
     * viewport should be stopped. If `true` the overlay is placed in the same
     * container as that of the controls (CSS class name
     * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
     * with CSS class name specified by the `className` property.
     */
    stopEvent?: boolean | undefined;
    /**
     * Whether the overlay is inserted first
     * in the overlay container, or appended. If the overlay is placed in the same
     * container as that of the controls (see the `stopEvent` option) you will
     * probably set `insertFirst` to `true` so the overlay is displayed below the
     * controls.
     */
    insertFirst?: boolean | undefined;
    /**
     * Pan the map when calling
     * `setPosition`, so that the overlay is entirely visible in the current viewport.
     */
    autoPan?: boolean | PanIntoViewOptions | undefined;
    /**
     * CSS class
     * name.
     */
    className?: string | undefined;
};
type PanOptions = {
    /**
     * The duration of the animation in
     * milliseconds.
     */
    duration?: number | undefined;
    /**
     * The easing function to use. Can
     * be one from {@link module :ol/easing} or a custom function.
     * Default is {@link module :ol/easing.inAndOut}.
     */
    easing?: ((arg0: number) => number) | undefined;
};
type PanIntoViewOptions = {
    /**
     * The animation parameters for the pan
     */
    animation?: PanOptions | undefined;
    /**
     * The margin (in pixels) between the
     * overlay and the borders of the map when panning into view.
     */
    margin?: number | undefined;
};
type OverlayObjectEventTypes = Types$2 | "change:element" | "change:map" | "change:offset" | "change:position" | "change:positioning";
/**
 * *
 */
type OverlayOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<OverlayObjectEventTypes, ObjectEvent, Return> & CombinedOnSignature<EventTypes | OverlayObjectEventTypes, Return>;
/**
 * @typedef {import("./ObjectEventType").Types|'change:element'|'change:map'|'change:offset'|'change:position'|
 *   'change:positioning'} OverlayObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<OverlayObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature
 */
/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay.js';
 *
 *     // ...
 *     const popup = new Overlay({
 *       element: document.getElementById('popup'),
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */
declare class Overlay extends BaseObject {
    /**
     * @param {Options} options Overlay options.
     */
    constructor(options: Options$1H);
    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */
    on: OverlayOnSignature<EventsKey>;
    /***
     * @type {OverlayOnSignature<import("./events").EventsKey>}
     */
    once: OverlayOnSignature<EventsKey>;
    /***
     * @type {OverlayOnSignature<void>}
     */
    un: OverlayOnSignature<void>;
    /**
     * @protected
     * @type {Options}
     */
    protected options: Options$1H;
    /**
     * @protected
     * @type {number|string|undefined}
     */
    protected id: number | string | undefined;
    /**
     * @protected
     * @type {boolean}
     */
    protected insertFirst: boolean;
    /**
     * @protected
     * @type {boolean}
     */
    protected stopEvent: boolean;
    /**
     * @protected
     * @type {HTMLElement}
     */
    protected element: HTMLElement;
    /**
     * @protected
     * @type {PanIntoViewOptions|undefined}
     */
    protected autoPan: PanIntoViewOptions | undefined;
    /**
     * @protected
     * @type {{transform_: string,
     *         visible: boolean}}
     */
    protected rendered: {
        transform_: string;
        visible: boolean;
    };
    /**
     * @protected
     * @type {?import("./events.js").EventsKey}
     */
    protected mapPostrenderListenerKey: EventsKey | null;
    /**
     * Get the DOM element of this overlay.
     * @return {HTMLElement|undefined} The Element containing the overlay.
     * @observable
     * @api
     */
    getElement(): HTMLElement | undefined;
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId(): number | string | undefined;
    /**
     * Get the map associated with this overlay.
     * @return {import("./Map.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */
    getMap(): Map | null;
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */
    getOffset(): Array<number>;
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */
    getPosition(): Coordinate | undefined;
    /**
     * Get the current positioning of this overlay.
     * @return {Positioning} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */
    getPositioning(): Positioning;
    /**
     * @protected
     */
    protected handleElementChanged(): void;
    /**
     * @protected
     */
    protected handleMapChanged(): void;
    /**
     * @protected
     */
    protected render(): void;
    /**
     * @protected
     */
    protected handleOffsetChanged(): void;
    /**
     * @protected
     */
    protected handlePositionChanged(): void;
    /**
     * @protected
     */
    protected handlePositioningChanged(): void;
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */
    setElement(element: HTMLElement | undefined): void;
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./Map.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */
    setMap(map: Map | null): void;
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */
    setOffset(offset: Array<number>): void;
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */
    setPosition(position: Coordinate | undefined): void;
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */
    protected performAutoPan(): void;
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
     * @api
     */
    panIntoView(panIntoViewOptions?: PanIntoViewOptions): void;
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */
    protected getRect(element: HTMLElement, size: Size): Extent$1;
    /**
     * Set the positioning for this overlay.
     * @param {Positioning} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */
    setPositioning(positioning: Positioning): void;
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */
    protected setVisible(visible: boolean): void;
    /**
     * Update pixel position.
     * @protected
     */
    protected updatePixelPosition(): void;
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */
    protected updateRenderedPosition(pixel: Pixel, mapSize: Size | undefined): void;
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */
    getOptions(): Options$1H;
}

/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */
declare class MapBrowserEvent<EVENT extends UIEvent> extends MapEvent {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [dragging] Is the map currently being dragged?
     * @param {import("./Map.js").FrameState} [frameState] Frame state.
     * @param {Array<PointerEvent>} [activePointers] Active pointers.
     */
    constructor(type: string, map: Map, originalEvent: EVENT, dragging?: boolean, frameState?: FrameState, activePointers?: Array<PointerEvent>);
    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */
    originalEvent: EVENT;
    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     * @private
     */
    private pixel_;
    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     * @private
     */
    private coordinate_;
    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    dragging: boolean;
    /**
     * @type {Array<PointerEvent>|undefined}
     */
    activePointers: Array<PointerEvent> | undefined;
    set pixel(pixel: Pixel);
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get pixel(): Pixel;
    set coordinate(coordinate: Coordinate);
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get coordinate(): Coordinate;
}
//# sourceMappingURL=MapBrowserEvent.d.ts.map

/**
 * *
 */
type InteractionOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active", Return>;
/**
 * Object literal with config options for interactions.
 */
type InteractionOptions = {
    /**
     * Method called by the map to notify the interaction that a browser event was
     * dispatched to the map. If the function returns a falsy value, propagation of
     * the event to other interactions in the map's interactions chain will be
     * prevented (this includes functions with no explicit return). The interactions
     * are traversed in reverse order of the interactions collection of the map.
     */
    handleEvent?: ((arg0: MapBrowserEvent<any>) => boolean) | undefined;
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */
/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
declare class Interaction extends BaseObject {
    /**
     * @param {InteractionOptions} [options] Options.
     */
    constructor(options?: InteractionOptions);
    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    on: InteractionOnSignature<EventsKey>;
    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    once: InteractionOnSignature<EventsKey>;
    /***
     * @type {InteractionOnSignature<void>}
     */
    un: InteractionOnSignature<void>;
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    handleEvent(mapBrowserEvent: MapBrowserEvent<any>): boolean;
    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    private map_;
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */
    getActive(): boolean;
    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap(): Map | null;
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    setActive(active: boolean): void;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(map: Map | null): void;
}

type Options$1G = {
    /**
     * The element is the control's
     * container element. This only needs to be specified if you're developing
     * a custom control.
     */
    element?: HTMLElement | undefined;
    /**
     * Function called when
     * the control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Specify a target if you want
     * the control to be rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
};
/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
declare class Control extends BaseObject {
    /**
     * @param {Options} options Control options.
     */
    constructor(options: Options$1G);
    /**
     * @protected
     * @type {HTMLElement}
     */
    protected element: HTMLElement;
    /**
     * @private
     * @type {HTMLElement}
     */
    private target_;
    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    private map_;
    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */
    protected listenerKeys: Array<EventsKey>;
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
    render(mapEvent: MapEvent): void;
    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap(): Map | null;
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(map: Map | null): void;
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
    setTarget(target: HTMLElement | string): void;
}

/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
declare class PriorityQueue<T> {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    constructor(priorityFunction: (arg0: T) => number, keyFunction: (arg0: T) => string);
    /**
     * @type {function(T): number}
     * @private
     */
    private priorityFunction_;
    /**
     * @type {function(T): string}
     * @private
     */
    private keyFunction_;
    /**
     * @type {Array<T>}
     * @private
     */
    private elements_;
    /**
     * @type {Array<number>}
     * @private
     */
    private priorities_;
    /**
     * @type {!Object<string, boolean>}
     * @private
     */
    private queuedElements_;
    /**
     * FIXME empty description for jsdoc
     */
    clear(): void;
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    dequeue(): T;
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    enqueue(element: T): boolean;
    /**
     * @return {number} Count.
     */
    getCount(): number;
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    private getLeftChildIndex_;
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    private getRightChildIndex_;
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    private getParentIndex_;
    /**
     * Make this a heap. O(N).
     * @private
     */
    private heapify_;
    /**
     * @return {boolean} Is empty.
     */
    isEmpty(): boolean;
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    isKeyQueued(key: string): boolean;
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    isQueued(element: T): boolean;
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    private siftUp_;
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    private siftDown_;
    /**
     * FIXME empty description for jsdoc
     */
    reprioritize(): void;
}

type PriorityFunction = (arg0: Tile$1, arg1: string, arg2: Coordinate, arg3: number) => number;
/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */
declare class TileQueue extends PriorityQueue<any> {
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    constructor(tilePriorityFunction: PriorityFunction, tileChangeCallback: () => unknown);
    /** @private */
    private boundHandleTileChange_;
    /**
     * @private
     * @type {function(): ?}
     */
    private tileChangeCallback_;
    /**
     * @private
     * @type {number}
     */
    private tilesLoading_;
    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    private tilesLoadingKeys_;
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     * @override
     */
    override enqueue(element: any[]): boolean;
    /**
     * @return {number} Number of tiles loading.
     */
    getTilesLoading(): number;
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
    protected handleTileChange(event: BaseEvent): void;
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
    loadMoreTiles(maxTotalLoading: number, maxNewLoads: number): void;
}

/**
 * @typedef {'addlayer'|'removelayer'} GroupEventType
 */
/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */
declare class GroupEvent extends BaseEvent {
    /**
     * @param {GroupEventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    constructor(type: GroupEventType, layer: BaseLayer);
    /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */
    layer: BaseLayer;
}

type GroupEventType = "addlayer" | "removelayer";
/**
 * *
 */
type GroupOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<BaseLayerObjectEventTypes | "change:layers", ObjectEvent, Return> & CombinedOnSignature<EventTypes | BaseLayerObjectEventTypes | "change:layers", Return>;
type Options$1F = {
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Child layers.
     */
    layers?: BaseLayer[] | Collection<BaseLayer> | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};

/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
declare class LayerGroup extends BaseLayer {
    /**
     * @param {Options} [options] Layer options.
     */
    constructor(options?: Options$1F);
    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    on: GroupOnSignature<EventsKey>;
    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    once: GroupOnSignature<EventsKey>;
    /***
     * @type {GroupOnSignature<void>}
     */
    un: GroupOnSignature<void>;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    private layersListenerKeys_;
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    private listenerKeys_;
    /**
     * @private
     */
    private handleLayerChange_;
    /**
     * @private
     */
    private handleLayersChanged_;
    /**
     * @param {BaseLayer} layer The layer.
     */
    registerLayerListeners_(layer: BaseLayer): void;
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupAdd_(event: GroupEvent): void;
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupRemove_(event: GroupEvent): void;
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    private handleLayersAdd_;
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    private handleLayersRemove_;
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    getLayers(): Collection<BaseLayer>;
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    setLayers(layers: Collection<BaseLayer>): void;
}

/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 */
type FrameState = {
    /**
     * The pixel ratio of the frame.
     */
    pixelRatio: number;
    /**
     * The time when rendering of the frame was requested.
     */
    time: number;
    /**
     * The state of the current view.
     */
    viewState: State$3;
    /**
     * Animate.
     */
    animate: boolean;
    /**
     * CoordinateToPixelTransform.
     */
    coordinateToPixelTransform: Transform;
    /**
     * Declutter trees by declutter group.
     * When null, no decluttering is needed because no layers have decluttering enabled.
     */
    declutter: {
        [x: string]: RBush$1<DeclutterEntry>;
    } | null;
    /**
     * Extent (in view projection coordinates).
     */
    extent: null | Extent$1;
    /**
     * Next extent during an animation series.
     */
    nextExtent?: Extent$1 | undefined;
    /**
     * Index.
     */
    index: number;
    /**
     * LayerStatesArray.
     */
    layerStatesArray: Array<State$1>;
    /**
     * LayerIndex.
     */
    layerIndex: number;
    /**
     * PixelToCoordinateTransform.
     */
    pixelToCoordinateTransform: Transform;
    /**
     * PostRenderFunctions.
     */
    postRenderFunctions: Array<PostRenderFunction>;
    /**
     * Size.
     */
    size: Size;
    /**
     * TileQueue.
     */
    tileQueue: TileQueue;
    /**
     * UsedTiles.
     */
    usedTiles: {
        [x: string]: {
            [x: string]: boolean;
        };
    };
    /**
     * ViewHints.
     */
    viewHints: Array<number>;
    /**
     * WantedTiles.
     */
    wantedTiles: {
        [x: string]: {
            [x: string]: boolean;
        };
    };
    /**
     * The id of the map.
     */
    mapId: string;
    /**
     * Identifiers of previously rendered elements.
     */
    renderTargets: {
        [x: string]: boolean;
    };
};
type PostRenderFunction = (arg0: Map, arg1: FrameState) => any;
type AtPixelOptions = {
    /**
     * Layer filter
     * function. The filter function will receive one argument, the
     * {@link module :ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
     * Only layers which are visible and for which this function returns `true`
     * will be tested for features. By default, all visible layers will be tested.
     */
    layerFilter?: undefined | ((arg0: Layer<Source>) => boolean);
    /**
     * Hit-detection tolerance in css pixels. Pixels
     * inside the radius around the given position will be checked for features.
     */
    hitTolerance?: number | undefined;
    /**
     * Check-Wrapped Will check for wrapped geometries inside the range of
     * +/- 1 world width. Works only if a projection is used that can be wrapped.
     */
    checkWrapped?: boolean | undefined;
};
type MapObjectEventTypes = Types$2 | "change:layergroup" | "change:size" | "change:target" | "change:view";
/**
 * *
 */
type MapEventHandler<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<MapObjectEventTypes, ObjectEvent, Return> & OnSignature<Types, MapBrowserEvent<any>, Return> & OnSignature<Types$1, MapEvent, Return> & OnSignature<MapRenderEventTypes, RenderEvent, Return> & CombinedOnSignature<EventTypes | MapObjectEventTypes | Types | Types$1 | MapRenderEventTypes, Return>;
/**
 * Object literal with config options for the map.
 */
type MapOptions = {
    /**
     * Controls initially added to the map. If not specified,
     * {@link module :ol/control/defaults.defaults} is used.
     */
    controls?: Collection<Control> | Control[] | undefined;
    /**
     * The ratio between
     * physical pixels and device-independent pixels (dips) on the device.
     */
    pixelRatio?: number | undefined;
    /**
     * Interactions that are initially added to the map. If not specified,
     * {@link module :ol/interaction/defaults.defaults} is used.
     */
    interactions?: Collection<Interaction> | Interaction[] | undefined;
    /**
     * The element to
     * listen to keyboard events on. This determines when the `KeyboardPan` and
     * `KeyboardZoom` interactions trigger. For example, if this option is set to
     * `document` the keyboard interactions will always trigger. If this option is
     * not specified, the element the library listens to keyboard events on is the
     * map target (i.e. the user-provided div for the map). If this is not
     * `document`, the target element needs to be focused for key events to be
     * emitted, requiring that the target element has a `tabindex` attribute.
     */
    keyboardEventTarget?: string | Document | HTMLElement | undefined;
    /**
     * Layers. If this is not defined, a map with no layers will be rendered. Note
     * that layers are rendered in the order supplied, so if you want, for example,
     * a vector layer to appear on top of a tile layer, it must come after the tile
     * layer.
     */
    layers?: BaseLayer[] | Collection<BaseLayer> | LayerGroup | undefined;
    /**
     * Maximum number tiles to load
     * simultaneously.
     */
    maxTilesLoading?: number | undefined;
    /**
     * The minimum distance in pixels the
     * cursor must move to be detected as a map move event instead of a click.
     * Increasing this value can make it easier to click on the map.
     */
    moveTolerance?: number | undefined;
    /**
     * Overlays initially added to the map. By default, no overlays are added.
     */
    overlays?: Collection<Overlay> | Overlay[] | undefined;
    /**
     * The container for the map, either the
     * element itself or the `id` of the element. If not specified at construction
     * time, {@link module :ol/Map~Map#setTarget} must be called for the map to be
     * rendered. If passed by element, the container can be in a secondary document.
     * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
     * properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
     * `tabindex` atribute must be set on the custom element's host element.
     * **Note:** CSS `transform` support for the target element is limited to `scale`.
     */
    target?: string | HTMLElement | undefined;
    /**
     * The map's view.  No layer sources will be
     * fetched unless this is specified at construction time or through
     * {@link module :ol/Map~Map#setView}.
     */
    view?: View | Promise<ViewOptions> | undefined;
};
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map.js';
 *     import View from 'ol/View.js';
 *     import TileLayer from 'ol/layer/Tile.js';
 *     import OSM from 'ol/source/OSM.js';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
declare class Map extends BaseObject {
    /**
     * @param {MapOptions} [options] Map options.
     */
    constructor(options?: MapOptions);
    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    on: MapEventHandler<EventsKey>;
    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    once: MapEventHandler<EventsKey>;
    /***
     * @type {MapEventHandler<void>}
     */
    un: MapEventHandler<void>;
    /**
     * @private
     * @type {boolean}
     */
    private renderComplete_;
    /**
     * @private
     * @type {boolean}
     */
    private loaded_;
    /** @private */
    private boundHandleBrowserEvent_;
    /**
     * @type {number}
     * @private
     */
    private maxTilesLoading_;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    private postRenderTimeoutHandle_;
    /**
     * @private
     * @type {number|undefined}
     */
    private animationDelayKey_;
    /**
     * @private
     */
    private animationDelay_;
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    private coordinateToPixelTransform_;
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    private pixelToCoordinateTransform_;
    /**
     * @private
     * @type {number}
     */
    private frameIndex_;
    /**
     * @private
     * @type {?FrameState}
     */
    private frameState_;
    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */
    private previousExtent_;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    private viewPropertyListenerKey_;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    private viewChangeListenerKey_;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    private layerGroupPropertyListenerKeys_;
    /**
     * @private
     * @type {!HTMLElement}
     */
    private viewport_;
    /**
     * @private
     * @type {!HTMLElement}
     */
    private overlayContainer_;
    /**
     * @private
     * @type {!HTMLElement}
     */
    private overlayContainerStopEvent_;
    /**
     * @private
     * @type {MapBrowserEventHandler}
     */
    private mapBrowserEventHandler_;
    /**
     * @private
     * @type {number}
     */
    private moveTolerance_;
    /**
     * @private
     * @type {HTMLElement|Document}
     */
    private keyboardEventTarget_;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    private targetChangeHandlerKeys_;
    /**
     * @private
     * @type {HTMLElement|null}
     */
    private targetElement_;
    /**
     * @private
     * @type {ResizeObserver}
     */
    private resizeObserver_;
    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */
    protected controls: Collection<Control>;
    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */
    protected interactions: Collection<Interaction>;
    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */
    private overlays_;
    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */
    private overlayIdIndex_;
    /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */
    private renderer_;
    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */
    private postRenderFunctions_;
    /**
     * @private
     * @type {TileQueue}
     */
    private tileQueue_;
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */
    addControl(control: Control): void;
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
    addInteraction(interaction: Interaction): void;
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
    addLayer(layer: BaseLayer): void;
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
    private handleLayerAdd_;
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
    addOverlay(overlay: Overlay): void;
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
    private addOverlayInternal_;
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
    forEachFeatureAtPixel<T>(pixel: Pixel, callback: (arg0: FeatureLike, arg1: Layer<Source>, arg2: SimpleGeometry) => T, options?: AtPixelOptions): T | undefined;
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
    getFeaturesAtPixel(pixel: Pixel, options?: AtPixelOptions): Array<FeatureLike>;
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
    getAllLayers(): Array<Layer>;
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
    hasFeatureAtPixel(pixel: Pixel, options?: AtPixelOptions): boolean;
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    getEventCoordinate(event: MouseEvent): Coordinate;
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
    getEventCoordinateInternal(event: MouseEvent): Coordinate;
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent|{clientX: number, clientY: number}} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
    getEventPixel(event: UIEvent | {
        clientX: number;
        clientY: number;
    }): Pixel;
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
    getTarget(): HTMLElement | string | undefined;
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
    getTargetElement(): HTMLElement;
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
    getCoordinateFromPixel(pixel: Pixel): Coordinate;
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
    getCoordinateFromPixelInternal(pixel: Pixel): Coordinate;
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
    getControls(): Collection<Control>;
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
    getOverlays(): Collection<Overlay>;
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default|null} Overlay.
     * @api
     */
    getOverlayById(id: string | number): Overlay | null;
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
    getInteractions(): Collection<Interaction>;
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
    getLayerGroup(): LayerGroup;
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
    setLayers(layers: Array<BaseLayer> | Collection<BaseLayer>): void;
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
    getLayers(): Collection<BaseLayer>;
    /**
     * @return {boolean} Layers have sources that are still loading.
     */
    getLoadingOrNotReady(): boolean;
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
    getPixelFromCoordinate(coordinate: Coordinate): Pixel;
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
    getPixelFromCoordinateInternal(coordinate: Coordinate): Pixel;
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */
    getRenderer(): MapRenderer | null;
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    getSize(): Size | undefined;
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
    getView(): View;
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
    getViewport(): HTMLElement;
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
    getOverlayContainer(): HTMLElement;
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
    getOverlayContainerStopEvent(): HTMLElement;
    /**
     * @return {!Document} The document where the map is displayed.
     */
    getOwnerDocument(): Document;
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    getTilePriority(tile: Tile$1, tileSourceKey: string, tileCenter: Coordinate, tileResolution: number): number;
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */
    handleBrowserEvent(browserEvent: UIEvent, type?: string): void;
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
    handleMapBrowserEvent(mapBrowserEvent: MapBrowserEvent<any>): void;
    /**
     * @protected
     */
    protected handlePostRender(): void;
    /**
     * @private
     */
    private handleSizeChanged_;
    /**
     * @private
     */
    private handleTargetChanged_;
    /**
     * @private
     */
    private handleTileChange_;
    /**
     * @private
     */
    private handleViewPropertyChanged_;
    /**
     * @private
     */
    private handleViewChanged_;
    /**
     * @private
     */
    private handleLayerGroupChanged_;
    /**
     * @return {boolean} Is rendered.
     */
    isRendered(): boolean;
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
    renderSync(): void;
    /**
     * Redraws all text after new fonts have loaded
     */
    redrawText(): void;
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
    render(): void;
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
    removeControl(control: Control): Control | undefined;
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
    removeInteraction(interaction: Interaction): Interaction | undefined;
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
    removeLayer(layer: BaseLayer): BaseLayer | undefined;
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
    private handleLayerRemove_;
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
    removeOverlay(overlay: Overlay): Overlay | undefined;
    /**
     * @param {number} time Time.
     * @private
     */
    private renderFrame_;
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
    setLayerGroup(layerGroup: LayerGroup): void;
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    setSize(size: Size | undefined): void;
    /**
     * Set the target element to render this map into.
     * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
     *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
     *  `tabindex` atribute must be set on the custom element's host element.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
    setTarget(target?: HTMLElement | string): void;
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
    setView(view: View | Promise<ViewOptions>): void;
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
    updateSize(): void;
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @param {import("./size.js").Size|undefined} size The size.
     * @private
     */
    private updateViewportSize_;
}

declare class RenderEvent extends BaseEvent {
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
     */
    constructor(type: any, inversePixelTransform?: Transform, frameState?: FrameState, context?: (CanvasRenderingContext2D | WebGLRenderingContext) | null);
    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */
    inversePixelTransform: Transform | undefined;
    /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */
    frameState: FrameState | undefined;
    /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */
    context: CanvasRenderingContext2D | WebGLRenderingContext | undefined;
}
//# sourceMappingURL=Event.d.ts.map

/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
declare class CanvasImmediateRenderer extends VectorContext {
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
     */
    constructor(context: CanvasRenderingContext2D, pixelRatio: number, extent: Extent$1, transform: Transform, viewRotation: number, squaredTolerance?: number, userTransform?: TransformFunction);
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    private context_;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    private extent_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private transform_;
    /**
     * @private
     * @type {number}
     */
    private transformRotation_;
    /**
     * @private
     * @type {number}
     */
    private viewRotation_;
    /**
     * @private
     * @type {number}
     */
    private squaredTolerance_;
    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */
    private userTransform_;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    private contextFillState_;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    private contextStrokeState_;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    private contextTextState_;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    private fillState_;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    private strokeState_;
    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    private image_;
    /**
     * @private
     * @type {number}
     */
    private imageAnchorX_;
    /**
     * @private
     * @type {number}
     */
    private imageAnchorY_;
    /**
     * @private
     * @type {number}
     */
    private imageHeight_;
    /**
     * @private
     * @type {number}
     */
    private imageOpacity_;
    /**
     * @private
     * @type {number}
     */
    private imageOriginX_;
    /**
     * @private
     * @type {number}
     */
    private imageOriginY_;
    /**
     * @private
     * @type {boolean}
     */
    private imageRotateWithView_;
    /**
     * @private
     * @type {number}
     */
    private imageRotation_;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    private imageScale_;
    /**
     * @private
     * @type {number}
     */
    private imageWidth_;
    /**
     * @private
     * @type {string}
     */
    private text_;
    /**
     * @private
     * @type {number}
     */
    private textOffsetX_;
    /**
     * @private
     * @type {number}
     */
    private textOffsetY_;
    /**
     * @private
     * @type {boolean}
     */
    private textRotateWithView_;
    /**
     * @private
     * @type {number}
     */
    private textRotation_;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    private textScale_;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    private textFillState_;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    private textStrokeState_;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    private textState_;
    /**
     * @private
     * @type {Array<number>}
     */
    private pixelCoordinates_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private tmpLocalTransform_;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    private drawImages_;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    private drawText_;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
    private moveToLineTo_;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    private drawRings_;
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     * @override
     */
    override drawCircle(geometry: Circle): void;
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    setTransform(transform: Transform): void;
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     * @override
     */
    override drawGeometry(geometry: Geometry$1 | RenderFeature): void;
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     * @override
     */
    override drawFeature(feature: Feature$2, style: Style$2): void;
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     * @override
     */
    override drawGeometryCollection(geometry: GeometryCollection$1): void;
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     * @override
     */
    override drawPoint(geometry: Point$1 | RenderFeature): void;
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     * @override
     */
    override drawMultiPoint(geometry: MultiPoint$1 | RenderFeature): void;
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     * @override
     */
    override drawLineString(geometry: LineString$1 | RenderFeature): void;
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     * @override
     */
    override drawMultiLineString(geometry: MultiLineString$1 | RenderFeature): void;
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     * @override
     */
    override drawPolygon(geometry: Polygon$1 | RenderFeature): void;
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @override
     */
    override drawMultiPolygon(geometry: MultiPolygon$1): void;
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
    private setContextFillState_;
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
    private setContextStrokeState_;
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
    private setContextTextState_;
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @override
     */
    override setImageStyle(imageStyle: ImageStyle): void;
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @override
     */
    override setTextStyle(textStyle: Text$1): void;
}
//# sourceMappingURL=Immediate.d.ts.map

/**
 * @typedef {Object} State
 * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.
 * @property {import("./Feature.js").FeatureLike} feature Feature.
 * @property {import("./geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} pixelRatio Pixel ratio used by the layer renderer.
 * @property {number} resolution Resolution that the render batch was created and optimized for.
 * This is not the view's resolution that is being rendered.
 * @property {number} rotation Rotation of the rendered layer in radians.
 */
/**
 * A function to be used when sorting features before rendering.
 * It takes two instances of {@link module:ol/Feature~Feature} or
 * {@link module:ol/render/Feature~RenderFeature} and returns a `{number}`.
 *
 * @typedef {function(import("./Feature.js").FeatureLike, import("./Feature.js").FeatureLike):number} OrderFunction
 */
/**
 * @typedef {Object} ToContextOptions
 * @property {import("./size.js").Size} [size] Desired size of the canvas in css
 * pixels. When provided, both canvas and css size will be set according to the
 * `pixelRatio`. If not provided, the current canvas and css sizes will not be
 * altered.
 * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas
 * pixel to css pixel ratio) for the canvas.
 */
/**
 * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
 * to the context's canvas.
 *
 * The units for geometry coordinates are css pixels relative to the top left
 * corner of the canvas element.
 * ```js
 * import {toContext} from 'ol/render.js';
 * import Fill from 'ol/style/Fill.js';
 * import Polygon from 'ol/geom/Polygon.js';
 *
 * const canvas = document.createElement('canvas');
 * const render = toContext(
 *     canvas.getContext('2d'),
 *     {size: [100, 100]}
 * );
 * render.setFillStrokeStyle(new Fill({ color: blue }));
 * render.drawPolygon(
 *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]])
 * );
 * ```
 *
 * @param {CanvasRenderingContext2D} context Canvas context.
 * @param {ToContextOptions} [options] Options.
 * @return {CanvasImmediateRenderer} Canvas Immediate.
 * @api
 */
declare function toContext(context: CanvasRenderingContext2D, options?: ToContextOptions): CanvasImmediateRenderer;
/**
 * Gets a vector context for drawing to the event's canvas.
 * @param {import("./render/Event.js").default} event Render event.
 * @return {CanvasImmediateRenderer} Vector context.
 * @api
 */
declare function getVectorContext(event: RenderEvent): CanvasImmediateRenderer;
/**
 * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.
 * @param {import("./render/Event.js").default} event Render event.
 * @param {import("./pixel.js").Pixel} pixel CSS pixel relative to the top-left
 * corner of the map viewport.
 * @return {import("./pixel.js").Pixel} Pixel on the event's canvas context.
 * @api
 */
declare function getRenderPixel(event: RenderEvent, pixel: Pixel): Pixel;
type State = {
    /**
     * Canvas context that the layer is being rendered to.
     */
    context: CanvasRenderingContext2D;
    /**
     * Feature.
     */
    feature: FeatureLike;
    /**
     * Geometry.
     */
    geometry: SimpleGeometry;
    /**
     * Pixel ratio used by the layer renderer.
     */
    pixelRatio: number;
    /**
     * Resolution that the render batch was created and optimized for.
     * This is not the view's resolution that is being rendered.
     */
    resolution: number;
    /**
     * Rotation of the rendered layer in radians.
     */
    rotation: number;
};
/**
 * A function to be used when sorting features before rendering.
 * It takes two instances of {@link module :ol/Feature~Feature} or
 * {@link module :ol/render/Feature~RenderFeature} and returns a `{number}`.
 */
type OrderFunction = (arg0: FeatureLike, arg1: FeatureLike) => number;
type ToContextOptions = {
    /**
     * Desired size of the canvas in css
     * pixels. When provided, both canvas and css size will be set according to the
     * `pixelRatio`. If not provided, the current canvas and css sizes will not be
     * altered.
     */
    size?: Size | undefined;
    /**
     * Pixel ratio (canvas
     * pixel to css pixel ratio) for the canvas.
     */
    pixelRatio?: number | undefined;
};

/**
 * Defines how symbols and text are decluttered on layers ith `declutter` set to `true`
 * * **declutter**: Overlapping symbols and text are decluttered.
 * * **obstacle**: Symbols and text are rendered, but serve as obstacle for subsequent attempts
 *   to place a symbol or text at the same location.
 * * **none**: No decluttering is done.
 */
type DeclutterMode = "declutter" | "obstacle" | "none";
/**
 * A function that takes a {@link module :ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module :ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 */
type StyleFunction = (arg0: FeatureLike, arg1: number) => (Style$2 | Array<Style$2> | void);
/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 */
type StyleLike = Style$2 | Array<Style$2> | StyleFunction;
/**
 * A function that takes a {@link module :ol/Feature~Feature} as argument and returns an
 * {@link module :ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 */
type GeometryFunction$1 = (arg0: FeatureLike) => (Geometry$1 | RenderFeature | undefined);
/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module :ol/render~State} of the layer renderer.
 */
type RenderFunction = (arg0: (Coordinate | Array<Coordinate> | Array<Array<Coordinate>> | Array<Array<Array<Coordinate>>>), arg1: State) => void;
type Options$1E = {
    /**
     * Feature property or geometry
     * or function returning a geometry to render for this style.
     */
    geometry?: string | Geometry$1 | GeometryFunction$1 | undefined;
    /**
     * Fill style.
     */
    fill?: Fill | undefined;
    /**
     * Image style.
     */
    image?: ImageStyle | undefined;
    /**
     * Custom renderer. When configured, `fill`, `stroke` and `image` will be
     * ignored, and the provided function will be called with each render frame for each geometry.
     */
    renderer?: RenderFunction | undefined;
    /**
     * Custom renderer for hit detection. If provided will be used
     * in hit detection rendering.
     */
    hitDetectionRenderer?: RenderFunction | undefined;
    /**
     * Stroke style.
     */
    stroke?: Stroke | undefined;
    /**
     * Text style.
     */
    text?: Text$1 | undefined;
    /**
     * Z index.
     */
    zIndex?: number | undefined;
};
/**
 * Defines how symbols and text are decluttered on layers ith `declutter` set to `true`
 * * **declutter**: Overlapping symbols and text are decluttered.
 * * **obstacle**: Symbols and text are rendered, but serve as obstacle for subsequent attempts
 *   to place a symbol or text at the same location.
 * * **none**: No decluttering is done.
 *
 * @typedef {"declutter"|"obstacle"|"none"} DeclutterMode
 */
/**
 * A function that takes a {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */
/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */
/**
 * A function that takes a {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */
/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>|Array<Array<Array<import("../coordinate.js").Coordinate>>>),import("../render.js").State): void} RenderFunction
 */
/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */
/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */
declare class Style$2 {
    /**
     * @param {Options} [options] Style options.
     */
    constructor(options?: Options$1E);
    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     */
    private geometry_;
    /**
     * @private
     * @type {!GeometryFunction}
     */
    private geometryFunction_;
    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    private fill_;
    /**
     * @private
     * @type {import("./Image.js").default|null}
     */
    private image_;
    /**
     * @private
     * @type {RenderFunction|null}
     */
    private renderer_;
    /**
     * @private
     * @type {RenderFunction|null}
     */
    private hitDetectionRenderer_;
    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    private stroke_;
    /**
     * @private
     * @type {import("./Text.js").default|null}
     */
    private text_;
    /**
     * @private
     * @type {number|undefined}
     */
    private zIndex_;
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */
    clone(): Style$2;
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getRenderer(): RenderFunction | null;
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setRenderer(renderer: RenderFunction | null): void;
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setHitDetectionRenderer(renderer: RenderFunction | null): void;
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getHitDetectionRenderer(): RenderFunction | null;
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    getGeometry(): string | Geometry$1 | GeometryFunction$1 | null;
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    getGeometryFunction(): GeometryFunction$1;
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill(): Fill | null;
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(fill: Fill | null): void;
    /**
     * Get the image style.
     * @return {import("./Image.js").default|null} Image style.
     * @api
     */
    getImage(): ImageStyle | null;
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
    setImage(image: ImageStyle): void;
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke(): Stroke | null;
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(stroke: Stroke | null): void;
    /**
     * Get the text style.
     * @return {import("./Text.js").default|null} Text style.
     * @api
     */
    getText(): Text$1 | null;
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
    setText(text: Text$1): void;
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    getZIndex(): number | undefined;
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
    setGeometry(geometry: string | Geometry$1 | GeometryFunction$1): void;
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    setZIndex(zIndex: number | undefined): void;
}

/**
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.
 */
type Type$1 = "Point" | "LineString" | "LinearRing" | "Polygon" | "MultiPoint" | "MultiLineString";
/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */
declare class RenderFeature {
    /**
     * @param {Type} type Geometry type.
     * @param {Array<number>} flatCoordinates Flat coordinates. These always need
     *     to be right-handed for polygons.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Object<string, *>} properties Properties.
     * @param {number|string|undefined} id Feature id.
     */
    constructor(type: Type$1, flatCoordinates: Array<number>, ends: Array<number>, stride: number, properties: {
        [x: string]: any;
    }, id: number | string | undefined);
    /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */
    styleFunction: StyleFunction | undefined;
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */
    private extent_;
    /**
     * @private
     * @type {number|string|undefined}
     */
    private id_;
    /**
     * @private
     * @type {Type}
     */
    private type_;
    /**
     * @private
     * @type {Array<number>}
     */
    private flatCoordinates_;
    /**
     * @private
     * @type {Array<number>}
     */
    private flatInteriorPoints_;
    /**
     * @private
     * @type {Array<number>}
     */
    private flatMidpoints_;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private ends_;
    /**
     * @private
     * @type {Object<string, *>}
     */
    private properties_;
    /**
     * @private
     * @type {number}
     */
    private squaredTolerance_;
    /**
     * @private
     * @type {number}
     */
    private stride_;
    /**
     * @private
     * @type {RenderFeature}
     */
    private simplifiedGeometry_;
    /**
     * Get a feature property by its key.
     * @param {string} key Key
     * @return {*} Value for the requested key.
     * @api
     */
    get(key: string): any;
    /**
     * Get the extent of this feature's geometry.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(): Extent$1;
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoint(): Array<number>;
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints(): Array<number>;
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint(): Array<number>;
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints(): Array<number>;
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is set when reading data from a remote source.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId(): number | string | undefined;
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getOrientedFlatCoordinates(): Array<number>;
    /**
     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
     * determining the geometry type in style function (see {@link #getType}).
     * @return {RenderFeature} Feature.
     * @api
     */
    getGeometry(): RenderFeature;
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {RenderFeature} Simplified geometry.
     */
    getSimplifiedGeometry(squaredTolerance: number): RenderFeature;
    /**
     * Get a transformed and simplified version of the geometry.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {RenderFeature} Simplified geometry.
     */
    simplifyTransformed(squaredTolerance: number, transform?: TransformFunction): RenderFeature;
    /**
     * Get the feature properties.
     * @return {Object<string, *>} Feature properties.
     * @api
     */
    getProperties(): {
        [x: string]: any;
    };
    /**
     * Get an object of all property names and values.  This has the same behavior as getProperties,
     * but is here to conform with the {@link module:ol/Feature~Feature} interface.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal(): {
        [x: string]: any;
    } | null;
    /**
     * @return {number} Stride.
     */
    getStride(): number;
    /**
     * @return {import('../style/Style.js').StyleFunction|undefined} Style
     */
    getStyleFunction(): StyleFunction | undefined;
    /**
     * Get the type of this feature's geometry.
     * @return {Type} Geometry type.
     * @api
     */
    getType(): Type$1;
    /**
     * Transform geometry coordinates from tile pixel space to projected.
     *
     * @param {import("../proj.js").ProjectionLike} projection The data projection
     */
    transform(projection: ProjectionLike): void;
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     */
    applyTransform(transformFn: TransformFunction): void;
    /**
     * @return {RenderFeature} A cloned render feature.
     */
    clone(): RenderFeature;
    /**
     * @return {Array<number>|null} Ends.
     */
    getEnds(): Array<number> | null;
    /**
     * Add transform and resolution based geometry simplification to this instance.
     * @return {RenderFeature} This render feature.
     */
    enableSimplifyTransformed(): RenderFeature;
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getFlatCoordinates: () => Array<number>;
}

type FeatureLike = Feature$2 | RenderFeature;
/**
 * *
 */
type FeatureOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:geometry", ObjectEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:geometry", Return>;
/**
 * *
 */
type ObjectWithGeometry<Geometry extends Geometry$1 = Geometry$1> = {
    [x: string]: any;
} & {
    geometry?: Geometry;
};
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */
/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */
/***
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */
/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */
declare class Feature$2<Geometry extends Geometry$1 = Geometry$1> extends BaseObject {
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    constructor(geometryOrProperties?: Geometry | ObjectWithGeometry<Geometry>);
    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    on: FeatureOnSignature<EventsKey>;
    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    once: FeatureOnSignature<EventsKey>;
    /***
     * @type {FeatureOnSignature<void>}
     */
    un: FeatureOnSignature<void>;
    /**
     * @private
     * @type {number|string|undefined}
     */
    private id_;
    /**
     * @type {string}
     * @private
     */
    private geometryName_;
    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    private style_;
    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    private styleFunction_;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    private geometryChangeKey_;
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */
    clone(): Feature$2<Geometry>;
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
    getGeometry(): Geometry | undefined;
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId(): number | string | undefined;
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
    getGeometryName(): string;
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
    getStyle(): StyleLike | undefined;
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
    getStyleFunction(): StyleFunction | undefined;
    /**
     * @private
     */
    private handleGeometryChange_;
    /**
     * @private
     */
    private handleGeometryChanged_;
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
    setGeometry(geometry: Geometry | undefined): void;
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setStyle(style?: StyleLike): void;
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setId(id: number | string | undefined): void;
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
    setGeometryName(name: string): void;
}

/**
 * @classdesc
 * Events emitted on [GeolocationPositionError](https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError).
 */
declare class GeolocationError extends BaseEvent {
    /**
     * @param {GeolocationPositionError} error error object.
     */
    constructor(error: GeolocationPositionError);
    /**
     * Code of the underlying `GeolocationPositionError`.
     * @type {number}
     * @api
     */
    code: number;
    /**
     * Message of the underlying `GeolocationPositionError`.
     * @type {string}
     * @api
     */
    message: string;
}

type Options$1D = {
    /**
     * Start Tracking right after
     * instantiation.
     */
    tracking?: boolean | undefined;
    /**
     * Tracking options.
     * See https://www.w3.org/TR/geolocation-API/#position_options_interface.
     */
    trackingOptions?: PositionOptions | undefined;
    /**
     * The projection the position
     * is reported in.
     */
    projection?: ProjectionLike;
};
type GeolocationObjectEventTypes = Types$2 | "change:accuracy" | "change:accuracyGeometry" | "change:altitude" | "change:altitudeAccuracy" | "change:heading" | "change:position" | "change:projection" | "change:speed" | "change:tracking" | "change:trackingOptions";
/**
 * *
 */
type GeolocationOnSignature<Return> = OnSignature<GeolocationObjectEventTypes, ObjectEvent, Return> & OnSignature<"error", GeolocationError, Return> & CombinedOnSignature<EventTypes | GeolocationObjectEventTypes, Return> & OnSignature<EventTypes, BaseEvent, Return>;

/**
 * @typedef {Object} Options
 * @property {boolean} [tracking=false] Start Tracking right after
 * instantiation.
 * @property {PositionOptions} [trackingOptions] Tracking options.
 * See https://www.w3.org/TR/geolocation-API/#position_options_interface.
 * @property {import("./proj.js").ProjectionLike} [projection] The projection the position
 * is reported in.
 */
/**
 * @typedef {import("./ObjectEventType").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|
 *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|
 *    'change:trackingOptions'} GeolocationObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<GeolocationObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'error', GeolocationError, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|GeolocationObjectEventTypes, Return> &
 *   import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return>} GeolocationOnSignature
 */
/**
 * @classdesc
 * Helper class for providing HTML5 Geolocation capabilities.
 * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)
 * is used to locate a user's position.
 *
 * To get notified of position changes and errors, register listeners for the generic
 * `change` event and the `error` event on your instance of {@link module:ol/Geolocation~Geolocation}.
 *
 * Example:
 *
 *     const geolocation = new Geolocation({
 *       // take the projection to use from the map's view
 *       projection: view.getProjection()
 *     });
 *     // listen to changes in position
 *     geolocation.on('change', function(evt) {
 *       console.log(geolocation.getPosition());
 *     });
 *     // listen to error
 *     geolocation.on('error', function(evt) {
 *       window.console.log(evt.message);
 *     });
 *
 * @fires GeolocationError
 * @api
 */
declare class Geolocation extends BaseObject {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1D);
    /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */
    on: GeolocationOnSignature<EventsKey>;
    /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */
    once: GeolocationOnSignature<EventsKey>;
    /***
     * @type {GeolocationOnSignature<void>}
     */
    un: GeolocationOnSignature<void>;
    /**
     * The unprojected (EPSG:4326) device position.
     * @private
     * @type {?import("./coordinate.js").Coordinate}
     */
    private position_;
    /**
     * @private
     * @type {import("./proj.js").TransformFunction}
     */
    private transform_;
    /**
     * @private
     * @type {number|undefined}
     */
    private watchId_;
    /**
     * @private
     */
    private handleProjectionChanged_;
    /**
     * @private
     */
    private handleTrackingChanged_;
    /**
     * @private
     * @param {GeolocationPosition} position position event.
     */
    private positionChange_;
    /**
     * @private
     * @param {GeolocationPositionError} error error object.
     */
    private positionError_;
    /**
     * Get the accuracy of the position in meters.
     * @return {number|undefined} The accuracy of the position measurement in
     *     meters.
     * @observable
     * @api
     */
    getAccuracy(): number | undefined;
    /**
     * Get a geometry of the position accuracy.
     * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
     * @observable
     * @api
     */
    getAccuracyGeometry(): Polygon$1 | null;
    /**
     * Get the altitude associated with the position.
     * @return {number|undefined} The altitude of the position in meters above mean
     *     sea level.
     * @observable
     * @api
     */
    getAltitude(): number | undefined;
    /**
     * Get the altitude accuracy of the position.
     * @return {number|undefined} The accuracy of the altitude measurement in
     *     meters.
     * @observable
     * @api
     */
    getAltitudeAccuracy(): number | undefined;
    /**
     * Get the heading as radians clockwise from North.
     * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
     * is set to `true` in the tracking options.
     * @return {number|undefined} The heading of the device in radians from north.
     * @observable
     * @api
     */
    getHeading(): number | undefined;
    /**
     * Get the position of the device.
     * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
     *     in the current projection.
     * @observable
     * @api
     */
    getPosition(): Coordinate | undefined;
    /**
     * Get the projection associated with the position.
     * @return {import("./proj/Projection.js").default|undefined} The projection the position is
     *     reported in.
     * @observable
     * @api
     */
    getProjection(): Projection | undefined;
    /**
     * Get the speed in meters per second.
     * @return {number|undefined} The instantaneous speed of the device in meters
     *     per second.
     * @observable
     * @api
     */
    getSpeed(): number | undefined;
    /**
     * Determine if the device location is being tracked.
     * @return {boolean} The device location is being tracked.
     * @observable
     * @api
     */
    getTracking(): boolean;
    /**
     * Get the tracking options.
     * See https://www.w3.org/TR/geolocation-API/#position-options.
     * @return {PositionOptions|undefined} PositionOptions as defined by
     *     the [HTML5 Geolocation spec
     *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
     * @observable
     * @api
     */
    getTrackingOptions(): PositionOptions | undefined;
    /**
     * Set the projection to use for transforming the coordinates.
     * @param {import("./proj.js").ProjectionLike} projection The projection the position is
     *     reported in.
     * @observable
     * @api
     */
    setProjection(projection: ProjectionLike): void;
    /**
     * Enable or disable tracking.
     * @param {boolean} tracking Enable tracking.
     * @observable
     * @api
     */
    setTracking(tracking: boolean): void;
    /**
     * Set the tracking options.
     * See http://www.w3.org/TR/geolocation-API/#position-options.
     * @param {PositionOptions} options PositionOptions as defined by the
     *     [HTML5 Geolocation spec
     *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
     * @observable
     * @api
     */
    setTrackingOptions(options: PositionOptions): void;
}

/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 */
type Loader$2 = (arg0: (arg0: Error | undefined) => void) => void;
/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */
declare class ImageCanvas extends ImageWrapper {
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {HTMLCanvasElement} canvas Canvas.
     * @param {Loader} [loader] Optional loader function to
     *     support asynchronous canvas drawing.
     */
    constructor(extent: Extent$1, resolution: number, pixelRatio: number, canvas: HTMLCanvasElement, loader?: Loader$2);
    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */
    private loader_;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    private canvas_;
    /**
     * @private
     * @type {?Error}
     */
    private error_;
    /**
     * Get any error associated with asynchronous rendering.
     * @return {?Error} Any error that occurred during rendering.
     */
    getError(): Error | null;
    /**
     * Handle async drawing complete.
     * @param {Error} [err] Any error during drawing.
     * @private
     */
    private handleLoad_;
    /**
     * @return {HTMLCanvasElement} Canvas element.
     * @override
     */
    override getImage(): HTMLCanvasElement;
}

declare class ImageTile extends Tile$1 {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    constructor(tileCoord: TileCoord, state: any, src: string, crossOrigin: string | null, tileLoadFunction: LoadFunction$1, options?: Options$1Q);
    /**
     * @private
     * @type {?string}
     */
    private crossOrigin_;
    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    private src_;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    private image_;
    /**
     * @private
     * @type {?function():void}
     */
    private unlisten_;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    private tileLoadFunction_;
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */
    getImage(): HTMLCanvasElement | HTMLImageElement | HTMLVideoElement;
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */
    setImage(element: HTMLCanvasElement | HTMLImageElement): void;
    /**
     * Tracks loading or read errors.
     *
     * @private
     */
    private handleImageError_;
    /**
     * Tracks successful image load.
     *
     * @private
     */
    private handleImageLoad_;
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    private unlistenImage_;
}
//# sourceMappingURL=ImageTile.d.ts.map

/**
 * @module ol/Kinetic
 */
/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
declare class Kinetic {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    constructor(decay: number, minVelocity: number, delay: number);
    /**
     * @private
     * @type {number}
     */
    private decay_;
    /**
     * @private
     * @type {number}
     */
    private minVelocity_;
    /**
     * @private
     * @type {number}
     */
    private delay_;
    /**
     * @private
     * @type {Array<number>}
     */
    private points_;
    /**
     * @private
     * @type {number}
     */
    private angle_;
    /**
     * @private
     * @type {number}
     */
    private initialVelocity_;
    /**
     * FIXME empty description for jsdoc
     */
    begin(): void;
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    update(x: number, y: number): void;
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    end(): boolean;
    /**
     * @return {number} Total distance travelled (pixels).
     */
    getDistance(): number;
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    getAngle(): number;
}
//# sourceMappingURL=Kinetic.d.ts.map

declare class MapBrowserEventHandler extends Target {
    /**
     * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    constructor(map: Map, moveTolerance?: number);
    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */
    private map_;
    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    private clickTimeoutId_;
    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */
    emulateClicks_: boolean;
    /**
     * @type {boolean}
     * @private
     */
    private dragging_;
    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */
    private dragListenerKeys_;
    /**
     * @type {number}
     * @private
     */
    private moveTolerance_;
    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */
    private down_;
    /**
     * @type {Array<PointerEvent>}
     * @private
     */
    private activePointers_;
    /**
     * @type {!Object<number, Event>}
     * @private
     */
    private trackedTouches_;
    /**
     * @private
     */
    private element_;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    private pointerdownListenerKey_;
    /**
     * @type {PointerEvent}
     * @private
     */
    private originalPointerMoveEvent_;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    private relayedListenerKey_;
    /**
     * @private
     */
    private boundHandleTouchMove_;
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    private emulateClick_;
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    private updateActivePointers_;
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    private handlePointerUp_;
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
    private isMouseActionButton_;
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    private handlePointerDown_;
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    private handlePointerMove_;
    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    private relayMoveEvent_;
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
    private handleTouchMove_;
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
    private isMoving_;
}
//# sourceMappingURL=MapBrowserEventHandler.d.ts.map

/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Entry|null} newer Newer.
 * @property {Entry|null} older Older.
 * @property {*} value_ Value.
 */
/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
declare class LRUCache<T> {
    /**
     * @param {number} [highWaterMark] High water mark.
     */
    constructor(highWaterMark?: number);
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    highWaterMark: number;
    /**
     * @private
     * @type {number}
     */
    private count_;
    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    private entries_;
    /**
     * @private
     * @type {?Entry}
     */
    private oldest_;
    /**
     * @private
     * @type {?Entry}
     */
    private newest_;
    deleteOldest(): void;
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache(): boolean;
    /**
     * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
     * the entry will be disposed.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */
    expireCache(keep?: {
        [x: string]: boolean;
    }): void;
    /**
     * FIXME empty description for jsdoc
     */
    clear(): void;
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */
    containsKey(key: string): boolean;
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */
    forEach(f: (arg0: T, arg1: string, arg2: LRUCache<T>) => unknown): void;
    /**
     * @param {string} key Key.
     * @param {*} [options] Options (reserved for subclasses).
     * @return {T} Value.
     */
    get(key: string, options?: any): T;
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */
    remove(key: string): T;
    /**
     * @return {number} Count.
     */
    getCount(): number;
    /**
     * @return {Array<string>} Keys.
     */
    getKeys(): Array<string>;
    /**
     * @return {Array<T>} Values.
     */
    getValues(): Array<T>;
    /**
     * @return {T} Last value.
     */
    peekLast(): T;
    /**
     * @return {string} Last key.
     */
    peekLastKey(): string;
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */
    peekFirstKey(): string;
    /**
     * Return an entry without updating least recently used time.
     * @param {string} key Key.
     * @return {T|undefined} Value.
     */
    peek(key: string): T | undefined;
    /**
     * @return {T} value Value.
     */
    pop(): T;
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    replace(key: string, value: T): void;
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    set(key: string, value: T): void;
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */
    setSize(size: number): void;
}

declare class TileCache extends LRUCache<any> {
    constructor(highWaterMark?: number);
    /**
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     * @override
     */
    override expireCache(usedTiles: {
        [x: string]: boolean;
    }): void;
    /**
     * Prune all tiles from the cache that don't have the same z as the newest tile.
     */
    pruneExceptNewestZ(): void;
}
//# sourceMappingURL=TileCache.d.ts.map

declare class ExecutorGroup {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [renderBuffer] Optional rendering buffer.
     * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
     */
    constructor(maxExtent: Extent$1, resolution: number, pixelRatio: number, overlaps: boolean, allInstructions: {
        [x: string]: any;
    }, renderBuffer?: number, deferredRendering?: boolean);
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    private maxExtent_;
    /**
     * @private
     * @type {boolean}
     */
    private overlaps_;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @private
     * @type {number}
     */
    private resolution_;
    /**
     * @private
     * @type {number|undefined}
     */
    private renderBuffer_;
    /**
     * @private
     * @type {!Object<string, !Object<string, import("./Executor").default>>}
     */
    private executorsByZIndex_;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    private hitDetectionContext_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private hitDetectionTransform_;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    private renderedContext_;
    /**
     * @private
     * @type {Object<number, Array<import("./ZIndexContext.js").default>>}
     */
    private deferredZIndexContexts_;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    clip(context: CanvasRenderingContext2D, transform: Transform): void;
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     * @param {boolean} deferredRendering Enable deferred rendering.
     */
    private createExecutors_;
    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
    hasExecutors(executors: Array<BuilderType>): boolean;
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate<T>(coordinate: Coordinate, resolution: number, rotation: number, hitTolerance: number, callback: (arg0: FeatureLike, arg1: SimpleGeometry, arg2: number) => T, declutteredFeatures: Array<FeatureLike>): T | undefined;
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */
    getClipCoords(transform: Transform): Array<number> | null;
    /**
     * @return {boolean} Is empty.
     */
    isEmpty(): boolean;
    /**
     * @param {CanvasRenderingContext2D} targetContext Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ALL}
     * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
     *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
     */
    execute(targetContext: CanvasRenderingContext2D, scaledCanvasSize: Size, transform: Transform, viewRotation: number, snapToPixel: boolean, builderTypes?: Array<BuilderType>, declutterTree?: RBush$1<DeclutterEntry> | null): void;
    getDeferredZIndexContexts(): {
        [x: number]: ZIndexContext[];
    };
    getRenderedContext(): CanvasRenderingContext2D;
    renderDeferred(): void;
}

type ReadOptions = {
    /**
     * Projection of the data we are reading.
     * If not provided, the projection will be derived from the data (where possible) or
     * the `dataProjection` of the format is assigned (where set). If the projection
     * can not be derived from the data and if no `dataProjection` is set for a format,
     * the features will not be reprojected.
     */
    dataProjection?: ProjectionLike;
    /**
     * Tile extent in map units of the tile being read.
     * This is only required when reading data with tile pixels as geometry units. When configured,
     * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
     * provided.
     */
    extent?: Extent$1 | undefined;
    /**
     * Projection of the feature geometries
     * created by the format reader. If not provided, features will be returned in the
     * `dataProjection`.
     */
    featureProjection?: ProjectionLike;
};
type WriteOptions = {
    /**
     * Projection of the data we are writing.
     * If not provided, the `dataProjection` of the format is assigned (where set).
     * If no `dataProjection` is set for a format, the features will be returned
     * in the `featureProjection`.
     */
    dataProjection?: ProjectionLike;
    /**
     * Projection of the feature geometries
     * that will be serialized by the format writer. If not provided, geometries are assumed
     * to be in the `dataProjection` if that is set; in other words, they are not transformed.
     */
    featureProjection?: ProjectionLike;
    /**
     * When writing geometries, follow the right-hand
     * rule for linear ring orientation.  This means that polygons will have counter-clockwise
     * exterior rings and clockwise interior rings.  By default, coordinates are serialized
     * as they are provided at construction.  If `true`, the right-hand rule will
     * be applied.  If `false`, the left-hand rule will be applied (clockwise for
     * exterior and counter-clockwise for interior rings).  Note that not all
     * formats support this.  The GeoJSON format does use this property when writing
     * geometries.
     */
    rightHanded?: boolean | undefined;
    /**
     * Maximum number of decimal places for coordinates.
     * Coordinates are stored internally as floats, but floating-point arithmetic can create
     * coordinates with a large number of decimal places, not generally wanted on output.
     * Set a number here to round coordinates. Can also be used to ensure that
     * coordinates read in can be written back out with the same number of decimals.
     * Default is no rounding.
     */
    decimals?: number | undefined;
};
type Type = "arraybuffer" | "json" | "text" | "xml";
/**
 * *
 */
type FeatureToFeatureClass<T extends FeatureLike> = T extends RenderFeature ? typeof RenderFeature : typeof Feature$2;
/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */
/**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */
/**
 * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
 */
/**
 * @typedef {Object} SimpleGeometryObject
 * @property {import('../geom/Geometry.js').Type} type Type.
 * @property {Array<number>} flatCoordinates Flat coordinates.
 * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.
 * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.
 */
/**
 * @typedef {Array<GeometryObject>} GeometryCollectionObject
 */
/**
 * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject
 */
/**
 * @typedef {Object} FeatureObject
 * @property {string|number} [id] Id.
 * @property {GeometryObject} [geometry] Geometry.
 * @property {Object<string, *>} [properties] Properties.
 */
/***
 * @template {import('../Feature.js').FeatureLike} T
 * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass
 */
/***
 * @template {import("../Feature.js").FeatureClass} T
 * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("../Feature.js").default]
 * @abstract
 * @api
 */
declare class FeatureFormat<FeatureType extends FeatureLike = Feature$2<Geometry$1>> {
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */
    protected dataProjection: Projection | undefined;
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */
    protected defaultFeatureProjection: Projection | undefined;
    /**
     * @protected
     * @type {FeatureToFeatureClass<FeatureType>}
     */
    protected featureClass: FeatureToFeatureClass<FeatureType>;
    /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */
    supportedMediaTypes: Array<string>;
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */
    protected getReadOptions(source: Document | Element | any | string, options?: ReadOptions): ReadOptions | undefined;
    /**
     * Sets the `dataProjection` on the options, if no `dataProjection`
     * is set.
     * @param {WriteOptions|ReadOptions|undefined} options
     *     Options.
     * @protected
     * @return {WriteOptions|ReadOptions|undefined}
     *     Updated options.
     */
    protected adaptOptions(options: WriteOptions | ReadOptions | undefined): WriteOptions | ReadOptions | undefined;
    /**
     * @abstract
     * @return {Type} The format type.
     */
    getType(): Type;
    /**
     * Read a single feature from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {FeatureType|Array<FeatureType>} Feature.
     */
    readFeature(source: Document | Element | any | string, options?: ReadOptions): FeatureType | Array<FeatureType>;
    /**
     * Read all features from a source.
     *
     * @abstract
     * @param {Document|Element|ArrayBuffer|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     */
    readFeatures(source: Document | Element | ArrayBuffer | any | string, options?: ReadOptions): Array<FeatureType>;
    /**
     * Read a single geometry from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometry(source: Document | Element | any | string, options?: ReadOptions): Geometry$1;
    /**
     * Read the projection from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    readProjection(source: Document | Element | any | string): Projection | undefined;
    /**
     * Encode a feature in this format.
     *
     * @abstract
     * @param {Feature} feature Feature.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeature(feature: Feature$2, options?: WriteOptions): string | ArrayBuffer;
    /**
     * Encode an array of features in this format.
     *
     * @abstract
     * @param {Array<Feature>} features Features.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeatures(features: Array<Feature$2>, options?: WriteOptions): string | ArrayBuffer;
    /**
     * Write a single geometry in this format.
     *
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeGeometry(geometry: Geometry$1, options?: WriteOptions): string | ArrayBuffer;
}

type VectorSourceEventTypes = "addfeature" | "changefeature" | "clear" | "removefeature" | "featuresloadstart" | "featuresloadend" | "featuresloaderror";

/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 */
declare class VectorSourceEvent<FeatureType extends FeatureLike = Feature$2<Geometry$1>> extends BaseEvent {
    /**
     * @param {string} type Type.
     * @param {FeatureType} [feature] Feature.
     * @param {Array<FeatureType>} [features] Features.
     */
    constructor(type: string, feature?: FeatureType, features?: Array<FeatureType>);
    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {FeatureType|undefined}
     * @api
     */
    feature: FeatureType | undefined;
    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<FeatureType>|undefined}
     * @api
     */
    features: Array<FeatureType> | undefined;
}

/**
 * A function that takes an {@link module :ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module :ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module :ol/loadingstrategy} strategies.
 */
type LoadingStrategy = (arg0: Extent$1, arg1: number, arg2: Projection) => Array<Extent$1>;
/**
 * *
 */
type FeatureClassOrArrayOfRenderFeatures<T extends FeatureLike = Feature$2<Geometry$1>> = T extends RenderFeature ? T | Array<T> : T;
/**
 * *
 */
type VectorSourceOnSignature<Return, FeatureType extends FeatureLike = Feature$2<Geometry$1>> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2, ObjectEvent, Return> & OnSignature<VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> & CombinedOnSignature<EventTypes | Types$2 | VectorSourceEventTypes, Return>;
type Options$1C<FeatureType extends FeatureLike = Feature$2<Geometry$1>> = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Features. If provided as {@link module :ol/Collection~Collection}, the features in the source
     * and the collection will stay in sync.
     */
    features?: FeatureType[] | Collection<FeatureType> | undefined;
    /**
     * The feature format used by the XHR
     * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
     */
    format?: FeatureFormat<FeatureType> | undefined;
    /**
     * The loader function used to load features, from a remote source for example.
     * If this is not set and `url` is set, the source will create and use an XHR
     * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
     * will only fire if the `success` and `failure` callbacks are used.
     *
     * Example:
     *
     * ```js
     * import Vector from 'ol/source/Vector.js';
     * import GeoJSON from 'ol/format/GeoJSON.js';
     * import {bbox} from 'ol/loadingstrategy.js';
     *
     * const vectorSource = new Vector({
     * format: new GeoJSON(),
     * loader: function(extent, resolution, projection, success, failure) {
     * const proj = projection.getCode();
     * const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
     * 'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
     * 'outputFormat=application/json&srsname=' + proj + '&' +
     * 'bbox=' + extent.join(',') + ',' + proj;
     * const xhr = new XMLHttpRequest();
     * xhr.open('GET', url);
     * const onError = function() {
     * vectorSource.removeLoadedExtent(extent);
     * failure();
     * }
     * xhr.onerror = onError;
     * xhr.onload = function() {
     * if (xhr.status == 200) {
     * const features = vectorSource.getFormat().readFeatures(xhr.responseText);
     * vectorSource.addFeatures(features);
     * success(features);
     * } else {
     * onError();
     * }
     * }
     * xhr.send();
     * },
     * strategy: bbox,
     * });
     * ```
     */
    loader?: FeatureLoader<FeatureType> | undefined;
    /**
     * This source may have overlapping geometries.
     * Setting this to `false` (e.g. for sources with polygons that represent administrative
     * boundaries or TopoJSON sources) allows the renderer to optimise fill and
     * stroke operations.
     */
    overlaps?: boolean | undefined;
    /**
     * The loading strategy to use.
     * By default an {@link module :ol/loadingstrategy.all}strategy is used, a one-off strategy which loads all features at once.
     */
    strategy?: LoadingStrategy | undefined;
    /**
     * Setting this option instructs the source to load features using an XHR loader
     * (see {@link module :ol/featureloader.xhr}). Use a `string` and an
     * {@link module :ol/loadingstrategy.all} for a one-off download of all features from
     * the given URL. Use a {@link module :ol/featureloader~FeatureUrlFunction} to generate the url with
     * other loading strategies.
     * Requires `format` to be set as well.
     * When default XHR feature loader is provided, the features will
     * be transformed from the data projection to the view projection
     * during parsing. If your remote data source does not advertise its projection
     * properly, this transformation will be incorrect. For some formats, the
     * default projection (usually EPSG:4326) can be overridden by setting the
     * dataProjection constructor option on the format.
     * Note that if a source contains non-feature data, such as a GeoJSON geometry
     * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
     */
    url?: string | FeatureUrlFunction | undefined;
    /**
     * By default, an RTree is used as spatial index. When features are removed and
     * added frequently, and the total number of features is low, setting this to
     * `false` may improve performance.
     *
     * Note that
     * {@link module :ol/source/Vector~VectorSource#getFeaturesInExtent},
     * {@link module :ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
     * {@link module :ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
     * set to `false`, and {@link module :ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
     * through all features.
     *
     * When set to `false`, the features will be maintained in an
     * {@link module :ol/Collection~Collection}, which can be retrieved through
     * {@link module :ol/source/Vector~VectorSource#getFeaturesCollection}.
     */
    useSpatialIndex?: boolean | undefined;
    /**
     * Wrap the world horizontally. For vector editing across the
     * -180° and 180° meridians to work properly, this should be set to `false`. The
     * resulting geometry coordinates will then exceed the world bounds.
     */
    wrapX?: boolean | undefined;
};

/***
 * @template {import("../Feature.js").FeatureLike} [T=import("../Feature.js").default]
 * @typedef {T extends RenderFeature ? T|Array<T> : T} FeatureClassOrArrayOfRenderFeatures
 */
/***
 * @template Return
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */
/**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<FeatureType>|Collection<FeatureType>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default<FeatureType>} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader<FeatureType>} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */
/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 */
declare class VectorSource<FeatureType extends FeatureLike = Feature$2<Geometry$1>> extends Source {
    /**
     * @param {Options<FeatureType>} [options] Vector source options.
     */
    constructor(options?: Options$1C<FeatureType>);
    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey, FeatureType>}
     */
    on: VectorSourceOnSignature<EventsKey, FeatureType>;
    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey, FeatureType>}
     */
    once: VectorSourceOnSignature<EventsKey, FeatureType>;
    /***
     * @type {VectorSourceOnSignature<void>}
     */
    un: VectorSourceOnSignature<void>;
    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader<FeatureType>}
     */
    private loader_;
    /**
     * @private
     * @type {import("../format/Feature.js").default<FeatureType>|null}
     */
    private format_;
    /**
     * @private
     * @type {boolean}
     */
    private overlaps_;
    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    private url_;
    /**
     * @private
     * @type {LoadingStrategy}
     */
    private strategy_;
    /**
     * @private
     * @type {RBush<FeatureType>}
     */
    private featuresRtree_;
    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    private loadedExtentsRtree_;
    /**
     * @type {number}
     * @private
     */
    private loadingExtentsCount_;
    /**
     * @private
     * @type {!Object<string, FeatureType>}
     */
    private nullGeometryFeatures_;
    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import('../Feature.js').FeatureLike|Array<import('../Feature.js').FeatureLike>>}
     */
    private idIndex_;
    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, FeatureType>}
     */
    private uidIndex_;
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    private featureChangeKeys_;
    /**
     * @private
     * @type {Collection<FeatureType>|null}
     */
    private featuresCollection_;
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {FeatureType} feature Feature to add.
     * @api
     */
    addFeature(feature: FeatureType): void;
    /**
     * Add a feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @protected
     */
    protected addFeatureInternal(feature: FeatureType): void;
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @private
     */
    private setupChangeEvents_;
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    private addToIndex_;
    /**
     * Add a batch of features to the source.
     * @param {Array<FeatureType>} features Features to add.
     * @api
     */
    addFeatures(features: Array<FeatureType>): void;
    /**
     * Add features without firing a `change` event.
     * @param {Array<FeatureType>} features Features.
     * @protected
     */
    protected addFeaturesInternal(features: Array<FeatureType>): void;
    /**
     * @param {!Collection<FeatureType>} collection Collection.
     * @private
     */
    private bindFeaturesCollection_;
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */
    clear(fast?: boolean): void;
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(FeatureType): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeature<T>(callback: (arg0: FeatureType) => T): T | undefined;
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
     * called for all features.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    forEachFeatureAtCoordinateDirect<T>(coordinate: Coordinate, callback: (arg0: FeatureType) => T): T | undefined;
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureInExtent<T>(extent: Extent$1, callback: (arg0: FeatureType) => T): T | undefined;
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureIntersectingExtent<T>(extent: Extent$1, callback: (arg0: FeatureType) => T): T | undefined;
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with a {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<FeatureType>|null} The collection of features.
     * @api
     */
    getFeaturesCollection(): Collection<FeatureType> | null;
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeatures(): Array<FeatureType>;
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesAtCoordinate(coordinate: Coordinate): Array<FeatureType>;
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesInExtent(extent: Extent$1, projection?: Projection): Array<FeatureType>;
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false` and the features in this source are of type
     * {@link module:ol/Feature~Feature}.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {FeatureType} Closest feature.
     * @api
     */
    getClosestFeatureToCoordinate(coordinate: Coordinate, filter?: (arg0: FeatureType) => boolean): FeatureType;
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(extent?: Extent$1): Extent$1;
    /**
     * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
     * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
     * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
     * `GeometryCollection` member.
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
     * @api
     */
    getFeatureById(id: string | number): FeatureClassOrArrayOfRenderFeatures<FeatureType> | null;
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {FeatureType|null} The feature (or `null` if not found).
     */
    getFeatureByUid(uid: string): FeatureType | null;
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
     * @api
     */
    getFormat(): FeatureFormat<FeatureType> | null;
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps(): boolean;
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
    getUrl(): string | FeatureUrlFunction | undefined;
    /**
     * @param {Event} event Event.
     * @private
     */
    private handleFeatureChange_;
    /**
     * Returns true if the feature is contained within the source.
     * @param {FeatureType} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    hasFeature(feature: FeatureType): boolean;
    /**
     * @return {boolean} Is empty.
     */
    isEmpty(): boolean;
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    loadFeatures(extent: Extent$1, resolution: number, projection: Projection): void;
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    removeLoadedExtent(extent: Extent$1): void;
    /**
     * Batch remove features from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {Array<FeatureType>} features Features to remove.
     * @api
     */
    removeFeatures(features: Array<FeatureType>): void;
    /**
     * Remove a single feature from the source. If you want to batch remove
     * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
     * instead.
     * @param {FeatureType} feature Feature to remove.
     * @api
     */
    removeFeature(feature: FeatureType): void;
    /**
     * Remove feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @return {boolean} True if the feature was removed, false if it was not found.
     * @protected
     */
    protected removeFeatureInternal(feature: FeatureType): boolean;
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {FeatureType} feature The feature.
     * @private
     */
    private removeFromIdIndex_;
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
     * @api
     */
    setLoader(loader: FeatureLoader<FeatureType>): void;
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
    setUrl(url: string | FeatureUrlFunction): void;
    /**
     * @param {boolean} overlaps The source can have overlapping geometries.
     */
    setOverlaps(overlaps: boolean): void;
}

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), a
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 *
 * @template {import("./Feature.js").FeatureLike} [FeatureType=import("./Feature.js").default]
 * @typedef {function(this:(import("./source/Vector").default<FeatureType>|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<FeatureType>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */
/**
 * @template {import("./Feature.js").FeatureLike} [FeatureType=import("./Feature.js").default]
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<FeatureType>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */
declare function loadFeaturesXhr<FeatureType extends FeatureLike = Feature$2<Geometry$1>>(url: string | FeatureUrlFunction, format: FeatureFormat<FeatureType>, extent: Extent$1, resolution: number, projection: Projection, success: (arg0: Array<FeatureType>, arg1: Projection) => void, failure: () => void): void;
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @template {import("./Feature.js").FeatureLike} FeatureType
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
 * @return {FeatureLoader<FeatureType>} The feature loader.
 * @api
 */
declare function xhr<FeatureType extends FeatureLike>(url: string | FeatureUrlFunction, format: FeatureFormat<FeatureType>): FeatureLoader<FeatureType>;
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */
declare function setWithCredentials(xhrWithCredentials: boolean): void;
/**
 * {@link module :ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module :ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), a
 * {@link module :ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module :ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 */
type FeatureLoader<FeatureType extends FeatureLike = Feature$2<Geometry$1>> = (this: (VectorSource<FeatureType> | VectorTile$1<any>), arg1: Extent$1, arg2: number, arg3: Projection, arg4: ((arg0: Array<FeatureType>) => void) | undefined, arg5: (() => void) | undefined) => void;
/**
 * {@link module :ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module :ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module :ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 */
type FeatureUrlFunction = (arg0: Extent$1, arg1: number, arg2: Projection) => string;

/**
 * @template {import('./Feature.js').FeatureLike} FeatureType
 */
declare class VectorTile$1<FeatureType extends FeatureLike> extends Tile$1 {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Data source url.
     * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    constructor(tileCoord: TileCoord, state: any, src: string, format: FeatureFormat<FeatureType>, tileLoadFunction: LoadFunction$1, options?: Options$1Q);
    /**
     * Extent of this tile; set by the source.
     * @type {import("./extent.js").Extent}
     */
    extent: Extent$1;
    /**
     * @private
     * @type {import("./format/Feature.js").default<FeatureType>}
     */
    private format_;
    /**
     * @private
     * @type {Array<FeatureType>}
     */
    private features_;
    /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader<FeatureType>}
     */
    private loader_;
    /**
     * Feature projection of this tile; set by the source.
     * @type {import("./proj/Projection.js").default}
     */
    projection: Projection;
    /**
     * Resolution of this tile; set by the source.
     * @type {number}
     */
    resolution: number;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    private tileLoadFunction_;
    /**
     * @private
     * @type {string}
     */
    private url_;
    /**
     * @return {string} Tile url.
     */
    getTileUrl(): string;
    /**
     * Get the feature format assigned for reading this tile's features.
     * @return {import("./format/Feature.js").default<FeatureType>} Feature format.
     * @api
     */
    getFormat(): FeatureFormat<FeatureType>;
    /**
     * Get the features for this tile. Geometries will be in the view projection.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeatures(): Array<FeatureType>;
    /**
     * Handler for successful tile load.
     * @param {Array<FeatureType>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data projection.
     */
    onLoad(features: Array<FeatureType>, dataProjection: Projection): void;
    /**
     * Handler for tile load errors.
     */
    onError(): void;
    /**
     * Function for use in a {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
     * Sets the features for the tile.
     * @param {Array<FeatureType>} features Features.
     * @api
     */
    setFeatures(features: Array<FeatureType>): void;
    /**
     * Set the feature loader for reading this tile's features.
     * @param {import("./featureloader.js").FeatureLoader<FeatureType>} loader Feature loader.
     * @api
     */
    setLoader(loader: FeatureLoader<FeatureType>): void;
}
//# sourceMappingURL=VectorTile.d.ts.map

type ReplayState = {
    /**
     * Dirty.
     */
    dirty: boolean;
    /**
     * RenderedRenderOrder.
     */
    renderedRenderOrder: null | OrderFunction;
    /**
     * RenderedTileRevision.
     */
    renderedTileRevision: number;
    /**
     * RenderedResolution.
     */
    renderedResolution: number;
    /**
     * RenderedRevision.
     */
    renderedRevision: number;
    /**
     * RenderedTileResolution.
     */
    renderedTileResolution: number;
    /**
     * RenderedTileZ.
     */
    renderedTileZ: number;
};
declare class VectorRenderTile extends Tile$1 {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
     * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function.
     * @param {function(VectorRenderTile):void} removeSourceTiles Function.
     */
    constructor(tileCoord: TileCoord, state: any, urlTileCoord: TileCoord, getSourceTiles: (arg0: VectorRenderTile) => Array<VectorTile$1<any>>, removeSourceTiles: (arg0: VectorRenderTile) => void);
    /**
     * @private
     * @type {CanvasRenderingContext2D|null}
     */
    private context_;
    /**
     * Executor groups. Read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */
    executorGroups: {
        [x: string]: ExecutorGroup[];
    };
    /**
     * Number of loading source tiles. Read/written by the source.
     * @type {number}
     */
    loadingSourceTiles: number;
    /**
     * @type {Object<string, ImageData>}
     */
    hitDetectionImageData: {
        [x: string]: ImageData;
    };
    /**
     * @private
     * @type {!Object<string, ReplayState>}
     */
    private replayState_;
    /**
     * @type {Array<import("./VectorTile.js").default>}
     */
    sourceTiles: Array<VectorTile$1<any>>;
    /**
     * @type {Object<string, boolean>}
     */
    errorTileKeys: {
        [x: string]: boolean;
    };
    /**
     * @type {number}
     */
    wantedResolution: number;
    /**
     * @type {!function():Array<import("./VectorTile.js").default>}
     */
    getSourceTiles: () => Array<VectorTile$1<any>>;
    /**
     * @type {!function(VectorRenderTile):void}
     * @private
     */
    private removeSourceTiles_;
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    wrappedTileCoord: TileCoord;
    /**
     * @return {CanvasRenderingContext2D} The rendering context.
     */
    getContext(): CanvasRenderingContext2D;
    /**
     * @return {boolean} Tile has a rendering context.
     */
    hasContext(): boolean;
    /**
     * Get the Canvas for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    getImage(): HTMLCanvasElement;
    /**
     * @param {import("./layer/Layer.js").default} layer Layer.
     * @return {ReplayState} The replay state.
     */
    getReplayState(layer: Layer): ReplayState;
}

/**
 * @module ol/asserts
 */
/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */
declare function assert(assertion: any, errorMessage: string): void;

/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */
declare function setLevel(l: Level): void;
/**
 * @param  {...any} args Arguments to log
 */
declare function log(...args: any[]): void;
/**
 * @param  {...any} args Arguments to log
 */
declare function warn(...args: any[]): void;
/**
 * @param  {...any} args Arguments to log
 */
declare function error(...args: any[]): void;
type Level = "info" | "warn" | "error" | "none";

type Options$1B = {
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * Specify a target if you
     * want the control to be rendered outside of the map's
     * viewport.
     */
    target?: string | HTMLElement | undefined;
    /**
     * Specify if attributions can
     * be collapsed. If not specified, sources control this behavior with their
     * `attributionsCollapsible` setting.
     */
    collapsible?: boolean | undefined;
    /**
     * Specify if attributions should
     * be collapsed at startup.
     */
    collapsed?: boolean | undefined;
    /**
     * Text label to use for the button tip.
     */
    tipLabel?: string | undefined;
    /**
     * Text label to use for the
     * collapsed attributions button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    label?: string | HTMLElement | undefined;
    /**
     * CSS class name for the
     * collapsed attributions button.
     */
    expandClassName?: string | undefined;
    /**
     * Text label to use
     * for the expanded attributions button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    collapseLabel?: string | HTMLElement | undefined;
    /**
     * CSS class name for the
     * expanded attributions button.
     */
    collapseClassName?: string | undefined;
    /**
     * Function called when
     * the control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Optional attribution(s) that will always be
     * displayed regardless of the layers rendered
     */
    attributions?: string | Array<string> | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {string|Array<string>|undefined} [attributions] Optional attribution(s) that will always be
 * displayed regardless of the layers rendered
 */
/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
declare class Attribution extends Control {
    /**
     * @param {Options} [options] Attribution options.
     */
    constructor(options?: Options$1B);
    /**
     * @private
     * @type {HTMLElement}
     */
    private ulElement_;
    /**
     * @private
     * @type {boolean}
     */
    private collapsed_;
    /**
     * @private
     * @type {boolean}
     */
    private userCollapsed_;
    /**
     * @private
     * @type {boolean}
     */
    private overrideCollapsible_;
    /**
     * @private
     * @type {boolean}
     */
    private collapsible_;
    /**
     * @private
     * @type {string | Array<string> | undefined}
     */
    private attributions_;
    /**
     * @private
     * @type {HTMLElement}
     */
    private collapseLabel_;
    /**
     * @private
     * @type {HTMLElement}
     */
    private label_;
    /**
     * @private
     * @type {HTMLElement}
     */
    private toggleButton_;
    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */
    private renderedAttributions_;
    /**
     * @private
     * @type {boolean}
     */
    private renderedVisible_;
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */
    private collectSourceAttributions_;
    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    private updateElement_;
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    private handleClick_;
    /**
     * @private
     */
    private handleToggle_;
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    getCollapsible(): boolean;
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    setCollapsible(collapsible: boolean): void;
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    setCollapsed(collapsed: boolean): void;
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
    getCollapsed(): boolean;
}

/**
 * *
 */
type FullScreenOnSignature<Return> = OnSignature<EventTypes | "enterfullscreen" | "leavefullscreen", BaseEvent, Return> & OnSignature<Types$2, ObjectEvent, Return> & CombinedOnSignature<EventTypes | "enterfullscreen" | "leavefullscreen" | Types$2, Return>;
type Options$1A = {
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * Text label to use for the button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    label?: string | HTMLElement | Text | undefined;
    /**
     * Text label to use for the
     * button when full-screen is active.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    labelActive?: string | HTMLElement | Text | undefined;
    /**
     * CSS class name for the button
     * when full-screen is active.
     */
    activeClassName?: string | undefined;
    /**
     * CSS class name for the button
     * when full-screen is inactive.
     */
    inactiveClassName?: string | undefined;
    /**
     * Text label to use for the button tip.
     */
    tipLabel?: string | undefined;
    /**
     * Full keyboard access.
     */
    keys?: boolean | undefined;
    /**
     * Specify a target if you want the
     * control to be rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
    /**
     * The element to be displayed
     * fullscreen. When not provided, the element containing the map viewport will
     * be displayed fullscreen.
     */
    source?: string | HTMLElement | undefined;
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen', import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen'|import("../ObjectEventType").Types, Return>} FullScreenOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-full-screen'] CSS class name.
 * @property {string|Text|HTMLElement} [label='\u2922'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|Text|HTMLElement} [labelActive='\u00d7'] Text label to use for the
 * button when full-screen is active.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [activeClassName=className + '-true'] CSS class name for the button
 * when full-screen is active.
 * @property {string} [inactiveClassName=className + '-false'] CSS class name for the button
 * when full-screen is inactive.
 * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
 * @property {boolean} [keys=false] Full keyboard access.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {HTMLElement|string} [source] The element to be displayed
 * fullscreen. When not provided, the element containing the map viewport will
 * be displayed fullscreen.
 */
/**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](https://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 * @fires FullScreenEventType#enterfullscreen
 * @fires FullScreenEventType#leavefullscreen
 * @api
 */
declare class FullScreen extends Control {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1A);
    /***
     * @type {FullScreenOnSignature<import("../events").EventsKey>}
     */
    on: FullScreenOnSignature<EventsKey>;
    /***
     * @type {FullScreenOnSignature<import("../events").EventsKey>}
     */
    once: FullScreenOnSignature<EventsKey>;
    /***
     * @type {FullScreenOnSignature<void>}
     */
    un: FullScreenOnSignature<void>;
    /**
     * @private
     * @type {boolean}
     */
    private keys_;
    /**
     * @private
     * @type {HTMLElement|string|undefined}
     */
    private source_;
    /**
     * @type {boolean}
     * @private
     */
    private isInFullscreen_;
    /**
     * @private
     */
    private boundHandleMapTargetChange_;
    /**
     * @private
     * @type {string}
     */
    private cssClassName_;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    private documentListeners_;
    /**
     * @private
     * @type {Array<string>}
     */
    private activeClassName_;
    /**
     * @private
     * @type {Array<string>}
     */
    private inactiveClassName_;
    /**
     * @private
     * @type {Text|HTMLElement}
     */
    private labelNode_;
    /**
     * @private
     * @type {Text|HTMLElement}
     */
    private labelActiveNode_;
    /**
     * @private
     * @type {HTMLElement}
     */
    private button_;
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    private handleClick_;
    /**
     * @private
     */
    private handleFullScreen_;
    /**
     * @private
     */
    private handleFullScreenChange_;
    /**
     * @param {HTMLElement} element Target element
     * @param {boolean} fullscreen True if fullscreen class name should be active
     * @private
     */
    private setClassName_;
    /**
     * @private
     */
    private handleMapTargetChange_;
}

/**
 * *
 */
type MousePositionOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:coordinateFormat" | "change:projection", ObjectEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:coordinateFormat" | "change:projection", Return>;
type Options$1z = {
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * Coordinate format.
     */
    coordinateFormat?: CoordinateFormat | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Function called when the
     * control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Specify a target if you want the
     * control to be rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
    /**
     * Markup to show when the mouse position is not
     * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space is rendered
     * initially and the last position is retained when the mouse leaves the viewport.
     * When a string is provided (e.g. `'no position'` or `''` for an empty string) it is used as a
     * placeholder.
     */
    placeholder?: string | undefined;
    /**
     * Wrap the world horizontally on the projection's antimeridian, if it
     * is a global projection.
     */
    wrapX?: boolean | undefined;
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:coordinateFormat'|'change:projection', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:coordinateFormat'|'change:projection', Return>} MousePositionOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-mouse-position'] CSS class name.
 * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
 * control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {string} [placeholder] Markup to show when the mouse position is not
 * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space is rendered
 * initially and the last position is retained when the mouse leaves the viewport.
 * When a string is provided (e.g. `'no position'` or `''` for an empty string) it is used as a
 * placeholder.
 * @property {boolean} [wrapX=true] Wrap the world horizontally on the projection's antimeridian, if it
 * is a global projection.
 */
/**
 * @classdesc
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 *
 * On touch devices, which usually do not have a mouse cursor, the coordinates
 * of the currently touched position are shown.
 *
 * @api
 */
declare class MousePosition extends Control {
    /**
     * @param {Options} [options] Mouse position options.
     */
    constructor(options?: Options$1z);
    /***
     * @type {MousePositionOnSignature<import("../events").EventsKey>}
     */
    on: MousePositionOnSignature<EventsKey>;
    /***
     * @type {MousePositionOnSignature<import("../events").EventsKey>}
     */
    once: MousePositionOnSignature<EventsKey>;
    /***
     * @type {MousePositionOnSignature<void>}
     */
    un: MousePositionOnSignature<void>;
    /**
     * @private
     * @type {boolean}
     */
    private renderOnMouseOut_;
    /**
     * @private
     * @type {string}
     */
    private placeholder_;
    /**
     * @private
     * @type {string}
     */
    private renderedHTML_;
    /**
     * @private
     * @type {?import("../proj/Projection.js").default}
     */
    private mapProjection_;
    /**
     * @private
     * @type {?import("../proj.js").TransformFunction}
     */
    private transform_;
    /**
     * @private
     * @type {boolean}
     */
    private wrapX_;
    /**
     * @private
     */
    private handleProjectionChanged_;
    /**
     * Return the coordinate format type used to render the current position or
     * undefined.
     * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
     *     position in.
     * @observable
     * @api
     */
    getCoordinateFormat(): CoordinateFormat | undefined;
    /**
     * Return the projection that is used to report the mouse position.
     * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
     *     position in.
     * @observable
     * @api
     */
    getProjection(): Projection | undefined;
    /**
     * @param {MouseEvent} event Browser event.
     * @protected
     */
    protected handleMouseMove(event: MouseEvent): void;
    /**
     * @param {Event} event Browser event.
     * @protected
     */
    protected handleMouseOut(event: Event): void;
    /**
     * Set the coordinate format type used to render the current position.
     * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
     *     position in.
     * @observable
     * @api
     */
    setCoordinateFormat(format: CoordinateFormat): void;
    /**
     * Set the projection that is used to report the mouse position.
     * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
     *     position in.
     * @observable
     * @api
     */
    setProjection(projection: ProjectionLike): void;
    /**
     * @param {?import("../pixel.js").Pixel} pixel Pixel.
     * @private
     */
    private updateHTML_;
}

type Options$1y = {
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * Whether the control should start collapsed or not (expanded).
     */
    collapsed?: boolean | undefined;
    /**
     * Text label to use for the
     * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
     */
    collapseLabel?: string | HTMLElement | undefined;
    /**
     * Whether the control can be collapsed or not.
     */
    collapsible?: boolean | undefined;
    /**
     * Text label to use for the collapsed
     * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
     */
    label?: string | HTMLElement | undefined;
    /**
     * Layers for the overview map.
     */
    layers?: BaseLayer[] | Collection<BaseLayer> | undefined;
    /**
     * Function called when the control
     * should be re-rendered. This is called in a `requestAnimationFrame` callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Whether the control view should rotate with the main map view.
     */
    rotateWithView?: boolean | undefined;
    /**
     * Specify a target if you want the control
     * to be rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
    /**
     * Text label to use for the button tip.
     */
    tipLabel?: string | undefined;
    /**
     * Custom view for the overview map (should use same projection as main map). If not provided,
     * a default view with the same projection as the main map will be used.
     */
    view?: View | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-overviewmap'] CSS class name.
 * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
 * @property {string|HTMLElement} [collapseLabel='‹'] Text label to use for the
 * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
 * @property {string|HTMLElement} [label='›'] Text label to use for the collapsed
 * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {Array<import("../layer/Base.js").default>|import("../Collection.js").default<import("../layer/Base.js").default>} [layers]
 * Layers for the overview map.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
 * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
 * a default view with the same projection as the main map will be used.
 */
/**
 * Create a new control with a map acting as an overview map for another
 * defined map.
 *
 * @api
 */
declare class OverviewMap extends Control {
    /**
     * @param {Options} [options] OverviewMap options.
     */
    constructor(options?: Options$1y);
    /**
     * @private
     */
    private boundHandleRotationChanged_;
    /**
     * @type {boolean}
     * @private
     */
    private collapsed_;
    /**
     * @private
     * @type {boolean}
     */
    private collapsible_;
    /**
     * @private
     * @type {boolean}
     */
    private rotateWithView_;
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */
    private viewExtent_;
    /**
     * @private
     * @type {HTMLElement}
     */
    private collapseLabel_;
    /**
     * @private
     * @type {HTMLElement}
     */
    private label_;
    /**
     * @type {HTMLElement}
     * @private
     */
    private ovmapDiv_;
    /**
     * Explicitly given view to be used instead of a view derived from the main map.
     * @type {View}
     * @private
     */
    private view_;
    /**
     * @type {Map}
     * @private
     */
    private ovmap_;
    /**
     * @type {import("../Overlay.js").default}
     * @private
     */
    private boxOverlay_;
    /**
     * Handle map property changes.  This only deals with changes to the map's view.
     * @param {import("../Object.js").ObjectEvent} event The propertychange event.
     * @private
     */
    private handleMapPropertyChange_;
    /**
     * Register listeners for view property changes.
     * @param {import("../View.js").default} view The view.
     * @private
     */
    private bindView_;
    /**
     * Unregister listeners for view property changes.
     * @param {import("../View.js").default} view The view.
     * @private
     */
    private unbindView_;
    /**
     * Handle rotation changes to the main map.
     * @private
     */
    private handleRotationChanged_;
    /**
     * Reset the overview map extent if the box size (width or
     * height) is less than the size of the overview map size times minRatio
     * or is greater than the size of the overview size times maxRatio.
     *
     * If the map extent was not reset, the box size can fits in the defined
     * ratio sizes. This method then checks if is contained inside the overview
     * map current extent. If not, recenter the overview map to the current
     * main map center location.
     * @private
     */
    private validateExtent_;
    /**
     * Reset the overview map extent to half calculated min and max ratio times
     * the extent of the main map.
     * @private
     */
    private resetExtent_;
    /**
     * Set the center of the overview map to the map center without changing its
     * resolution.
     * @private
     */
    private recenter_;
    /**
     * Update the box using the main map extent
     * @private
     */
    private updateBox_;
    /**
     * @private
     */
    private updateBoxAfterOvmapIsRendered_;
    ovmapPostrenderKey_: any;
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    private handleClick_;
    /**
     * @private
     */
    private handleToggle_;
    /**
     * Return `true` if the overview map is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    getCollapsible(): boolean;
    /**
     * Set whether the overview map should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    setCollapsible(collapsible: boolean): void;
    /**
     * Collapse or expand the overview map according to the passed parameter. Will
     * not do anything if the overview map isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    setCollapsed(collapsed: boolean): void;
    /**
     * Determine if the overview map is collapsed.
     * @return {boolean} The overview map is collapsed.
     * @api
     */
    getCollapsed(): boolean;
    /**
     * Return `true` if the overview map view can rotate, `false` otherwise.
     * @return {boolean} True if the control view can rotate.
     * @api
     */
    getRotateWithView(): boolean;
    /**
     * Set whether the overview map view should rotate with the main map view.
     * @param {boolean} rotateWithView True if the control view should rotate.
     * @api
     */
    setRotateWithView(rotateWithView: boolean): void;
    /**
     * Return the overview map.
     * @return {import("../Map.js").default} Overview map.
     * @api
     */
    getOverviewMap(): Map;
}

type Options$1x = {
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * Text label to use for the rotate button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    label?: string | HTMLElement | undefined;
    /**
     * Text label to use for the rotate tip.
     */
    tipLabel?: string | undefined;
    /**
     * CSS class name for the compass.
     */
    compassClassName?: string | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * Hide the control when rotation is 0.
     */
    autoHide?: boolean | undefined;
    /**
     * Function called when the control should
     * be re-rendered. This is called in a `requestAnimationFrame` callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Function called when the control is clicked.
     * This will override the default `resetNorth`.
     */
    resetNorth?: (() => void) | undefined;
    /**
     * Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
declare class Rotate extends Control {
    /**
     * @param {Options} [options] Rotate options.
     */
    constructor(options?: Options$1x);
    /**
     * @type {HTMLElement}
     * @private
     */
    private label_;
    /**
     * @private
     */
    private callResetNorth_;
    /**
     * @type {number}
     * @private
     */
    private duration_;
    /**
     * @type {boolean}
     * @private
     */
    private autoHide_;
    /**
     * @private
     * @type {number|undefined}
     */
    private rotation_;
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    private handleClick_;
    /**
     * @private
     */
    private resetNorth_;
}

/**
 * Units for the scale line.
 */
type Units = "degrees" | "imperial" | "nautical" | "metric" | "us";
/**
 * *
 */
type ScaleLineOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:units", ObjectEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:units", Return>;
type Options$1w = {
    /**
     * CSS class name. The default is `ol-scale-bar` when configured with
     * `bar: true`. Otherwise the default is `ol-scale-line`.
     */
    className?: string | undefined;
    /**
     * Minimum width in pixels at the OGC default dpi. The width will be
     * adjusted to match the dpi used.
     */
    minWidth?: number | undefined;
    /**
     * Maximum width in pixels at the OGC default dpi. The width will be
     * adjusted to match the dpi used.
     */
    maxWidth?: number | undefined;
    /**
     * Function called when the control
     * should be re-rendered. This is called in a `requestAnimationFrame` callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Specify a target if you want the control
     * to be rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
    /**
     * Units.
     */
    units?: Units | undefined;
    /**
     * Render scalebars instead of a line.
     */
    bar?: boolean | undefined;
    /**
     * Number of steps the scalebar should use. Use even numbers
     * for best results. Only applies when `bar` is `true`.
     */
    steps?: number | undefined;
    /**
     * Render the text scale above of the scalebar. Only applies
     * when `bar` is `true`.
     */
    text?: boolean | undefined;
    /**
     * dpi of output device such as printer. Only applies
     * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
     */
    dpi?: number | undefined;
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:units', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |'change:units', Return>} ScaleLineOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className] CSS class name. The default is `ol-scale-bar` when configured with
 * `bar: true`. Otherwise the default is `ol-scale-line`.
 * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {number} [maxWidth] Maximum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {Units} [units='metric'] Units.
 * @property {boolean} [bar=false] Render scalebars instead of a line.
 * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
 * for best results. Only applies when `bar` is `true`.
 * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
 * when `bar` is `true`.
 * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies
 * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
 */
/**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * When specifying `bar` as `true`, a scalebar will be rendered instead
 * of a scaleline.
 * For cartesian measurements of the scaleline, you need to set the
 * `getPointResolution` method of your projection to simply return the input
 * value, e.g. `projection.setGetPointResolution(r => r);`
 *
 * @api
 */
declare class ScaleLine extends Control {
    /**
     * @param {Options} [options] Scale line options.
     */
    constructor(options?: Options$1w);
    /***
     * @type {ScaleLineOnSignature<import("../events").EventsKey>}
     */
    on: ScaleLineOnSignature<EventsKey>;
    /***
     * @type {ScaleLineOnSignature<import("../events").EventsKey>}
     */
    once: ScaleLineOnSignature<EventsKey>;
    /***
     * @type {ScaleLineOnSignature<void>}
     */
    un: ScaleLineOnSignature<void>;
    /**
     * @private
     * @type {HTMLElement}
     */
    private innerElement_;
    /**
     * @private
     * @type {?import("../View.js").State}
     */
    private viewState_;
    /**
     * @private
     * @type {number}
     */
    private minWidth_;
    /**
     * @private
     * @type {number|undefined}
     */
    private maxWidth_;
    /**
     * @private
     * @type {boolean}
     */
    private renderedVisible_;
    /**
     * @private
     * @type {number|undefined}
     */
    private renderedWidth_;
    /**
     * @private
     * @type {string}
     */
    private renderedHTML_;
    /**
     * @private
     * @type {boolean}
     */
    private scaleBar_;
    /**
     * @private
     * @type {number}
     */
    private scaleBarSteps_;
    /**
     * @private
     * @type {boolean}
     */
    private scaleBarText_;
    /**
     * @private
     * @type {number|undefined}
     */
    private dpi_;
    /**
     * Return the units to use in the scale line.
     * @return {Units} The units
     * to use in the scale line.
     * @observable
     * @api
     */
    getUnits(): Units;
    /**
     * @private
     */
    private handleUnitsChanged_;
    /**
     * Set the units to use in the scale line.
     * @param {Units} units The units to use in the scale line.
     * @observable
     * @api
     */
    setUnits(units: Units): void;
    /**
     * Specify the dpi of output device such as printer.
     * @param {number|undefined} dpi The dpi of output device.
     * @api
     */
    setDpi(dpi: number | undefined): void;
    /**
     * @private
     */
    private updateElement_;
    /**
     * @private
     * @param {number} width The current width of the scalebar.
     * @param {number} scale The current scale.
     * @param {string} suffix The suffix to append to the scale text.
     * @return {string} The stringified HTML of the scalebar.
     */
    private createScaleBar;
    /**
     * Creates a marker at given position
     * @param {'absolute'|'relative'} position The position, absolute or relative
     * @return {string} The stringified div containing the marker
     */
    createMarker(position: "absolute" | "relative"): string;
    /**
     * Creates the label for a marker marker at given position
     * @param {number} i The iterator
     * @param {number} width The width the scalebar will currently use
     * @param {boolean} isLast Flag indicating if we add the last step text
     * @param {number} scale The current scale for the whole scalebar
     * @param {string} suffix The suffix for the scale
     * @return {string} The stringified div containing the step text
     */
    createStepText(i: number, width: number, isLast: boolean, scale: number, suffix: string): string;
    /**
     * Returns the appropriate scale for the given resolution and units.
     * @return {number} The appropriate scale.
     */
    getScaleForResolution(): number;
}

type Options$1v = {
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * CSS class name for the zoom-in button.
     */
    zoomInClassName?: string | undefined;
    /**
     * CSS class name for the zoom-out button.
     */
    zoomOutClassName?: string | undefined;
    /**
     * Text label to use for the zoom-in
     * button. Instead of text, also an element (e.g. a `span` element) can be used.
     */
    zoomInLabel?: string | HTMLElement | undefined;
    /**
     * Text label to use for the zoom-out button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    zoomOutLabel?: string | HTMLElement | undefined;
    /**
     * Text label to use for the button tip.
     */
    zoomInTipLabel?: string | undefined;
    /**
     * Text label to use for the button tip.
     */
    zoomOutTipLabel?: string | undefined;
    /**
     * The zoom delta applied on each click.
     */
    delta?: number | undefined;
    /**
     * Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
declare class Zoom extends Control {
    /**
     * @param {Options} [options] Zoom options.
     */
    constructor(options?: Options$1v);
    /**
     * @type {number}
     * @private
     */
    private duration_;
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */
    private handleClick_;
    /**
     * @param {number} delta Zoom delta.
     * @private
     */
    private zoomByDelta_;
}

type Options$1u = {
    /**
     * CSS class name.
     */
    className?: string | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * Function called when the control
     * should be re-rendered. This is called in a `requestAnimationFrame` callback.
     */
    render?: ((arg0: MapEvent) => void) | undefined;
    /**
     * Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoomslider'] CSS class name.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A slider type of control for zooming.
 *
 * Example:
 *
 *     map.addControl(new ZoomSlider());
 *
 * @api
 */
declare class ZoomSlider extends Control {
    /**
     * @param {Options} [options] Zoom slider options.
     */
    constructor(options?: Options$1u);
    /**
     * @type {!Array<import("../events.js").EventsKey>}
     * @private
     */
    private dragListenerKeys_;
    /**
     * Will hold the current resolution of the view.
     *
     * @type {number|undefined}
     * @private
     */
    private currentResolution_;
    /**
     * The direction of the slider. Will be determined from actual display of the
     * container and defaults to Direction.VERTICAL.
     *
     * @type {Direction}
     * @private
     */
    private direction_;
    /**
     * @type {boolean}
     * @private
     */
    private dragging_;
    /**
     * @type {number}
     * @private
     */
    private heightLimit_;
    /**
     * @type {number}
     * @private
     */
    private widthLimit_;
    /**
     * @type {number|undefined}
     * @private
     */
    private startX_;
    /**
     * @type {number|undefined}
     * @private
     */
    private startY_;
    /**
     * The calculated thumb size (border box plus margins).  Set when initSlider_
     * is called.
     * @type {import("../size.js").Size}
     * @private
     */
    private thumbSize_;
    /**
     * Whether the slider is initialized.
     * @type {boolean}
     * @private
     */
    private sliderInitialized_;
    /**
     * @type {number}
     * @private
     */
    private duration_;
    /**
     * Initializes the slider element. This will determine and set this controls
     * direction_ and also constrain the dragging of the thumb to always be within
     * the bounds of the container.
     *
     * @return {boolean} Initialization successful
     * @private
     */
    private initSlider_;
    /**
     * @param {PointerEvent} event The browser event to handle.
     * @private
     */
    private handleContainerClick_;
    /**
     * Handle dragger start events.
     * @param {PointerEvent} event The drag event.
     * @private
     */
    private handleDraggerStart_;
    /**
     * Handle dragger drag events.
     *
     * @param {PointerEvent} event The drag event.
     * @private
     */
    private handleDraggerDrag_;
    /**
     * Handle dragger end events.
     * @param {PointerEvent} event The drag event.
     * @private
     */
    private handleDraggerEnd_;
    /**
     * Positions the thumb inside its container according to the given resolution.
     *
     * @param {number} res The res.
     * @private
     */
    private setThumbPosition_;
    /**
     * Calculates the relative position of the thumb given x and y offsets.  The
     * relative position scales from 0 to 1.  The x and y offsets are assumed to be
     * in pixel units within the dragger limits.
     *
     * @param {number} x Pixel position relative to the left of the slider.
     * @param {number} y Pixel position relative to the top of the slider.
     * @return {number} The relative position of the thumb.
     * @private
     */
    private getRelativePosition_;
    /**
     * Calculates the corresponding resolution of the thumb given its relative
     * position (where 0 is the minimum and 1 is the maximum).
     *
     * @param {number} position The relative position of the thumb.
     * @return {number} The corresponding resolution.
     * @private
     */
    private getResolutionForPosition_;
    /**
     * Determines the relative position of the slider for the given resolution.  A
     * relative position of 0 corresponds to the minimum view resolution.  A
     * relative position of 1 corresponds to the maximum view resolution.
     *
     * @param {number} res The resolution.
     * @return {number} The relative position value (between 0 and 1).
     * @private
     */
    private getPositionForResolution_;
}

type Options$1t = {
    /**
     * Class name.
     */
    className?: string | undefined;
    /**
     * Specify a target if you want the control
     * to be rendered outside of the map's viewport.
     */
    target?: string | HTMLElement | undefined;
    /**
     * Text label to use for the button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     */
    label?: string | HTMLElement | undefined;
    /**
     * Text label to use for the button tip.
     */
    tipLabel?: string | undefined;
    /**
     * The extent to zoom to. If undefined the validity
     * extent of the view projection is used.
     */
    extent?: Extent$1 | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoom-extent'] Class name.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string|HTMLElement} [label='E'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.
 * @property {import("../extent.js").Extent} [extent] The extent to zoom to. If undefined the validity
 * extent of the view projection is used.
 */
/**
 * @classdesc
 * A button control which, when pressed, changes the map view to a specific
 * extent. To style this control use the css selector `.ol-zoom-extent`.
 *
 * @api
 */
declare class ZoomToExtent extends Control {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1t);
    /**
     * @type {?import("../extent.js").Extent|null}
     * @protected
     */
    protected extent: (Extent$1 | null) | null;
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    private handleClick_;
    /**
     * @protected
     */
    protected handleZoomToExtent(): void;
}

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */
/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */
declare function defaults$1(options?: DefaultsOptions$1): Collection<Control>;
type DefaultsOptions$1 = {
    /**
     * Include
     * {@link module :ol/control/Attribution~Attribution}.
     */
    attribution?: boolean | undefined;
    /**
     * Options for {@link module :ol/control/Attribution~Attribution}.
     */
    attributionOptions?: Options$1B | undefined;
    /**
     * Include
     * {@link module :ol/control/Rotate~Rotate}.
     */
    rotate?: boolean | undefined;
    /**
     * Options
     * for {@link module :ol/control/Rotate~Rotate}.
     */
    rotateOptions?: Options$1x | undefined;
    /**
     * Include {@link module :ol/control/Zoom~Zoom}.
     */
    zoom?: boolean | undefined;
    /**
     * Options for
     * {@link module :ol/control/Zoom~Zoom}.
     */
    zoomOptions?: Options$1v | undefined;
};

/**
 * @module ol/css
 */
/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */
/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
declare const CLASS_HIDDEN: string;
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
declare const CLASS_SELECTABLE: string;
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
declare const CLASS_UNSELECTABLE: string;
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
declare const CLASS_UNSUPPORTED: string;
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
declare const CLASS_CONTROL: string;
/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
declare const CLASS_COLLAPSED: string;
declare function getFontParameters(fontSpec: string): FontParameters | null;
type FontParameters = {
    /**
     * Style.
     */
    style: string;
    /**
     * Variant.
     */
    variant: string;
    /**
     * Weight.
     */
    weight: string;
    /**
     * Size.
     */
    size: string;
    /**
     * LineHeight.
     */
    lineHeight: string;
    /**
     * Family.
     */
    family: string;
    /**
     * Families.
     */
    families: Array<string>;
};

/**
 * @module ol/dom
 */
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */
declare function createCanvasContext2D(width?: number, height?: number, canvasPool?: Array<HTMLCanvasElement>, settings?: CanvasRenderingContext2DSettings): CanvasRenderingContext2D;
/**
 * @return {CanvasRenderingContext2D} Shared canvas context.
 */
declare function getSharedCanvasContext2D(): CanvasRenderingContext2D;
/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */
declare function releaseCanvas(context: CanvasRenderingContext2D): void;
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
declare function outerWidth(element: HTMLElement): number;
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
declare function outerHeight(element: HTMLElement): number;
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
declare function replaceNode(newNode: Node, oldNode: Node): void;
/**
 * @param {Node} node The node to remove the children from.
 */
declare function removeChildren(node: Node): void;
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */
declare function replaceChildren(node: Node, children: Array<Node>): void;

/**
 * @module ol/easing
 */
/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
declare function easeIn(t: number): number;
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
declare function easeOut(t: number): number;
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
declare function inAndOut(t: number): number;
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
declare function linear(t: number): number;
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
declare function upAndDown(t: number): number;

type SnapEventType = string;
declare namespace SnapEventType {
    let SNAP: string;
}
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this
 */
declare class SnapEvent extends BaseEvent {
    /**
     * @param {SnapEventType} type Type.
     * @param {Object} options Options.
     * @param {import("../coordinate.js").Coordinate} options.vertex The snapped vertex.
     * @param {import("../coordinate.js").Coordinate} options.vertexPixel The pixel of the snapped vertex.
     * @param {import("../Feature.js").default} options.feature The feature being snapped.
     * @param {Array<import("../coordinate.js").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.
     */
    constructor(type: SnapEventType, options: {
        vertex: Coordinate;
        vertexPixel: Coordinate;
        feature: Feature$2;
        segment: Array<Coordinate> | null;
    });
    /**
     * The Map coordinate of the snapped point.
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    vertex: Coordinate;
    /**
     * The Map pixel of the snapped point.
     * @type {Array<number>&Array<number>}
     * @api
     */
    vertexPixel: Array<number> & Array<number>;
    /**
     * The feature closest to the snapped point.
     * @type {import("../Feature.js").default<import("../geom/Geometry.js").default>}
     * @api
     */
    feature: Feature$2<Geometry$1>;
    /**
     * The segment closest to the snapped point, if snapped to a segment.
     * @type {Array<import("../coordinate.js").Coordinate>|null}
     * @api
     */
    segment: Array<Coordinate> | null;
}

/**
 * Always returns true.
 * @return {boolean} true.
 */
declare function TRUE(): boolean;
/**
 * Always returns false.
 * @return {boolean} false.
 */
declare function FALSE(): boolean;
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
declare function VOID(): void;
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */
declare function memoizeOne<ReturnType>(fn: (...args: any[]) => ReturnType): (...args: any[]) => ReturnType;
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */
declare function toPromise<T>(getter: () => (T | Promise<T>)): Promise<T>;

/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */
/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */
declare function all$1(...args: Condition[]): Condition;
declare function altKeyOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function altShiftKeysOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function focus(event: MapBrowserEvent<any>): boolean;
declare function focusWithTabindex(event: MapBrowserEvent<any>): boolean;
/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
declare const always: typeof TRUE;
declare function click(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function mouseActionButton(mapBrowserEvent: MapBrowserEvent<any>): boolean;
/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
declare const never: typeof FALSE;
declare function pointerMove(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function singleClick(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function doubleClick(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function noModifierKeys(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function platformModifierKeyOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function platformModifierKey(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function shiftKeyOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function targetNotEditable(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function mouseOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function touchOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function penOnly(mapBrowserEvent: MapBrowserEvent<any>): boolean;
declare function primaryAction(mapBrowserEvent: MapBrowserEvent<any>): boolean;
/**
 * A function that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 */
type Condition = (this: unknown, arg1: MapBrowserEvent<any>) => boolean;

/**
 * Get a string representation for a type.
 * @param {number} type The type.
 * @return {string} The type name.
 */
declare function typeName(type: number): string;
/**
 * @param {number} broad The broad type.
 * @param {number} specific The specific type.
 * @return {boolean} The broad type includes the specific type.
 */
declare function includesType(broad: number, specific: number): boolean;
/**
 * @param {number} oneType One type.
 * @param {number} otherType Another type.
 * @return {boolean} The set of types overlap (share a common specific type)
 */
declare function overlapsType(oneType: number, otherType: number): boolean;
/**
 * @param {number} type The type.
 * @param {number} expected The expected type.
 * @return {boolean} The given type is exactly the expected type.
 */
declare function isType(type: number, expected: number): boolean;
/**
 * @typedef {LiteralExpression|CallExpression} Expression
 */
/**
 * @typedef {Object} ParsingContext
 * @property {Set<string>} variables Variables referenced with the 'var' operator.
 * @property {Set<string>} properties Properties referenced with the 'get' operator.
 * @property {boolean} featureId The style uses the feature id.
 * @property {boolean} geometryType The style uses the feature geometry type.
 */
/**
 * @return {ParsingContext} A new parsing context.
 */
declare function newParsingContext(): ParsingContext$1;
/**
 * @typedef {LiteralValue|Array} EncodedExpression
 */
/**
 * @param {EncodedExpression} encoded The encoded expression.
 * @param {number} expectedType The expected type.
 * @param {ParsingContext} context The parsing context.
 * @return {Expression} The parsed expression result.
 */
declare function parse$1(encoded: EncodedExpression, expectedType: number, context: ParsingContext$1): Expression;
/**
 * Returns a simplified geometry type suited for the `geometry-type` operator
 * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object
 * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found
 */
declare function computeGeometryType(geometry: Geometry$1 | RenderFeature): "Point" | "LineString" | "Polygon" | "";
declare const NoneType: 0;
declare const BooleanType: number;
declare const NumberType: number;
declare const StringType: number;
declare const ColorType: number;
declare const NumberArrayType: number;
declare const SizeType: number;
declare const AnyType: number;
/**
 * @typedef {boolean|number|string|Array<number>} LiteralValue
 */
declare class LiteralExpression {
    /**
     * @param {number} type The value type.
     * @param {LiteralValue} value The literal value.
     */
    constructor(type: number, value: LiteralValue);
    type: number;
    value: LiteralValue;
}
declare class CallExpression {
    /**
     * @param {number} type The return type.
     * @param {string} operator The operator.
     * @param {...Expression} args The arguments.
     */
    constructor(type: number, operator: string, ...args: Expression[]);
    type: number;
    operator: string;
    args: Expression[];
}
/**
 * @type {Object<string, string>}
 */
declare const Ops: {
    [x: string]: string;
};
type Expression = LiteralExpression | CallExpression;
type ParsingContext$1 = {
    /**
     * Variables referenced with the 'var' operator.
     */
    variables: Set<string>;
    /**
     * Properties referenced with the 'get' operator.
     */
    properties: Set<string>;
    /**
     * The style uses the feature id.
     */
    featureId: boolean;
    /**
     * The style uses the feature geometry type.
     */
    geometryType: boolean;
};
type EncodedExpression = LiteralValue | any[];
/**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import ("./expression.js").ExpressionValue} arguments.
 *
 * See below for details on the available operators (with notes for those that are WebGL or Canvas only).
 *
 * * Reading operators:
 *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import ("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import ("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import ("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).
 *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.
 *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a
 *     feature property. The result is `undefined` when there is nothing at the specified key or index.
 *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'
 *     `Multi*` values are returned as their singular equivalent
 *     `Circle` geometries are returned as 'Polygon'
 *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).
 *   * `['resolution']` returns the current resolution
 *   * `['time']` The time in seconds since the creation of the layer (WebGL only).
 *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined
 *   * `['zoom']` The current zoom level (WebGL only).
 *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line
 *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.
 *      Please note that the M component will be linearly interpolated between the two points composing a segment.
 *
 * * Math operators:
 *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)
 *   * `['/', value1, value2]` divides `value1` by `value2`
 *   * `['+', value1, value2, ...]` adds the values
 *   * `['-', value1, value2]` subtracts `value2` from `value1`
 *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   * `['abs', value1]` returns the absolute value of `value1`
 *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *   * `['sqrt', value1]` returns the square root of `value1`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.
 *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`
 *     (Canvas only).
 *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.
 *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`
 *     (Canvas only).
 *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.
 *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`
 *     (Canvas only).
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,
 *     `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and
 *     `false` otherwise.
 *     This operator has the following limitations:
 *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)
 *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an
 *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:
 *     `['literal', ['abc', 'def', 'ghi']]`
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4 (WebGL only).
 *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;
 *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).
 *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range) (WebGL only).
 *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is "true" or "false".
 *     If the input is a number, it is converted to a string as specified by the "NumberToString" algorithm of the ECMAScript
 *     Language Specification. If the input is a color, it is converted to a string of the form "rgba(r,g,b,a)". (Canvas only)
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `number[]` (number arrays can only have a length of 2, 3 or 4)
 * * `string`
 * * {@link module :ol/color~Color}
 */
type ExpressionValue$1 = Array<any> | Color | string | number | boolean;
type LiteralValue = boolean | number | string | Array<number>;

/**
 * @fileoverview This module includes functions to build expressions for evaluation on the CPU.
 * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded
 * expression and returns an instance of one of the expression classes.  The compiling step takes
 * the expression instance and returns a function that can be evaluated in to return a literal
 * value.  The evaluator function should do as little allocation and work as possible.
 */
/**
 * @typedef {Object} EvaluationContext
 * @property {Object} properties The values for properties used in 'get' expressions.
 * @property {Object} variables The values for variables used in 'var' expressions.
 * @property {number} resolution The map resolution.
 * @property {string|number|null} featureId The feature id.
 * @property {string} geometryType Geometry type of the current object.
 */
/**
 * @return {EvaluationContext} A new evaluation context.
 */
declare function newEvaluationContext(): EvaluationContext$1;
/**
 * @typedef {function(EvaluationContext):import("./expression.js").LiteralValue} ExpressionEvaluator
 */
/**
 * @typedef {function(EvaluationContext):boolean} BooleanEvaluator
 */
/**
 * @typedef {function(EvaluationContext):number} NumberEvaluator
 */
/**
 * @typedef {function(EvaluationContext):string} StringEvaluator
 */
/**
 * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator
 */
/**
 * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator
 */
/**
 * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator
 */
/**
 * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator
 */
/**
 * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator
 */
/**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The expression evaluator.
 */
declare function buildExpression$1(encoded: EncodedExpression, type: number, context: ParsingContext$1): ExpressionEvaluator;
type EvaluationContext$1 = {
    /**
     * The values for properties used in 'get' expressions.
     */
    properties: any;
    /**
     * The values for variables used in 'var' expressions.
     */
    variables: any;
    /**
     * The map resolution.
     */
    resolution: number;
    /**
     * The feature id.
     */
    featureId: string | number | null;
    /**
     * Geometry type of the current object.
     */
    geometryType: string;
};
type ExpressionEvaluator = (arg0: EvaluationContext$1) => LiteralValue;

/**
 * @module ol/webgl/PaletteTexture
 */
declare class PaletteTexture {
    /**
     * @param {string} name The name of the texture.
     * @param {Uint8Array} data The texture data.
     */
    constructor(name: string, data: Uint8Array);
    name: string;
    data: Uint8Array<ArrayBufferLike>;
    /**
     * @type {WebGLTexture|null}
     * @private
     */
    private texture_;
    /**
     * @param {WebGLRenderingContext} gl Rendering context.
     * @return {WebGLTexture} The texture.
     */
    getTexture(gl: WebGLRenderingContext): WebGLTexture;
    /**
     * @param {WebGLRenderingContext} gl Rendering context.
     */
    delete(gl: WebGLRenderingContext): void;
}
//# sourceMappingURL=PaletteTexture.d.ts.map

/**
 * Will return the number as a float with a dot separator, which is required by GLSL.
 * @param {number} v Numerical value.
 * @return {string} The value as string.
 */
declare function numberToGlsl(v: number): string;
/**
 * Will return the number array as a float with a dot separator, concatenated with ', '.
 * @param {Array<number>} array Numerical values array.
 * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.
 */
declare function arrayToGlsl(array: Array<number>): string;
/**
 * Will normalize and converts to string a `vec4` color array compatible with GLSL.
 * @param {string|import("../color.js").Color} color Color either in string format or [r, g, b, a] array format,
 * with RGB components in the 0..255 range and the alpha component in the 0..1 range.
 * Note that the final array will always have 4 components.
 * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
 */
declare function colorToGlsl(color: string | Color): string;
/**
 * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.
 * @param {number|import('../size.js').Size} size Size.
 * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
 */
declare function sizeToGlsl(size: number | Size): string;
/**
 * Returns a stable equivalent number for the string literal.
 * @param {string} string String literal value
 * @return {number} Number equivalent
 */
declare function getStringNumberEquivalent(string: string): number;
/**
 * Returns a stable equivalent number for the string literal, for use in shaders. This number is then
 * converted to be a GLSL-compatible string.
 * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216
 * @param {string} string String literal value
 * @return {string} GLSL-compatible string containing a number
 */
declare function stringToGlsl(string: string): string;
/**
 * Get the uniform name given a variable name.
 * @param {string} variableName The variable name.
 * @return {string} The uniform name.
 */
declare function uniformNameForVariable(variableName: string): string;
/**
 * @typedef {import('./expression.js').ParsingContext} ParsingContext
 */
/**
 *
 * @typedef {import("./expression.js").Expression} Expression
 */
/**
 *
 * @typedef {import("./expression.js").LiteralExpression} LiteralExpression
 */
/**
 * @typedef {Object} CompilationContextProperty
 * @property {string} name Name
 * @property {number} type Resolved property type
 */
/**
 * @typedef {Object} CompilationContextVariable
 * @property {string} name Name
 * @property {number} type Resolved variable type
 */
/**
 * @typedef {Object} CompilationContext
 * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader
 * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.
 * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.
 * @property {Object<string, string>} functions Lookup of functions used by the style.
 * @property {number} [bandCount] Number of bands per pixel.
 * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.
 * @property {boolean} featureId Whether the feature ID is used in the expression
 * @property {boolean} geometryType Whether the geometry type is used in the expression
 */
/**
 * @return {CompilationContext} A new compilation context.
 */
declare function newCompilationContext(): CompilationContext;
/**
 * @typedef {string} CompiledExpression
 */
/**
 * @typedef {function(CompilationContext, CallExpression, number): string} Compiler
 * Third argument is the expected value types
 */
/**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.
 * @param {CompilationContext} compilationContext An existing compilation context
 * @return {CompiledExpression} The compiled expression.
 */
declare function buildExpression(encoded: EncodedExpression, type: number, parsingContext: ParsingContext$1, compilationContext: CompilationContext): CompiledExpression;
declare const PALETTE_TEXTURE_ARRAY: "u_paletteTextures";
declare const FEATURE_ID_PROPERTY_NAME: "featureId";
declare const GEOMETRY_TYPE_PROPERTY_NAME: "geometryType";
type CompilationContextProperty = {
    /**
     * Name
     */
    name: string;
    /**
     * Resolved property type
     */
    type: number;
};
type CompilationContextVariable = {
    /**
     * Name
     */
    name: string;
    /**
     * Resolved variable type
     */
    type: number;
};
type CompilationContext = {
    /**
     * If false, means the expression output should be made for a vertex shader
     */
    inFragmentShader?: boolean | undefined;
    /**
     * The values for properties used in 'get' expressions.
     */
    properties: {
        [x: string]: CompilationContextProperty;
    };
    /**
     * The values for variables used in 'var' expressions.
     */
    variables: {
        [x: string]: CompilationContextVariable;
    };
    /**
     * Lookup of functions used by the style.
     */
    functions: {
        [x: string]: string;
    };
    /**
     * Number of bands per pixel.
     */
    bandCount?: number | undefined;
    /**
     * List of palettes used by the style.
     */
    paletteTextures?: PaletteTexture[] | undefined;
    /**
     * Whether the feature ID is used in the expression
     */
    featureId: boolean;
    /**
     * Whether the geometry type is used in the expression
     */
    geometryType: boolean;
};
type CompiledExpression = string;

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("../Feature.js").default]
 * @extends {FeatureFormat<FeatureType>}
 * @abstract
 */
declare class JSONFeature<FeatureType extends FeatureLike = Feature$2<Geometry$1>> extends FeatureFormat<FeatureType> {
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {FeatureType|Array<FeatureType>} Feature.
     */
    protected readFeatureFromObject(object: any, options?: ReadOptions): FeatureType | Array<FeatureType>;
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {Array<FeatureType>} Features.
     */
    protected readFeaturesFromObject(object: any, options?: ReadOptions): Array<FeatureType>;
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    protected readGeometryFromObject(object: any, options?: ReadOptions): Geometry$1;
    /**
     * Read the projection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    override readProjection(source: ArrayBuffer | Document | Element | any | string): Projection;
    /**
     * @abstract
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    protected readProjectionFromObject(object: any): Projection;
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @api
     * @override
     */
    override writeFeature(feature: Feature$2, options?: WriteOptions): string;
    /**
     * @abstract
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeFeatureObject(feature: Feature$2, options?: WriteOptions): any;
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded features.
     * @api
     * @override
     */
    override writeFeatures(features: Array<Feature$2>, options?: WriteOptions): string;
    /**
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeFeaturesObject(features: Array<Feature$2>, options?: WriteOptions): any;
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @api
     * @override
     */
    override writeGeometry(geometry: Geometry$1, options?: WriteOptions): string;
    /**
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeGeometryObject(geometry: Geometry$1, options?: WriteOptions): any;
}
//# sourceMappingURL=JSONFeature.d.ts.map

type EsriJSONFeatureSet = arcgis_rest_api.FeatureSet;
type EsriJSONGeometry = arcgis_rest_api.Geometry;
type Options$1s = {
    /**
     * Geometry name to use when creating features.
     */
    geometryName?: string | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [geometryName] Geometry name to use when creating features.
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the EsriJSON format.
 *
 * @api
 */
declare class EsriJSON extends JSONFeature<Feature$2<Geometry$1>> {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1s);
    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */
    private geometryName_;
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @param {string} [idField] Name of the field where to get the id from.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     * @override
     */
    protected override readFeatureFromObject(object: any, options?: ReadOptions, idField?: string): Feature$2;
    /**
     * @param {EsriJSONGeometry} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    protected override readGeometryFromObject(object: EsriJSONGeometry, options?: ReadOptions): Geometry$1;
    /**
     * Encode a geometry as a EsriJSON object.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {EsriJSONGeometry} Object.
     * @api
     * @override
     */
    override writeGeometryObject(geometry: Geometry$1, options?: WriteOptions): EsriJSONGeometry;
    /**
     * Encode an array of features as a EsriJSON object.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {EsriJSONFeatureSet} EsriJSON Object.
     * @api
     * @override
     */
    override writeFeaturesObject(features: Array<Feature$2>, options?: WriteOptions): EsriJSONFeatureSet;
}

/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Element} Node.
 */
declare function createElementNS(namespaceURI: string, qualifiedName: string): Element;
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
declare function getAllTextContent(node: Node, normalizeWhitespace: boolean): string;
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array<string>} accumulator Accumulator.
 * @private
 * @return {Array<string>} Accumulator.
 */
declare function getAllTextContent_(node: Node, normalizeWhitespace: boolean, accumulator: Array<string>): Array<string>;
/**
 * @param {Object} object Object.
 * @return {boolean} Is a document.
 */
declare function isDocument(object: any): boolean;
/**
 * @param {Element} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */
declare function getAttributeNS(node: Element, namespaceURI: string | null, name: string): string;
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */
declare function parse(xml: string): Document;
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
declare function makeArrayExtender<T>(valueReader: (this: T, arg1: Node, arg2: Array<any>) => (Array<any> | undefined), thisArg?: T): Parser;
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
declare function makeArrayPusher<T>(valueReader: (this: T, arg1: Element, arg2: Array<any>) => any, thisArg?: T): Parser;
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
declare function makeReplacer<T>(valueReader: (this: T, arg1: Node, arg2: Array<any>) => any, thisArg?: T): Parser;
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
declare function makeObjectPropertyPusher<T>(valueReader: (this: T, arg1: Element, arg2: Array<any>) => any, property?: string, thisArg?: T): Parser;
/**
 * Make an object property setter function.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
declare function makeObjectPropertySetter<T>(valueReader: (this: T, arg1: Element, arg2: Array<any>) => any, property?: string, thisArg?: T): Parser;
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */
declare function makeChildAppender<T, V>(nodeWriter: (this: T, arg1: Node, arg2: V, arg3: Array<any>) => void, thisArg?: T): Serializer;
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the
 * `nodeWriter` called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */
declare function makeArraySerializer<T, V>(nodeWriter: (this: T, arg1: Element, arg2: V, arg3: Array<any>) => void, thisArg?: T): Serializer;
/**
 * Create a node factory which can use the `keys` passed to
 * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string} [fixedNodeName] Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.
 */
declare function makeSimpleNodeFactory(fixedNodeName?: string, fixedNamespaceURI?: string): (arg0: any, arg1: Array<any>, arg2: string | undefined) => (Node | undefined);
/**
 * Create an array of `values` to be used with {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `key` argument.
 * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array<*>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 */
declare function makeSequence(object: {
    [x: string]: any;
}, orderedKeys: Array<string>): Array<any>;
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object<string, T>} [structureNS] Namespaced structure to add to.
 * @return {Object<string, T>} Namespaced structure.
 * @template T
 */
declare function makeStructureNS<T>(namespaceURIs: Array<string>, structure: T, structureNS?: {
    [x: string]: T;
}): {
    [x: string]: T;
};
/**
 * Parse a node using the parsers and object stack.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 */
declare function parseNode(parsersNS: {
    [x: string]: {
        [x: string]: Parser;
    };
}, node: Element, objectStack: Array<any>, thisArg?: any): void;
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 * @return {T} Object.
 * @template T
 */
declare function pushParseAndPop<T>(object: T, parsersNS: {
    [x: string]: {
        [x: string]: Parser;
    };
}, node: Element, objectStack: Array<any>, thisArg?: any): T;
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */
declare function serialize<T>(serializersNS: {
    [x: string]: {
        [x: string]: Serializer;
    };
}, nodeFactory: (this: T, arg1: any, arg2: Array<any>, arg3: (string | undefined)) => (Node | undefined), values: Array<any>, objectStack: Array<any>, keys?: Array<string>, thisArg?: T): void;
/**
 * @param {O} object Object.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */
declare function pushSerializeAndPop<O, T>(object: O, serializersNS: {
    [x: string]: {
        [x: string]: Serializer;
    };
}, nodeFactory: (this: T, arg1: any, arg2: Array<any>, arg3: (string | undefined)) => (Node | undefined), values: Array<any>, objectStack: Array<any>, keys?: Array<string>, thisArg?: T): O | undefined;
/**
 * Register a XMLSerializer. Can be used  to inject a XMLSerializer
 * where there is no globally available implementation.
 *
 * @param {XMLSerializer} xmlSerializer A XMLSerializer.
 * @api
 */
declare function registerXMLSerializer(xmlSerializer: XMLSerializer): void;
/**
 * @return {XMLSerializer} The XMLSerializer.
 */
declare function getXMLSerializer(): XMLSerializer;
/**
 * Register a Document to use when creating nodes for XML serializations. Can be used
 * to inject a Document where there is no globally available implementation.
 *
 * @param {Document} document A Document.
 * @api
 */
declare function registerDocument(document: Document): void;
/**
 * Get a document that should be used when creating nodes for XML serializations.
 * @return {Document} The document.
 */
declare function getDocument(): Document;
/**
 * When using {@link module:ol/xml.makeChildAppender} or
 * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs
 * to have this structure.
 * @typedef {Object} NodeStackItem
 * @property {Element} node Node.
 */
/**
 * @typedef {function(Element, Array<*>): void} Parser
 */
/**
 * @typedef {function(Element, *, Array<*>): void} Serializer
 */
/**
 * @type {string}
 */
declare const XML_SCHEMA_INSTANCE_URI: string;
/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
declare const OBJECT_PROPERTY_NODE_FACTORY: (arg0: any, arg1: Array<any>, arg2: string | undefined) => (Node | undefined);
type Parser = (arg0: Element, arg1: Array<any>) => void;
type Serializer = (arg0: Element, arg1: any, arg2: Array<any>) => void;

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @abstract
 */
declare class XMLFeature extends FeatureFormat<Feature$2<Geometry$1>> {
    constructor();
    /**
     * @type {XMLSerializer}
     * @private
     */
    private xmlSerializer_;
    /**
     * Read a single feature.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     * @override
     */
    override readFeature(source: Document | Element | any | string, options?: ReadOptions): Feature$2;
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromDocument(doc: Document, options?: ReadOptions): Feature$2;
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromNode(node: Element, options?: ReadOptions): Feature$2;
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    protected readFeaturesFromDocument(doc: Document, options?: ReadOptions): Array<Feature$2>;
    /**
     * @abstract
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    protected readFeaturesFromNode(node: Element, options?: ReadOptions): Array<Feature$2>;
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    protected readGeometryFromDocument(doc: Document, options?: ReadOptions): Geometry$1;
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    protected readGeometryFromNode(node: Element, options?: ReadOptions): Geometry$1;
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    override readProjection(source: Document | Element | any | string): Projection;
    /**
     * @param {Document} doc Document.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    protected readProjectionFromDocument(doc: Document): Projection;
    /**
     * @param {Element} node Node.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    protected readProjectionFromNode(node: Element): Projection;
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @override
     */
    override writeFeature(feature: Feature$2, options?: WriteOptions): string;
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @protected
     * @return {Node} Node.
     */
    protected writeFeatureNode(feature: Feature$2, options?: WriteOptions): Node;
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Result.
     * @api
     * @override
     */
    override writeFeatures(features: Array<Feature$2>, options?: WriteOptions): string;
    /**
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeFeaturesNode(features: Array<Feature$2>, options?: WriteOptions): Node;
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @override
     */
    override writeGeometry(geometry: Geometry$1, options?: WriteOptions): string;
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeGeometryNode(geometry: Geometry$1, options?: WriteOptions): Node;
}
//# sourceMappingURL=XMLFeature.d.ts.map

type Options$1r = {
    /**
     * Feature
     * namespace. If not defined will be derived from GML. If multiple
     * feature types have been configured which come from different feature
     * namespaces, this will be an object with the keys being the prefixes used
     * in the entries of featureType array. The values of the object will be the
     * feature namespaces themselves. So for instance there might be a featureType
     * item `topp:states` in the `featureType` array and then there will be a key
     * `topp` in the featureNS object with value `http://www.openplans.org/topp`.
     */
    featureNS?: string | {
        [x: string]: string;
    } | undefined;
    /**
     * Feature type(s) to parse.
     * If multiple feature types need to be configured
     * which come from different feature namespaces, `featureNS` will be an object
     * with the keys being the prefixes used in the entries of featureType array.
     * The values of the object will be the feature namespaces themselves.
     * So for instance there might be a featureType item `topp:states` and then
     * there will be a key named `topp` in the featureNS object with value
     * `http://www.openplans.org/topp`.
     */
    featureType?: string | string[] | undefined;
    /**
     * srsName to use when writing geometries.
     */
    srsName?: string | undefined;
    /**
     * Write gml:Surface instead of gml:Polygon
     * elements. This also affects the elements in multi-part geometries.
     */
    surface?: boolean | undefined;
    /**
     * Write gml:Curve instead of gml:LineString
     * elements. This also affects the elements in multi-part geometries.
     */
    curve?: boolean | undefined;
    /**
     * Write gml:MultiCurve instead of gml:MultiLineString.
     * Since the latter is deprecated in GML 3.
     */
    multiCurve?: boolean | undefined;
    /**
     * Write gml:multiSurface instead of
     * gml:MultiPolygon. Since the latter is deprecated in GML 3.
     */
    multiSurface?: boolean | undefined;
    /**
     * Optional schemaLocation to use when
     * writing out the GML, this will override the default provided.
     */
    schemaLocation?: string | undefined;
    /**
     * If coordinates have a Z value.
     */
    hasZ?: boolean | undefined;
};
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] Feature
 * namespace. If not defined will be derived from GML. If multiple
 * feature types have been configured which come from different feature
 * namespaces, this will be an object with the keys being the prefixes used
 * in the entries of featureType array. The values of the object will be the
 * feature namespaces themselves. So for instance there might be a featureType
 * item `topp:states` in the `featureType` array and then there will be a key
 * `topp` in the featureNS object with value `http://www.openplans.org/topp`.
 * @property {Array<string>|string} [featureType] Feature type(s) to parse.
 * If multiple feature types need to be configured
 * which come from different feature namespaces, `featureNS` will be an object
 * with the keys being the prefixes used in the entries of featureType array.
 * The values of the object will be the feature namespaces themselves.
 * So for instance there might be a featureType item `topp:states` and then
 * there will be a key named `topp` in the featureNS object with value
 * `http://www.openplans.org/topp`.
 * @property {string} [srsName] srsName to use when writing geometries.
 * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.
 * Since the latter is deprecated in GML 3.
 * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of
 * gml:MultiPolygon. Since the latter is deprecated in GML 3.
 * @property {string} [schemaLocation] Optional schemaLocation to use when
 * writing out the GML, this will override the default provided.
 * @property {boolean} [hasZ=false] If coordinates have a Z value.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes GML2 and GML3.
 *
 * @abstract
 * @api
 */
declare class GMLBase extends XMLFeature {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(options?: Options$1r);
    /**
     * @protected
     * @type {Array<string>|string|undefined}
     */
    protected featureType: Array<string> | string | undefined;
    /**
     * @protected
     * @type {Object<string, string>|string|undefined}
     */
    protected featureNS: {
        [x: string]: string;
    } | string | undefined;
    /**
     * @protected
     * @type {string|undefined}
     */
    protected srsName: string | undefined;
    /**
     * @protected
     * @type {string}
     */
    protected schemaLocation: string;
    /**
     * @type {Object<string, Object<string, Object>>}
     */
    FEATURE_COLLECTION_PARSERS: {
        [x: string]: {
            [x: string]: any;
        };
    };
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<Feature> | undefined} Features.
     */
    readFeaturesInternal(node: Element, objectStack: Array<any>): Array<Feature$2> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
     */
    readGeometryOrExtent(node: Element, objectStack: Array<any>): Geometry$1 | Extent$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Geometry.
     */
    readExtentElement(node: Element, objectStack: Array<any>): Extent$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|undefined} Geometry.
     */
    readGeometryElement(node: Element, objectStack: Array<any>): Geometry$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @param {boolean} asFeature whether result should be wrapped as a feature.
     * @return {Feature|Object} Feature
     */
    readFeatureElementInternal(node: Element, objectStack: Array<any>, asFeature: boolean): Feature$2 | any;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Feature} Feature.
     */
    readFeatureElement(node: Element, objectStack: Array<any>): Feature$2;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Point|undefined} Point.
     */
    readPoint(node: Element, objectStack: Array<any>): Point$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPoint|undefined} MultiPoint.
     */
    readMultiPoint(node: Element, objectStack: Array<any>): MultiPoint$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiLineString(node: Element, objectStack: Array<any>): MultiLineString$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiPolygon(node: Element, objectStack: Array<any>): MultiPolygon$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    pointMemberParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    lineStringMemberParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    polygonMemberParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readLineString(node: Element, objectStack: Array<any>): LineString$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} LinearRing flat coordinates.
     */
    readFlatLinearRing(node: Element, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LinearRing|undefined} LinearRing.
     */
    readLinearRing(node: Element, objectStack: Array<any>): LinearRing | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readPolygon(node: Element, objectStack: Array<any>): Polygon$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} Flat coordinates.
     */
    readFlatCoordinatesFromNode(node: Element, objectStack: Array<any>): Array<number>;
    namespace: string;
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    FLAT_LINEAR_RINGS_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    GEOMETRY_FLAT_COORDINATES_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    GEOMETRY_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    MULTIPOINT_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    MULTILINESTRING_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    MULTIPOLYGON_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    POINTMEMBER_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    LINESTRINGMEMBER_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    POLYGONMEMBER_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    RING_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
}

/**
 * @classdesc
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @api
 */
declare class GML3 extends GMLBase {
    /**
     * @private
     * @type {boolean}
     */
    private surface_;
    /**
     * @private
     * @type {boolean}
     */
    private curve_;
    /**
     * @private
     * @type {boolean}
     */
    private multiCurve_;
    /**
     * @private
     * @type {boolean}
     */
    private multiSurface_;
    /**
     * @private
     * @type {boolean}
     */
    private hasZ;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiCurve(node: Element, objectStack: Array<any>): MultiLineString$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Polygon.
     */
    readFlatCurveRing(node: Element, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiSurface(node: Element, objectStack: Array<any>): MultiPolygon$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    curveMemberParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    surfaceMemberParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPatch(node: Element, objectStack: Array<any>): Array<(Array<number>)> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readSegment(node: Element, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPolygonPatch(node: Element, objectStack: Array<any>): Array<(Array<number>)> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readLineStringSegment(node: Element, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    interiorParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    exteriorParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readSurface(node: Element, objectStack: Array<any>): Polygon$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readCurve(node: Element, objectStack: Array<any>): LineString$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readEnvelope(node: Element, objectStack: Array<any>): Extent$1 | undefined;
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPos(node: Node, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPosList(node: Element, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} value Point geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writePos_;
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    private getCoords_;
    /**
     * @param {Element} node Node.
     * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writePosList_;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(node: Element, geometry: Point$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(node: Element, extent: Extent$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(node: Element, geometry: LinearRing, objectStack: Array<any>): void;
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    private RING_NODE_FACTORY_;
    /**
     * @param {Element} node Node.
     * @param {Polygon} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(node: Element, geometry: Polygon$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {LineString} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(node: Element, geometry: LineString$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {MultiPolygon} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(node: Element, geometry: MultiPolygon$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(node: Element, geometry: MultiPoint$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {MultiLineString} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(node: Element, geometry: MultiLineString$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(node: Element, ring: LinearRing, objectStack: Array<any>): void;
    /**
     * @param {Node} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(node: Node, polygon: Polygon$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(node: Element, point: Point$1, objectStack: Array<any>): void;
    /**
     * @param {Node} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(node: Node, line: LineString$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writeSurfacePatches_;
    /**
     * @param {Element} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writeCurveSegments_;
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(node: Node, geometry: Geometry$1 | Extent$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(node: Element, feature: Feature$2, objectStack: Array<any>): void;
    /**
     * @param {Node} node Node.
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writeFeatureMembers_;
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    private MULTIGEOMETRY_MEMBER_NODE_FACTORY_;
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    private GEOMETRY_NODE_FACTORY_;
    /**
     * Encode an array of features in the GML 3.1.1 format as an XML node.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Element} Node.
     * @api
     * @override
     */
    override writeFeaturesNode(features: Array<Feature$2>, options?: WriteOptions): Element;
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    MULTICURVE_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    MULTISURFACE_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    CURVEMEMBER_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    SURFACEMEMBER_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    SURFACE_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    CURVE_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    ENVELOPE_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    PATCHES_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    SEGMENTS_PARSERS: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    RING_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    ENVELOPE_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    SURFACEORPOLYGONMEMBER_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    POINTMEMBER_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    LINESTRINGORCURVEMEMBER_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    GEOMETRY_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
}
//# sourceMappingURL=GML3.d.ts.map

/**
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @class
 * @param {import("./GMLBase.js").Options} [options]
 *     Optional configuration object.
 * @api
 */
declare const GML: typeof GML3;
//# sourceMappingURL=GML.d.ts.map

/**
 * @classdesc
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 *
 * @api
 */
declare class GML2 extends GMLBase {
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatCoordinates(node: Node, objectStack: Array<any>): Array<number> | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readBox(node: Element, objectStack: Array<any>): Extent$1 | undefined;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    innerBoundaryIsParser(node: Element, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    outerBoundaryIsParser(node: Element, objectStack: Array<any>): void;
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    private GEOMETRY_NODE_FACTORY_;
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(node: Element, feature: Feature$2, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(node: Element, geometry: LineString$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(node: Element, line: LineString$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(node: Element, geometry: MultiLineString$1, objectStack: Array<any>): void;
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(node: Node, geometry: Geometry$1 | Extent$1, objectStack: Array<any>): void;
    /**
     * @param {string} namespaceURI XML namespace.
     * @return {Element} coordinates node.
     * @private
     */
    private createCoordinatesNode_;
    /**
     * @param {Node} node Node.
     * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writeCoordinates_;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writeCurveSegments_;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(node: Element, geometry: Polygon$1, objectStack: Array<any>): void;
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    private RING_NODE_FACTORY_;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    private writeSurfacePatches_;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(node: Element, ring: LinearRing, objectStack: Array<any>): void;
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    private getCoords_;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(node: Element, geometry: Point$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(node: Element, geometry: MultiPoint$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(node: Element, point: Point$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(node: Element, geometry: LinearRing, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(node: Element, geometry: MultiPolygon$1, objectStack: Array<any>): void;
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(node: Node, polygon: Polygon$1, objectStack: Array<any>): void;
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(node: Element, extent: Extent$1, objectStack: Array<any>): void;
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    private MULTIGEOMETRY_MEMBER_NODE_FACTORY_;
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Parser>>}
     */
    BOX_PARSERS_: {
        [x: string]: {
            [x: string]: Parser;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    GEOMETRY_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    LINESTRINGORCURVEMEMBER_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    RING_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    POINTMEMBER_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @const
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    SURFACEORPOLYGONMEMBER_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
    /**
     * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
     */
    ENVELOPE_SERIALIZERS: {
        [x: string]: {
            [x: string]: Serializer;
        };
    };
}
//# sourceMappingURL=GML2.d.ts.map

/**
 * @classdesc Feature format for reading and writing data in the GML format
 *            version 3.2.1.
 * @api
 */
declare class GML32 extends GML3 {
}
//# sourceMappingURL=GML32.d.ts.map

type GPXLink = {
    /**
     * text
     */
    text?: string | undefined;
    /**
     * type
     */
    type?: string | undefined;
};
type GPXAuthor = {
    /**
     * name
     */
    name?: string | undefined;
    /**
     * email
     */
    email?: string | undefined;
    /**
     * link
     */
    link?: GPXLink | undefined;
};
type GPXMetadata = {
    /**
     * name
     */
    name?: string | undefined;
    /**
     * desc
     */
    desc?: string | undefined;
    /**
     * author
     */
    author?: GPXAuthor | undefined;
    /**
     * link
     */
    link?: GPXLink | undefined;
    /**
     * time
     */
    time?: number | undefined;
    /**
     * keywords
     */
    keywords?: string | undefined;
    /**
     * bounds
     */
    bounds?: number[] | undefined;
    /**
     * extensions
     */
    extensions?: any;
};
type Options$1q = {
    /**
     * Callback function
     * to process `extensions` nodes. To prevent memory leaks, this callback function must
     * not store any references to the node. Note that the `extensions`
     * node is not allowed in GPX 1.0. Moreover, only `extensions`
     * nodes from `wpt`, `rte` and `trk` can be processed, as those are
     * directly mapped to a feature.
     */
    readExtensions?: ((arg0: Feature$2, arg1: Node) => void) | undefined;
};
/**
 * @typedef {Object} Options
 * @property {function(Feature, Node):void} [readExtensions] Callback function
 * to process `extensions` nodes. To prevent memory leaks, this callback function must
 * not store any references to the node. Note that the `extensions`
 * node is not allowed in GPX 1.0. Moreover, only `extensions`
 * nodes from `wpt`, `rte` and `trk` can be processed, as those are
 * directly mapped to a feature.
 */
/**
 * @typedef {Object} LayoutOptions
 * @property {boolean} [hasZ] HasZ.
 * @property {boolean} [hasM] HasM.
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the GPX format.
 *
 * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first
 * feature of the source.
 *
 * When reading, routes (`<rte>`) are converted into LineString geometries, and
 * tracks (`<trk>`) into MultiLineString. Any properties on route and track
 * waypoints are ignored.
 *
 * When writing, LineString geometries are output as routes (`<rte>`), and
 * MultiLineString as tracks (`<trk>`).
 *
 * @api
 */
declare class GPX extends XMLFeature {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1q);
    /**
     * @type {function(Feature, Node): void|undefined}
     * @private
     */
    private readExtensions_;
    /**
     * @param {Array<Feature>} features List of features.
     * @private
     */
    private handleReadExtensions_;
    /**
     * Reads a GPX file's metadata tag, reading among other things:
     *   - the name and description of this GPX
     *   - its author
     *   - the copyright associated with this GPX file
     *
     * Will return null if no metadata tag is present (or no valid source is given).
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {GPXMetadata | null} Metadata
     * @api
     */
    readMetadata(source: Document | Element | any | string): GPXMetadata | null;
    /**
     * @param {Document} doc Document.
     * @return {GPXMetadata | null} Metadata
     */
    readMetadataFromDocument(doc: Document): GPXMetadata | null;
    /**
     * @param {Element} node Node.
     * @return {Object} Metadata
     */
    readMetadataFromNode(node: Element): any;
}

// Note: as of the RFC 7946 version of GeoJSON, Coordinate Reference Systems
// are no longer supported. (See https://tools.ietf.org/html/rfc7946#appendix-B)}



/**
 * The value values for the "type" property of GeoJSON Objects.
 * https://tools.ietf.org/html/rfc7946#section-1.4
 */
type GeoJsonTypes = GeoJSON$1["type"];

/**
 * Bounding box
 * https://tools.ietf.org/html/rfc7946#section-5
 */
type BBox = [number, number, number, number] | [number, number, number, number, number, number];

/**
 * A Position is an array of coordinates.
 * https://tools.ietf.org/html/rfc7946#section-3.1.1
 * Array should contain between two and three elements.
 * The previous GeoJSON specification allowed more elements (e.g., which could be used to represent M values),
 * but the current specification only allows X, Y, and (optionally) Z to be defined.
 */
type Position = number[]; // [number, number] | [number, number, number];

/**
 * The base GeoJSON object.
 * https://tools.ietf.org/html/rfc7946#section-3
 * The GeoJSON specification also allows foreign members
 * (https://tools.ietf.org/html/rfc7946#section-6.1)
 * Developers should use "&" type in TypeScript or extend the interface
 * to add these foreign members.
 */
interface GeoJsonObject {
    // Don't include foreign members directly into this type def.
    // in order to preserve type safety.
    // [key: string]: any;
    /**
     * Specifies the type of GeoJSON object.
     */
    type: GeoJsonTypes;
    /**
     * Bounding box of the coordinate range of the object's Geometries, Features, or Feature Collections.
     * The value of the bbox member is an array of length 2*n where n is the number of dimensions
     * represented in the contained geometries, with all axes of the most southwesterly point
     * followed by all axes of the more northeasterly point.
     * The axes order of a bbox follows the axes order of geometries.
     * https://tools.ietf.org/html/rfc7946#section-5
     */
    bbox?: BBox | undefined;
}

/**
 * Union of GeoJSON objects.
 */
type GeoJSON$1<G extends Geometry | null = Geometry, P = GeoJsonProperties> =
    | G
    | Feature$1<G, P>
    | FeatureCollection<G, P>;

/**
 * Geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3
 */
type Geometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon | GeometryCollection;

/**
 * Point geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.2
 */
interface Point extends GeoJsonObject {
    type: "Point";
    coordinates: Position;
}

/**
 * MultiPoint geometry object.
 *  https://tools.ietf.org/html/rfc7946#section-3.1.3
 */
interface MultiPoint extends GeoJsonObject {
    type: "MultiPoint";
    coordinates: Position[];
}

/**
 * LineString geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.4
 */
interface LineString extends GeoJsonObject {
    type: "LineString";
    coordinates: Position[];
}

/**
 * MultiLineString geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.5
 */
interface MultiLineString extends GeoJsonObject {
    type: "MultiLineString";
    coordinates: Position[][];
}

/**
 * Polygon geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.6
 */
interface Polygon extends GeoJsonObject {
    type: "Polygon";
    coordinates: Position[][];
}

/**
 * MultiPolygon geometry object.
 * https://tools.ietf.org/html/rfc7946#section-3.1.7
 */
interface MultiPolygon extends GeoJsonObject {
    type: "MultiPolygon";
    coordinates: Position[][][];
}

/**
 * Geometry Collection
 * https://tools.ietf.org/html/rfc7946#section-3.1.8
 */
interface GeometryCollection<G extends Geometry = Geometry> extends GeoJsonObject {
    type: "GeometryCollection";
    geometries: G[];
}

type GeoJsonProperties = { [name: string]: any } | null;

/**
 * A feature object which contains a geometry and associated properties.
 * https://tools.ietf.org/html/rfc7946#section-3.2
 */
interface Feature$1<G extends Geometry | null = Geometry, P = GeoJsonProperties> extends GeoJsonObject {
    type: "Feature";
    /**
     * The feature's geometry
     */
    geometry: G;
    /**
     * A value that uniquely identifies this feature in a
     * https://tools.ietf.org/html/rfc7946#section-3.2.
     */
    id?: string | number | undefined;
    /**
     * Properties associated with this feature.
     */
    properties: P;
}

/**
 * A collection of feature objects.
 *  https://tools.ietf.org/html/rfc7946#section-3.3
 */
interface FeatureCollection<G extends Geometry | null = Geometry, P = GeoJsonProperties> extends GeoJsonObject {
    type: "FeatureCollection";
    features: Array<Feature$1<G, P>>;
}

type GeoJSONFeature = Feature$1;
type GeoJSONFeatureCollection = FeatureCollection;
type GeoJSONGeometry = Geometry;
type GeoJSONGeometryCollection = GeometryCollection;
type Options$1p<FeatureType extends FeatureLike = Feature$2<Geometry$1>> = {
    /**
     * Default data projection.
     */
    dataProjection?: ProjectionLike;
    /**
     * Projection for features read or
     * written by the format.  Options passed to read or write methods will take precedence.
     */
    featureProjection?: ProjectionLike;
    /**
     * Geometry name to use when creating features.
     */
    geometryName?: string | undefined;
    /**
     * Certain GeoJSON providers include
     * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
     * will look for that field to set the geometry name. If both this field is set to `true`
     * and a `geometryName` is provided, the `geometryName` will take precedence.
     */
    extractGeometryName?: boolean | undefined;
    /**
     * Feature class
     * to be used when reading features. The default is {@link module :ol/Feature~Feature}. If performance is
     * the primary concern, and features are not going to be modified or round-tripped through the format,
     * consider using {@link module :ol/render/Feature~RenderFeature}
     */
    featureClass?: FeatureToFeatureClass<FeatureType> | undefined;
};
/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */
/**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @typedef {Object} Options
 *
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Feature class
 * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is
 * the primary concern, and features are not going to be modified or round-tripped through the format,
 * consider using {@link module:ol/render/Feature~RenderFeature}
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("../Feature.js").default]
 * @extends {JSONFeature<FeatureType>}
 * @api
 */
declare class GeoJSON<FeatureType extends FeatureLike = Feature$2<Geometry$1>> extends JSONFeature<FeatureType> {
    /**
     * @param {Options<FeatureType>} [options] Options.
     */
    constructor(options?: Options$1p<FeatureType>);
    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */
    private geometryName_;
    /**
     * Look for the `geometry_name` in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */
    private extractGeometryName_;
    /**
     * @param {GeoJSONGeometry} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    protected override readGeometryFromObject(object: GeoJSONGeometry, options?: ReadOptions): Geometry$1;
    /**
     * Encode a feature as a GeoJSON Feature object.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONFeature} Object.
     * @api
     * @override
     */
    override writeFeatureObject(feature: Feature$2, options?: WriteOptions): GeoJSONFeature;
    /**
     * Encode an array of features as a GeoJSON object.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONFeatureCollection} GeoJSON Object.
     * @api
     * @override
     */
    override writeFeaturesObject(features: Array<Feature$2>, options?: WriteOptions): GeoJSONFeatureCollection;
    /**
     * Encode a geometry as a GeoJSON object.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
     * @api
     * @override
     */
    override writeGeometryObject(geometry: Geometry$1, options?: WriteOptions): GeoJSONGeometry | GeoJSONGeometryCollection;
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for text feature formats.
 *
 * @abstract
 */
declare class TextFeature extends FeatureFormat<Feature$2<Geometry$1>> {
    constructor();
    /**
     * Read the feature from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     * @override
     */
    override readFeature(source: Document | Element | any | string, options?: ReadOptions): Feature$2;
    /**
     * @abstract
     * @param {string} text Text.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     */
    protected readFeatureFromText(text: string, options?: ReadOptions): Feature$2;
    /**
     * @abstract
     * @param {string} text Text.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    protected readFeaturesFromText(text: string, options?: ReadOptions): Array<Feature$2>;
    /**
     * @abstract
     * @param {string} text Text.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    protected readGeometryFromText(text: string, options?: ReadOptions): Geometry$1;
    /**
     * @param {string} text Text.
     * @protected
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    protected readProjectionFromText(text: string): Projection | undefined;
    /**
     * Encode a feature as a string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @api
     * @override
     */
    override writeFeature(feature: Feature$2, options?: WriteOptions): string;
    /**
     * @abstract
     * @param {import("../Feature.js").default} feature Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @protected
     * @return {string} Text.
     */
    protected writeFeatureText(feature: Feature$2, options?: WriteOptions): string;
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded features.
     * @api
     * @override
     */
    override writeFeatures(features: Array<Feature$2>, options?: WriteOptions): string;
    /**
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @protected
     * @return {string} Text.
     */
    protected writeFeaturesText(features: Array<Feature$2>, options?: WriteOptions): string;
    /**
     * Write a single geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Geometry.
     * @api
     * @override
     */
    override writeGeometry(geometry: Geometry$1, options?: WriteOptions): string;
    /**
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @protected
     * @return {string} Text.
     */
    protected writeGeometryText(geometry: Geometry$1, options?: WriteOptions): string;
}
//# sourceMappingURL=TextFeature.d.ts.map

/**
 * IGC altitude/z. One of 'barometric', 'gps', 'none'.
 */
type IGCZ = "barometric" | "gps" | "none";
type Options$1o = {
    /**
     * Altitude mode. Possible
     * values are `'barometric'`, `'gps'`, and `'none'`.
     */
    altitudeMode?: IGCZ | undefined;
};
/**
 * @typedef {Object} Options
 * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible
 * values are `'barometric'`, `'gps'`, and `'none'`.
 */
/**
 * @classdesc
 * Feature format for `*.igc` flight recording files.
 *
 * As IGC sources contain a single feature,
 * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an
 * array
 *
 * @api
 */
declare class IGC extends TextFeature {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1o);
    /**
     * @private
     * @type {IGCZ}
     */
    private altitudeMode_;
    /**
     * @private
     * @type {boolean}
     */
    private lad_;
    /**
     * @private
     * @type {boolean}
     */
    private lod_;
    /**
     * @private
     * @type {number}
     */
    private ladStart_;
    /**
     * @private
     * @type {number}
     */
    private ladStop_;
    /**
     * @private
     * @type {number}
     */
    private lodStart_;
    /**
     * @private
     * @type {number}
     */
    private lodStop_;
}

type Options$1n = {
    /**
     * Extent for the tile grid. No tiles
     * outside this extent will be requested by {@link module :ol/source/Tile~TileSource} sources.
     * When no `origin` or `origins` are configured, the `origin` will be set to the
     * top-left corner of the extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The tile grid origin, i.e.
     * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
     * to right and downwards. If not specified, `extent` or `origins` must be provided.
     */
    origin?: Coordinate | undefined;
    /**
     * Tile grid origins,
     * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
     * given, the array length should match the length of the `resolutions` array, i.e.
     * each resolution can have a different origin. Tile coordinates increase left to
     * right and downwards. If not specified, `extent` or `origin` must be provided.
     */
    origins?: Coordinate[] | undefined;
    /**
     * Resolutions. The array index of each
     * resolution needs to match the zoom level. This means that even if a `minZoom`
     * is configured, the resolutions array will have a length of `maxZoom + 1`
     */
    resolutions: Array<number>;
    /**
     * matrix IDs. The length of this array needs
     * to match the length of the `resolutions` array.
     */
    matrixIds: Array<string>;
    /**
     * Number of tile rows and columns
     * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
     * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
     * define each zoom level's extent together with the `origin` or `origins`.
     * A grid `extent` can be configured in addition, and will further limit the extent for
     * which tile requests are made by sources. If the bottom-left corner of
     * an extent is used as `origin` or `origins`, then the `y` value must be
     * negative because OpenLayers tile coordinates use the top left as the origin.
     */
    sizes?: Size[] | undefined;
    /**
     * Tile size.
     */
    tileSize?: number | Size | undefined;
    /**
     * Tile sizes. The length of
     * this array needs to match the length of the `resolutions` array.
     */
    tileSizes?: (number | Size)[] | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and downwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and downwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 */
/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */
declare class WMTSTileGrid extends TileGrid {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(options: Options$1n);
    /**
     * @private
     * @type {!Array<string>}
     */
    private matrixIds_;
    /**
     * @param {number} z Z.
     * @return {string} MatrixId..
     */
    getMatrixId(z: number): string;
    /**
     * Get the list of matrix identifiers.
     * @return {Array<string>} MatrixIds.
     * @api
     */
    getMatrixIds(): Array<string>;
}

/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
declare function getForProjection(projection: Projection): TileGrid;
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
declare function wrapX(tileGrid: TileGrid, tileCoord: TileCoord, projection: Projection): TileCoord;
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
declare function createForExtent(extent: Extent$1, maxZoom?: number, tileSize?: number | Size, corner?: Corner): TileGrid;
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */
/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
declare function createXYZ(options?: XYZOptions): TileGrid;
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
declare function createForProjection(projection: ProjectionLike, maxZoom?: number, tileSize?: number | Size, corner?: Corner): TileGrid;
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
declare function extentFromProjection(projection: ProjectionLike): Extent$1;

type XYZOptions = {
    /**
     * Extent for the tile grid. The origin for an XYZ tile grid is the
     * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
     * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
     */
    extent?: Extent$1 | undefined;
    /**
     * Resolution at level zero.
     */
    maxResolution?: number | undefined;
    /**
     * Maximum zoom. The default is `42`. This determines the number of levels
     * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
     */
    maxZoom?: number | undefined;
    /**
     * Minimum zoom.
     */
    minZoom?: number | undefined;
    /**
     * Tile size in pixels.
     */
    tileSize?: number | Size | undefined;
};

type TileSourceEventTypes = "tileloadstart" | "tileloadend" | "tileloaderror";

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
declare class TileSourceEvent extends BaseEvent {
    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */
    constructor(type: string, tile: Tile$1);
    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    tile: Tile$1;
}

/**
 * *
 */
type TileSourceOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2, ObjectEvent, Return> & OnSignature<TileSourceEventTypes, TileSourceEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | TileSourceEventTypes, Return>;
type Options$1m = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * TilePixelRatio.
     */
    tilePixelRatio?: number | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * State.
     */
    state?: State$2 | undefined;
    /**
     * TileGrid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * WrapX.
     */
    wrapX?: boolean | undefined;
    /**
     * Transition.
     */
    transition?: number | undefined;
    /**
     * Key.
     */
    key?: string | undefined;
    /**
     * ZDirection.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
};

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @template {import("../Tile.js").default} [TileType=import("../Tile.js").default]
 * @abstract
 * @api
 */
declare class TileSource<TileType extends Tile$1 = Tile$1> extends Source {
    /**
     * @param {Options} options SourceTile source options.
     */
    constructor(options: Options$1m);
    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    on: TileSourceOnSignature<EventsKey>;
    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    once: TileSourceOnSignature<EventsKey>;
    /***
     * @type {TileSourceOnSignature<void>}
     */
    un: TileSourceOnSignature<void>;
    /**
     * @private
     * @type {number}
     */
    private tilePixelRatio_;
    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     * @protected
     */
    protected tileGrid: TileGrid | null;
    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    protected tmpSize: Size;
    /**
     * @private
     * @type {string}
     */
    private key_;
    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    protected tileOptions: Options$1Q;
    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    zDirection: number | NearestDirectionFunction;
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
    getGutterForProjection(projection: Projection): number;
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
    getKey(): string;
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */
    protected setKey(key: string): void;
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {TileType|null} Tile.
     */
    getTile(z: number, x: number, y: number, pixelRatio: number, projection: Projection): TileType | null;
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */
    getTileGrid(): TileGrid | null;
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
    getTileGridForProjection(projection: Projection): TileGrid;
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
    getTilePixelRatio(pixelRatio: number): number;
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
    getTilePixelSize(z: number, pixelRatio: number, projection: Projection): Size;
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */
    getTileCoordForTileUrlFunction(tileCoord: TileCoord, projection?: Projection): TileCoord;
    /**
     * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
     * @api
     */
    clear(): void;
}

type Options$1l = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * State.
     */
    state?: State$2 | undefined;
    /**
     * TileGrid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * TileLoadFunction.
     */
    tileLoadFunction: LoadFunction$1;
    /**
     * TilePixelRatio.
     */
    tilePixelRatio?: number | undefined;
    /**
     * Deprecated.  Use an ImageTile source and provide a function
     * for the url option instead.
     */
    tileUrlFunction?: UrlFunction | undefined;
    /**
     * Url.
     */
    url?: string | undefined;
    /**
     * Urls.
     */
    urls?: string[] | undefined;
    /**
     * WrapX.
     */
    wrapX?: boolean | undefined;
    /**
     * Transition.
     */
    transition?: number | undefined;
    /**
     * Key.
     */
    key?: string | undefined;
    /**
     * ZDirection.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function
 * for the url option instead.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @deprecated Use the ol/source/ImageTile.js instead.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
declare class UrlTile extends TileSource<Tile$1> {
    /**
     * @param {Options} options Image tile options.
     */
    constructor(options: Options$1l);
    /**
     * @private
     * @type {boolean}
     */
    private generateTileUrlFunction_;
    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    protected tileLoadFunction: LoadFunction$1;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    tileUrlFunction(tileCoord: TileCoord, pixelRatio: number, projection: Projection): string | undefined;
    /**
     * @protected
     * @type {!Array<string>|null}
     */
    protected urls: Array<string> | null;
    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    private tileLoadingKeys_;
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile load function of the source.
     * @return {import("../Tile.js").LoadFunction} TileLoadFunction
     * @api
     */
    getTileLoadFunction(): LoadFunction$1;
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */
    getTileUrlFunction(): UrlFunction;
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */
    getUrls(): Array<string> | null;
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    protected handleTileChange(event: BaseEvent): void;
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */
    setTileLoadFunction(tileLoadFunction: LoadFunction$1): void;
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */
    setTileUrlFunction(tileUrlFunction: UrlFunction, key?: string): void;
    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */
    setUrl(url: string): void;
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */
    setUrls(urls: Array<string>): void;
}

type FunctionType$2 = (arg0: number, arg1: number, arg2: number, arg3: number) => (ImageTile);
/**
 * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType
 */
/**
 * @typedef {Object} TileOffset
 * @property {import("../ImageTile.js").default} tile Tile.
 * @property {number} offset Offset.
 */
/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
declare class ReprojTile extends Tile$1 {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
     * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} gutter Gutter of the source tiles.
     * @param {FunctionType} getTileFunction
     *     Function returning source tiles (z, x, y, pixelRatio).
     * @param {number} [errorThreshold] Acceptable reprojection error (in px).
     * @param {boolean} [renderEdges] Render reprojection edges.
     * @param {import("../Tile.js").Options} [options] Tile options.
     */
    constructor(sourceProj: Projection, sourceTileGrid: TileGrid, targetProj: Projection, targetTileGrid: TileGrid, tileCoord: TileCoord, wrappedTileCoord: TileCoord, pixelRatio: number, gutter: number, getTileFunction: FunctionType$2, errorThreshold?: number, renderEdges?: boolean, options?: Options$1Q);
    /**
     * @private
     * @type {boolean}
     */
    private renderEdges_;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @private
     * @type {number}
     */
    private gutter_;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    private canvas_;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    private sourceTileGrid_;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    private targetTileGrid_;
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    private wrappedTileCoord_;
    /**
     * @private
     * @type {!Array<TileOffset>}
     */
    private sourceTiles_;
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    private sourcesListenerKeys_;
    /**
     * @private
     * @type {number}
     */
    private sourceZ_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private clipExtent_;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    private triangulation_;
    /**
     * Get the HTML Canvas element for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    getImage(): HTMLCanvasElement;
    /**
     * @private
     */
    private reproject_;
    /**
     * @private
     */
    private unlistenSources_;
}

type Options$1k = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Source state.
     */
    state?: State$2 | undefined;
    /**
     * Class used to instantiate image tiles.
     * Default is {@link module :ol/ImageTile~ImageTile}.
     */
    tileClass?: typeof ImageTile | undefined;
    /**
     * Tile grid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * The pixel ratio used by the tile service. For example, if the tile
     * service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     */
    tilePixelRatio?: number | undefined;
    /**
     * Deprecated.  Use an ImageTile source and provide a function
     * for the url option instead.
     */
    tileUrlFunction?: UrlFunction | undefined;
    /**
     * URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
     * used instead of defining each one separately in the `urls` option.
     */
    url?: string | undefined;
    /**
     * An array of URL templates.
     */
    urls?: string[] | undefined;
    /**
     * Whether to wrap the world horizontally. The default, is to
     * request out-of-bounds tiles from the server. When set to `false`, only one
     * world will be rendered. When set to `true`, tiles will be requested for one
     * world only, but they will be wrapped horizontally to render multiple worlds.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Optional tile key for proper cache fetching
     */
    key?: string | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function
 * for the url option instead.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @deprecated Use the ol/source/ImageTile.js instead.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
declare class TileImage extends UrlTile {
    /**
     * @param {!Options} options Image tile options.
     */
    constructor(options: Options$1k);
    /**
     * @protected
     * @type {?string}
     */
    protected crossOrigin: string | null;
    /**
     * @protected
     * @type {typeof ImageTile}
     */
    protected tileClass: typeof ImageTile;
    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    protected tileGridForProjection: {
        [x: string]: TileGrid;
    };
    /**
     * @private
     * @type {number|undefined}
     */
    private reprojectionErrorThreshold_;
    /**
     * @private
     * @type {boolean}
     */
    private renderReprojectionEdges_;
    /**
     * @return {number} Gutter.
     */
    getGutter(): number;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */
    private createTile_;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     * @override
     */
    override getTile(z: number, x: number, y: number, pixelRatio: number, projection: Projection): (ImageTile | ReprojTile);
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!ImageTile} Tile.
     * @protected
     */
    protected getTileInternal(z: number, x: number, y: number, pixelRatio: number, projection: Projection): ImageTile;
    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */
    setRenderReprojectionEdges(render: boolean): void;
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
    setTileGridForProjection(projection: ProjectionLike, tilegrid: TileGrid): void;
}

type Options$1j = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The value for the crossOrigin option of the request.
     */
    crossOrigin?: string | null | undefined;
    /**
     * The extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * Requested image format.
     */
    format?: string | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * Requested IIIF image quality. Default is 'native'
     * for version 1, 'default' for versions 2 and 3.
     */
    quality?: string | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Supported resolutions as given in IIIF 'scaleFactors'
     */
    resolutions?: number[] | undefined;
    /**
     * Size of the image [width, height].
     */
    size: Size;
    /**
     * Supported scaled image sizes.
     * Content of the IIIF info.json 'sizes' property, but as array of Size objects.
     */
    sizes?: Size[] | undefined;
    /**
     * Source state.
     */
    state?: State$2 | undefined;
    /**
     * Supported IIIF region and size calculation
     * features.
     */
    supports?: string[] | undefined;
    /**
     * Tile pixel ratio.
     */
    tilePixelRatio?: number | undefined;
    /**
     * Tile size.
     * Same tile size is used for all zoom levels. If tile size is a number,
     * a square tile is assumed. If the IIIF image service supports arbitrary
     * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct
     * are supported), the default tilesize is 256.
     */
    tileSize?: number | Size | undefined;
    /**
     * Transition.
     */
    transition?: number | undefined;
    /**
     * Base URL of the IIIF Image service.
     * This should be the same as the IIIF Image ID.
     */
    url?: string | undefined;
    /**
     * Service's IIIF Image API version.
     */
    version?: string | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @classdesc
 * Layer source for IIIF Image API services.
 * @api
 */
declare class IIIF extends TileImage {
    /**
     * @param {Options} [options] Tile source options. Use {@link import("../format/IIIFInfo.js").IIIFInfo}
     * to parse Image API service information responses into constructor options.
     * @api
     */
    constructor(options?: Options$1j);
}

/**
 * Enum representing the major IIIF Image API versions
 */
type Versions = string;
declare namespace Versions {
    let VERSION1: string;
    let VERSION2: string;
    let VERSION3: string;
}

type PreferredOptions = {
    /**
     * Preferred image format. Will be used if the image information
     * indicates support for that format.
     */
    format?: string | undefined;
    /**
     * IIIF image qualitiy.  Will be used if the image information
     * indicates support for that quality.
     */
    quality?: string | undefined;
};
type SupportedFeatures = {
    /**
     * Supported IIIF image size and region
     * calculation features.
     */
    supports?: string[] | undefined;
    /**
     * Supported image formats.
     */
    formats?: string[] | undefined;
    /**
     * Supported IIIF image qualities.
     */
    qualities?: string[] | undefined;
};
type TileInfo = {
    /**
     * Supported resolution scaling factors.
     */
    scaleFactors: Array<number>;
    /**
     * Tile width in pixels.
     */
    width: number;
    /**
     * Tile height in pixels. Same as tile width if height is
     * not given.
     */
    height?: number | undefined;
};
type IiifProfile = {
    /**
     * Supported image formats for the image service.
     */
    formats?: string[] | undefined;
    /**
     * Supported IIIF image qualities.
     */
    qualities?: string[] | undefined;
    /**
     * Supported features.
     */
    supports?: string[] | undefined;
    /**
     * Maximum area (pixels) available for this image service.
     */
    maxArea?: number | undefined;
    /**
     * Maximum height.
     */
    maxHeight?: number | undefined;
    /**
     * Maximum width.
     */
    maxWidth?: number | undefined;
};
type ImageInformationResponse = {
    [x: string]: string | number | (string | number | IiifProfile | {
        [x: string]: number;
    } | TileInfo)[];
};
/**
 * @classdesc
 * Format for transforming IIIF Image API image information responses into
 * IIIF tile source ready options
 *
 * @api
 */
declare class IIIFInfo {
    /**
     * @param {string|ImageInformationResponse} imageInfo
     * Deserialized image information JSON response object or JSON response as string
     */
    constructor(imageInfo: string | ImageInformationResponse);
    /**
     * @param {string|ImageInformationResponse} imageInfo
     * Deserialized image information JSON response object or JSON response as string
     * @api
     */
    setImageInfo(imageInfo: string | ImageInformationResponse): void;
    imageInfo: any;
    /**
     * @return {Versions|undefined} Major IIIF version.
     * @api
     */
    getImageApiVersion(): Versions | undefined;
    /**
     * @param {Versions} version Optional IIIF image API version
     * @return {string|undefined} Compliance level as it appears in the IIIF image information
     * response.
     */
    getComplianceLevelEntryFromProfile(version: Versions): string | undefined;
    /**
     * @param {Versions} version Optional IIIF image API version
     * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined
     */
    getComplianceLevelFromProfile(version: Versions): string;
    /**
     * @return {SupportedFeatures|undefined} Image formats, qualities and region / size calculation
     * methods that are supported by the IIIF service.
     */
    getComplianceLevelSupportedFeatures(): SupportedFeatures | undefined;
    /**
     * @param {PreferredOptions} [preferredOptions] Optional options for preferred format and quality.
     * @return {import("../source/IIIF.js").Options|undefined} IIIF tile source ready constructor options.
     * @api
     */
    getTileSourceOptions(preferredOptions?: PreferredOptions): Options$1j | undefined;
}

/**
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */
type IconAnchorUnits = "fraction" | "pixels";
/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */
type IconOrigin = "bottom-left" | "bottom-right" | "top-left" | "top-right";
type Options$1i = {
    /**
     * Anchor. Default value is the icon center.
     */
    anchor?: number[] | undefined;
    /**
     * Origin of the anchor: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    anchorOrigin?: IconOrigin | undefined;
    /**
     * Units in which the anchor x value is
     * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
     * the x value in pixels.
     */
    anchorXUnits?: IconAnchorUnits | undefined;
    /**
     * Units in which the anchor y value is
     * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
     * the y value in pixels.
     */
    anchorYUnits?: IconAnchorUnits | undefined;
    /**
     * Color to tint the icon. If not specified,
     * the icon will be left as is.
     */
    color?: string | Color | undefined;
    /**
     * The `crossOrigin` attribute for loaded images. Note that you must provide a
     * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Image object for the icon.
     */
    img?: HTMLCanvasElement | HTMLImageElement | ImageBitmap | undefined;
    /**
     * Displacement of the icon in pixels.
     * Positive values will shift the icon right and up.
     */
    displacement?: number[] | undefined;
    /**
     * Opacity of the icon.
     */
    opacity?: number | undefined;
    /**
     * The width of the icon in pixels. This can't be used together with `scale`.
     */
    width?: number | undefined;
    /**
     * The height of the icon in pixels. This can't be used together with `scale`.
     */
    height?: number | undefined;
    /**
     * Scale.
     */
    scale?: number | Size | undefined;
    /**
     * Whether to rotate the icon with the view.
     */
    rotateWithView?: boolean | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    rotation?: number | undefined;
    /**
     * Offset which, together with `size` and `offsetOrigin`, defines the
     * sub-rectangle to use from the original (sprite) image.
     */
    offset?: number[] | undefined;
    /**
     * Origin of the offset: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    offsetOrigin?: IconOrigin | undefined;
    /**
     * Icon size in pixels. Used together with `offset` to define the
     * sub-rectangle to use from the original (sprite) image.
     */
    size?: Size | undefined;
    /**
     * Image source URI.
     */
    src?: string | undefined;
    /**
     * Declutter mode.
     */
    declutterMode?: DeclutterMode | undefined;
};
/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
declare class Icon extends ImageStyle {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1i);
    /**
     * @private
     * @type {Array<number>}
     */
    private anchor_;
    /**
     * @private
     * @type {Array<number>}
     */
    private normalizedAnchor_;
    /**
     * @private
     * @type {IconOrigin}
     */
    private anchorOrigin_;
    /**
     * @private
     * @type {IconAnchorUnits}
     */
    private anchorXUnits_;
    /**
     * @private
     * @type {IconAnchorUnits}
     */
    private anchorYUnits_;
    /**
     * @private
     * @type {?string}
     */
    private crossOrigin_;
    /**
     * @private
     * @type {import("../color.js").Color}
     */
    private color_;
    /**
     * @private
     * @type {import("./IconImage.js").default}
     */
    private iconImage_;
    /**
     * @private
     * @type {Array<number>}
     */
    private offset_;
    /**
     * @private
     * @type {IconOrigin}
     */
    private offsetOrigin_;
    /**
     * @private
     * @type {Array<number>}
     */
    private origin_;
    /**
     * @private
     * @type {import("../size.js").Size}
     */
    private size_;
    initialOptions_: Options$1i | undefined;
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     * @override
     */
    override clone(): Icon;
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
    setAnchor(anchor: Array<number>): void;
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
    getColor(): Color;
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
     * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
     * @api
     * @override
     */
    override getImage(pixelRatio: number): HTMLImageElement | HTMLCanvasElement | ImageBitmap;
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     * @override
     */
    override getHitDetectionImage(): HTMLImageElement | HTMLCanvasElement | ImageBitmap;
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
    getSrc(): string | undefined;
    /**
     * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon width (in pixels).
     * @api
     */
    getWidth(): number;
    /**
     * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon height (in pixels).
     * @api
     */
    getHeight(): number;
}

/**
 * A function that takes a url `{string}` and returns a url `{string}`.
 * Might be used to change an icon path or to substitute a
 * data url obtained from a KMZ array buffer.
 */
type IconUrlFunction = (arg0: string) => string;
type Options$1h = {
    /**
     * Extract styles from the KML.
     */
    extractStyles?: boolean | undefined;
    /**
     * Show names as labels for placemarks which contain points.
     */
    showPointNames?: boolean | undefined;
    /**
     * Default style. The
     * default default style is the same as Google Earth.
     */
    defaultStyle?: Style$2[] | undefined;
    /**
     * Write styles into KML.
     */
    writeStyles?: boolean | undefined;
    /**
     * The `crossOrigin` attribute for loaded images. Note that you must provide a
     * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Function that takes a url string and returns a url string.
     * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.
     */
    iconUrlFunction?: IconUrlFunction | undefined;
};

/**
 * @typedef {Object} Options
 * @property {boolean} [extractStyles=true] Extract styles from the KML.
 * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.
 * @property {Array<Style>} [defaultStyle] Default style. The
 * default default style is the same as Google Earth.
 * @property {boolean} [writeStyles=true] Write styles into KML.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.
 * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the KML format.
 *
 * {@link module:ol/format/KML~KML#readFeature} will read the first feature from
 * a KML source.
 *
 * MultiGeometries are converted into GeometryCollections if they are a mix of
 * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are
 * all of the same type.
 *
 * @api
 */
declare class KML extends XMLFeature {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1h);
    /**
     * @private
     * @type {Array<Style>}
     */
    private defaultStyle_;
    /**
     * @private
     * @type {boolean}
     */
    private extractStyles_;
    /**
     * @type {boolean}
     */
    writeStyles_: boolean;
    /**
     * @private
     * @type {!Object<string, (Array<Style>|string)>}
     */
    private sharedStyles_;
    /**
     * @private
     * @type {boolean}
     */
    private showPointNames_;
    /**
     * @type {null|string}
     */
    crossOrigin_: null | string;
    /**
     * @type {IconUrlFunction}
     */
    iconUrlFunction_: IconUrlFunction;
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     * @return {Array<Feature>|undefined} Features.
     */
    private readDocumentOrFolder_;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     * @return {Feature|undefined} Feature.
     */
    private readPlacemark_;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     */
    private readSharedStyle_;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     */
    private readSharedStyleMap_;
    /**
     * Read the name of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {string|undefined} Name.
     * @api
     */
    readName(source: Document | Element | string): string | undefined;
    /**
     * @param {Document} doc Document.
     * @return {string|undefined} Name.
     */
    readNameFromDocument(doc: Document): string | undefined;
    /**
     * @param {Element} node Node.
     * @return {string|undefined} Name.
     */
    readNameFromNode(node: Element): string | undefined;
    /**
     * Read the network links of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {Array<Object>} Network links.
     * @api
     */
    readNetworkLinks(source: Document | Element | string): Array<any>;
    /**
     * @param {Document} doc Document.
     * @return {Array<Object>} Network links.
     */
    readNetworkLinksFromDocument(doc: Document): Array<any>;
    /**
     * @param {Element} node Node.
     * @return {Array<Object>} Network links.
     */
    readNetworkLinksFromNode(node: Element): Array<any>;
    /**
     * Read the regions of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {Array<Object>} Regions.
     * @api
     */
    readRegion(source: Document | Element | string): Array<any>;
    /**
     * @param {Document} doc Document.
     * @return {Array<Object>} Region.
     */
    readRegionFromDocument(doc: Document): Array<any>;
    /**
     * @param {Element} node Node.
     * @return {Array<Object>} Region.
     * @api
     */
    readRegionFromNode(node: Element): Array<any>;
    /**
     * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.
     * @property {number} [Latitude] Latitude of the camera.
     * @property {number} [Longitude] Longitude of the camera.
     * @property {number} [Altitude] Altitude of the camera.
     * @property {string} [AltitudeMode] Floor-related altitude mode.
     * @property {number} [Heading] Horizontal camera rotation.
     * @property {number} [Tilt] Lateral camera rotation.
     * @property {number} [Roll] Vertical camera rotation.
     */
    /**
     * Read the cameras of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {Array<KMLCamera>} Cameras.
     * @api
     */
    readCamera(source: Document | Element | string): Array<{
        /**
         * Latitude of the camera.
         */
        Latitude?: number | undefined;
        /**
         * Longitude of the camera.
         */
        Longitude?: number | undefined;
        /**
         * Altitude of the camera.
         */
        Altitude?: number | undefined;
        /**
         * Floor-related altitude mode.
         */
        AltitudeMode?: string | undefined;
        /**
         * Horizontal camera rotation.
         */
        Heading?: number | undefined;
        /**
         * Lateral camera rotation.
         */
        Tilt?: number | undefined;
        /**
         * Vertical camera rotation.
         */
        Roll?: number | undefined;
    }>;
    /**
     * @param {Document} doc Document.
     * @return {Array<KMLCamera>} Cameras.
     */
    readCameraFromDocument(doc: Document): Array<{
        /**
         * Latitude of the camera.
         */
        Latitude?: number | undefined;
        /**
         * Longitude of the camera.
         */
        Longitude?: number | undefined;
        /**
         * Altitude of the camera.
         */
        Altitude?: number | undefined;
        /**
         * Floor-related altitude mode.
         */
        AltitudeMode?: string | undefined;
        /**
         * Horizontal camera rotation.
         */
        Heading?: number | undefined;
        /**
         * Lateral camera rotation.
         */
        Tilt?: number | undefined;
        /**
         * Vertical camera rotation.
         */
        Roll?: number | undefined;
    }>;
    /**
     * @param {Element} node Node.
     * @return {Array<KMLCamera>} Cameras.
     * @api
     */
    readCameraFromNode(node: Element): Array<{
        /**
         * Latitude of the camera.
         */
        Latitude?: number | undefined;
        /**
         * Longitude of the camera.
         */
        Longitude?: number | undefined;
        /**
         * Altitude of the camera.
         */
        Altitude?: number | undefined;
        /**
         * Floor-related altitude mode.
         */
        AltitudeMode?: string | undefined;
        /**
         * Horizontal camera rotation.
         */
        Heading?: number | undefined;
        /**
         * Lateral camera rotation.
         */
        Tilt?: number | undefined;
        /**
         * Vertical camera rotation.
         */
        Roll?: number | undefined;
    }>;
}

type Options$1g<FeatureType extends FeatureLike = RenderFeature> = {
    /**
     * Class for features returned by
     * {@link module :ol/format/MVT~MVT#readFeatures}. Set to {@link module :ol/Feature~Feature} to get full editing and geometry
     * support at the cost of decreased rendering performance. The default is
     * {@link module :ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.
     */
    featureClass?: FeatureToFeatureClass<FeatureType> | undefined;
    /**
     * Geometry name to use when creating features.
     */
    geometryName?: string | undefined;
    /**
     * Name of the feature attribute that holds the layer name.
     */
    layerName?: string | undefined;
    /**
     * Layers to read features from. If not provided, features will be read from all
     */
    layers?: string[] | undefined;
    /**
     * Optional property that will be assigned as the feature id and removed from the properties.
     * layers.
     */
    idProperty?: string | undefined;
};
/**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../render/Feature.js").default]
 * @typedef {Object} Options
 * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Class for features returned by
 * {@link module:ol/format/MVT~MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry
 * support at the cost of decreased rendering performance. The default is
 * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.
 * @property {string} [geometryName='geometry'] Geometry name to use when creating features.
 * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.
 * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all
 * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.
 * layers.
 */
/**
 * @classdesc
 * Feature format for reading data in the Mapbox MVT format.
 *
 * @template {import('../Feature.js').FeatureLike} [FeatureType=RenderFeature]
 * @extends {FeatureFormat<FeatureType>}
 * @api
 */
declare class MVT<FeatureType extends FeatureLike = RenderFeature> extends FeatureFormat<FeatureType> {
    /**
     * @param {Options<FeatureType>} [options] Options.
     */
    constructor(options?: Options$1g<FeatureType>);
    /**
     * @private
     * @type {string|undefined}
     */
    private geometryName_;
    /**
     * @private
     * @type {string}
     */
    private layerName_;
    /**
     * @private
     * @type {Array<string>|null}
     */
    private layers_;
    /**
     * @private
     * @type {string}
     */
    private idProperty_;
    /**
     * Read the raw geometry from the pbf offset stored in a raw feature's geometry
     * property.
     * @param {PBF} pbf PBF.
     * @param {Object} feature Raw feature.
     * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
     * @param {Array<number>} ends Array to store ends in.
     * @private
     */
    private readRawGeometry_;
    /**
     * @private
     * @param {PBF} pbf PBF
     * @param {Object} rawFeature Raw Mapbox feature.
     * @param {import("./Feature.js").ReadOptions} options Read options.
     * @return {FeatureType|null} Feature.
     */
    private createFeature_;
    /**
     * Read all features.
     *
     * @param {ArrayBuffer} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     * @api
     * @override
     */
    override readFeatures(source: ArrayBuffer, options?: ReadOptions): Array<FeatureType>;
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    override readProjection(source: Document | Element | any | string): Projection;
    /**
     * Sets the layers that features will be read from.
     * @param {Array<string>} layers Layers.
     * @api
     */
    setLayers(layers: Array<string>): void;
}

/**
 * @classdesc
 * Feature format for reading data in the
 * [OSMXML format](https://wiki.openstreetmap.org/wiki/OSM_XML).
 *
 * @api
 */
declare class OSMXML extends XMLFeature {
}
//# sourceMappingURL=OSMXML.d.ts.map

/**
 * @classdesc
 * Generic format for reading non-feature XML data
 *
 * @abstract
 */
declare class XML {
    /**
     * Read the source document.
     *
     * @param {Document|Element|string} source The XML source.
     * @return {Object|null} An object representing the source.
     * @api
     */
    read(source: Document | Element | string): any | null;
    /**
     * @param {Document} doc Document.
     * @return {Object|null} Object
     */
    readFromDocument(doc: Document): any | null;
    /**
     * @abstract
     * @param {Element} node Node.
     * @return {Object|null} Object
     */
    readFromNode(node: Element): any | null;
}
//# sourceMappingURL=XML.d.ts.map

declare class OWS extends XML {
}
//# sourceMappingURL=OWS.d.ts.map

type Options$1f = {
    /**
     * The factor by which the coordinates values will be scaled.
     */
    factor?: number | undefined;
    /**
     * Layout of the
     * feature geometries created by the format reader.
     */
    geometryLayout?: GeometryLayout | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the format reader.
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the Encoded
 * Polyline Algorithm Format.
 *
 * When reading features, the coordinates are assumed to be in two dimensions
 * and in [latitude, longitude] order.
 *
 * As Polyline sources contain a single feature,
 * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the
 * feature in an array.
 *
 * @api
 */
declare class Polyline extends TextFeature {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(options?: Options$1f);
    /**
     * @private
     * @type {number}
     */
    private factor_;
    /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */
    private geometryLayout_;
    /**
     * @param {import("../Feature.js").default<LineString>} feature Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @protected
     * @return {string} Text.
     * @override
     */
    protected override writeFeatureText(feature: Feature$2<LineString$1>, options?: WriteOptions): string;
    /**
     * @param {Array<import("../Feature.js").default<LineString>>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @protected
     * @return {string} Text.
     * @override
     */
    protected override writeFeaturesText(features: Array<Feature$2<LineString$1>>, options?: WriteOptions): string;
    /**
     * @param {LineString} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @protected
     * @return {string} Text.
     * @override
     */
    protected override writeGeometryText(geometry: LineString$1, options?: WriteOptions): string;
}

type Options$1e = {
    /**
     * Default data projection.
     */
    dataProjection?: ProjectionLike;
    /**
     * Set the name of the TopoJSON topology
     * `objects`'s children as feature property with the specified name. This means
     * that when set to `'layer'`, a topology like
     * ```
     * {
     * "type": "Topology",
     * "objects": {
     * "example": {
     * "type": "GeometryCollection",
     * "geometries": []
     * }
     * }
     * }
     * ```
     * will result in features that have a property `'layer'` set to `'example'`.
     * When not set, no property will be added to features.
     */
    layerName?: string | undefined;
    /**
     * Names of the TopoJSON topology's
     * `objects`'s children to read features from.  If not provided, features will
     * be read from all children.
     */
    layers?: string[] | undefined;
};
/**
 * @typedef {import("topojson-specification").Topology} TopoJSONTopology
 * @typedef {import("topojson-specification").GeometryCollection} TopoJSONGeometryCollection
 * @typedef {import("topojson-specification").GeometryObject} TopoJSONGeometry
 * @typedef {import("topojson-specification").Point} TopoJSONPoint
 * @typedef {import("topojson-specification").MultiPoint} TopoJSONMultiPoint
 * @typedef {import("topojson-specification").LineString} TopoJSONLineString
 * @typedef {import("topojson-specification").MultiLineString} TopoJSONMultiLineString
 * @typedef {import("topojson-specification").Polygon} TopoJSONPolygon
 * @typedef {import("topojson-specification").MultiPolygon} TopoJSONMultiPolygon
 */
/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {string} [layerName] Set the name of the TopoJSON topology
 * `objects`'s children as feature property with the specified name. This means
 * that when set to `'layer'`, a topology like
 * ```
 * {
 *   "type": "Topology",
 *   "objects": {
 *     "example": {
 *       "type": "GeometryCollection",
 *       "geometries": []
 *     }
 *   }
 * }
 * ```
 * will result in features that have a property `'layer'` set to `'example'`.
 * When not set, no property will be added to features.
 * @property {Array<string>} [layers] Names of the TopoJSON topology's
 * `objects`'s children to read features from.  If not provided, features will
 * be read from all children.
 */
/**
 * @classdesc
 * Feature format for reading data in the TopoJSON format.
 *
 * @api
 */
declare class TopoJSON extends JSONFeature<Feature$2<Geometry$1>> {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1e);
    /**
     * @private
     * @type {string|undefined}
     */
    private layerName_;
    /**
     * @private
     * @type {?Array<string>}
     */
    private layers_;
}

/**
 * @module ol/format/filter/Filter
 */
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature filters.
 *
 * @abstract
 */
declare class Filter {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     */
    constructor(tagName: string);
    /**
     * @private
     * @type {!string}
     */
    private tagName_;
    /**
     * The XML tag name for a filter.
     * @return {!string} Name.
     */
    getTagName(): string;
}
//# sourceMappingURL=Filter.d.ts.map

type Options$1d = {
    /**
     * The namespace URI used for features.
     */
    featureNS?: string | {
        [x: string]: string;
    } | undefined;
    /**
     * The feature type to parse. Only used for read operations.
     */
    featureType?: string | string[] | undefined;
    /**
     * The GML format to use to parse the response.
     * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.
     */
    gmlFormat?: GMLBase | undefined;
    /**
     * Optional schemaLocation to use for serialization, this will override the default.
     */
    schemaLocation?: string | undefined;
    /**
     * WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
     */
    version?: string | undefined;
};
type WriteGetFeatureOptions = {
    /**
     * The namespace URI used for features.
     */
    featureNS: string;
    /**
     * The prefix for the feature namespace.
     */
    featurePrefix: string;
    /**
     * The feature type names or FeatureType objects to
     * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are
     * ignored.).
     */
    featureTypes: Array<string | FeatureType$1>;
    /**
     * SRS name. No srsName attribute will be set on
     * geometries when this is not provided.
     */
    srsName?: string | undefined;
    /**
     * Handle.
     */
    handle?: string | undefined;
    /**
     * Output format.
     */
    outputFormat?: string | undefined;
    /**
     * Maximum number of features to fetch.
     */
    maxFeatures?: number | undefined;
    /**
     * Geometry name to use in a BBOX filter.
     */
    geometryName?: string | undefined;
    /**
     * Optional list of property names to serialize.
     */
    propertyNames?: string[] | undefined;
    /**
     * viewParams GeoServer vendor parameter.
     */
    viewParams?: string | undefined;
    /**
     * Start index to use for WFS paging. This is a
     * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.
     */
    startIndex?: number | undefined;
    /**
     * Number of features to retrieve when paging. This is a
     * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some
     * Web Feature Services have repurposed `maxfeatures` instead.
     */
    count?: number | undefined;
    /**
     * Extent to use for the BBOX filter. The `geometryName`
     * option must be set.
     */
    bbox?: Extent$1 | undefined;
    /**
     * Filter condition. See
     * {@link module :ol/format/filter} for more information.
     */
    filter?: Filter | undefined;
    /**
     * Indicates what response should be returned,
     * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.
     */
    resultType?: string | undefined;
};
type FeatureType$1 = {
    /**
     * The feature type name.
     */
    name: string;
    /**
     * Extent to use for the BBOX filter.
     */
    bbox: Extent$1;
    /**
     * Geometry name to use in the BBOX filter.
     */
    geometryName: string;
};
type WriteTransactionOptions = {
    /**
     * The namespace URI used for features.
     */
    featureNS: string;
    /**
     * The prefix for the feature namespace.
     */
    featurePrefix: string;
    /**
     * The feature type name.
     */
    featureType: string;
    /**
     * SRS name. No srsName attribute will be set on
     * geometries when this is not provided.
     */
    srsName?: string | undefined;
    /**
     * Handle.
     */
    handle?: string | undefined;
    /**
     * Must be set to true if the transaction is for
     * a 3D layer. This will allow the Z coordinate to be included in the transaction.
     */
    hasZ?: boolean | undefined;
    /**
     * Native elements. Currently not supported.
     */
    nativeElements: Array<any>;
    /**
     * GML options for the WFS transaction writer.
     */
    gmlOptions?: Options$1r | undefined;
    /**
     * WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
     */
    version?: string | undefined;
};
/**
 * Number of features; bounds/extent.
 */
type FeatureCollectionMetadata = {
    /**
     * NumberOfFeatures.
     */
    numberOfFeatures: number;
    /**
     * Bounds.
     */
    bounds: Extent$1;
};
type TransactionSummary = {
    /**
     * TotalDeleted.
     */
    totalDeleted: number;
    /**
     * TotalInserted.
     */
    totalInserted: number;
    /**
     * TotalUpdated.
     */
    totalUpdated: number;
};
/**
 * Total deleted; total inserted; total updated; array of insert ids.
 */
type TransactionResponse = {
    /**
     * Transaction summary.
     */
    transactionSummary: TransactionSummary;
    /**
     * InsertIds.
     */
    insertIds: Array<string>;
};
/**
 * @classdesc
 * Feature format for reading and writing data in the WFS format.
 * By default, supports WFS version 1.1.0. You can pass a GML format
 * as option to override the default.
 * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.
 *
 * @api
 */
declare class WFS extends XMLFeature {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(options?: Options$1d);
    /**
     * @private
     * @type {string}
     */
    private version_;
    /**
     * @private
     * @type {Array<string>|string|undefined}
     */
    private featureType_;
    /**
     * @private
     * @type {Object<string, string>|string|undefined}
     */
    private featureNS_;
    /**
     * @private
     * @type {GMLBase}
     */
    private gmlFormat_;
    /**
     * @private
     * @type {string}
     */
    private schemaLocation_;
    /**
     * @return {Array<string>|string|undefined} featureType
     */
    getFeatureType(): Array<string> | string | undefined;
    /**
     * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
     */
    setFeatureType(featureType: Array<string> | string | undefined): void;
    /**
     * Read transaction response of the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {TransactionResponse|undefined} Transaction response.
     * @api
     */
    readTransactionResponse(source: Document | Element | any | string): TransactionResponse | undefined;
    /**
     * Read feature collection metadata of the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {FeatureCollectionMetadata|undefined}
     *     FeatureCollection metadata.
     * @api
     */
    readFeatureCollectionMetadata(source: Document | Element | any | string): FeatureCollectionMetadata | undefined;
    /**
     * @param {Document} doc Document.
     * @return {FeatureCollectionMetadata|undefined}
     *     FeatureCollection metadata.
     */
    readFeatureCollectionMetadataFromDocument(doc: Document): FeatureCollectionMetadata | undefined;
    /**
     * @param {Element} node Node.
     * @return {FeatureCollectionMetadata|undefined}
     *     FeatureCollection metadata.
     */
    readFeatureCollectionMetadataFromNode(node: Element): FeatureCollectionMetadata | undefined;
    /**
     * @param {Document} doc Document.
     * @return {TransactionResponse|undefined} Transaction response.
     */
    readTransactionResponseFromDocument(doc: Document): TransactionResponse | undefined;
    /**
     * @param {Element} node Node.
     * @return {TransactionResponse|undefined} Transaction response.
     */
    readTransactionResponseFromNode(node: Element): TransactionResponse | undefined;
    /**
     * Encode format as WFS `GetFeature` and return the Node.
     *
     * @param {WriteGetFeatureOptions} options Options.
     * @return {Node} Result.
     * @api
     */
    writeGetFeature(options: WriteGetFeatureOptions): Node;
    /**
     * Create a bbox filter and combine it with another optional filter.
     *
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../extent.js").Extent} extent Extent.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     * @param {import("./filter/Filter.js").default} [filter] Filter condition.
     * @return {import("./filter/Filter.js").default} The filter.
     */
    combineBboxAndFilter(geometryName: string, extent: Extent$1, srsName?: string, filter?: Filter): Filter;
    /**
     * Encode format as WFS `Transaction` and return the Node.
     *
     * @param {Array<import("../Feature.js").default>} inserts The features to insert.
     * @param {Array<import("../Feature.js").default>} updates The features to update.
     * @param {Array<import("../Feature.js").default>} deletes The features to delete.
     * @param {WriteTransactionOptions} options Write options.
     * @return {Node} Result.
     * @api
     */
    writeTransaction(inserts: Array<Feature$2>, updates: Array<Feature$2>, deletes: Array<Feature$2>, options: WriteTransactionOptions): Node;
}

type Options$1c = {
    /**
     * Whether to split GeometryCollections into multiple features on reading.
     */
    splitCollection?: boolean | undefined;
    /**
     * Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.
     */
    hex?: boolean | undefined;
    /**
     * Use littleEndian for output.
     */
    littleEndian?: boolean | undefined;
    /**
     * Use EWKB format for output.
     */
    ewkb?: boolean | undefined;
    /**
     * Use specific coordinate layout for output features (null: auto detect)
     */
    geometryLayout?: GeometryLayout | undefined;
    /**
     * If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.
     */
    nodataZ?: number | undefined;
    /**
     * If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.
     */
    nodataM?: number | undefined;
    /**
     * SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.
     */
    srid?: number | boolean | undefined;
};
/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.
 * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.
 * @property {boolean} [littleEndian=true] Use littleEndian for output.
 * @property {boolean} [ewkb=true] Use EWKB format for output.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)
 * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.
 * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.
 * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.
 */
/**
 * @classdesc
 * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.
 * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.
 *
 * @api
 */
declare class WKB extends FeatureFormat<Feature$2<Geometry$1>> {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(options?: Options$1c);
    splitCollection: boolean;
    viewCache_: DataView<ArrayBufferLike> | null;
    hex_: boolean;
    littleEndian_: boolean;
    ewkb_: boolean;
    layout_: GeometryLayout | undefined;
    nodataZ_: number;
    nodataM_: number;
    srid_: number | boolean | undefined;
    /**
     * Read a single feature from a source.
     *
     * @param {string|ArrayBuffer|ArrayBufferView} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     * @override
     */
    override readFeature(source: string | ArrayBuffer | ArrayBufferView, options?: ReadOptions): Feature$2;
    /**
     * Read all features from a source.
     *
     * @param {string|ArrayBuffer|ArrayBufferView} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     * @override
     */
    override readFeatures(source: string | ArrayBuffer | ArrayBufferView, options?: ReadOptions): Array<Feature$2>;
    /**
     * Read a single geometry from a source.
     *
     * @param {string|ArrayBuffer|ArrayBufferView} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @api
     * @override
     */
    override readGeometry(source: string | ArrayBuffer | ArrayBufferView, options?: ReadOptions): Geometry$1;
    /**
     * Read the projection from a source.
     *
     * @param {string|ArrayBuffer|ArrayBufferView} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     * @api
     * @override
     */
    override readProjection(source: string | ArrayBuffer | ArrayBufferView): Projection | undefined;
}

type Options$1b = {
    /**
     * Whether to split GeometryCollections into
     * multiple features on reading.
     */
    splitCollection?: boolean | undefined;
};
/**
 * @classdesc
 * Geometry format for reading and writing data in the `WellKnownText` (WKT)
 * format.
 *
 * @api
 */
declare class WKT extends TextFeature {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1b);
    /**
     * Split GeometryCollection into multiple features.
     * @type {boolean}
     * @private
     */
    private splitCollection_;
    /**
     * Parse a WKT string.
     * @param {string} wkt WKT string.
     * @return {import("../geom/Geometry.js").default}
     *     The geometry created.
     * @private
     */
    private parse_;
}

/**
 * @typedef {Object} RootObject
 * @property {string} version Version
 * @property {boolean} v13 Whether version is 1.3 or higher
 */
/**
 * @classdesc
 * Format for reading WMS capabilities data
 *
 * @api
 */
declare class WMSCapabilities extends XML {
    /**
     * @type {string|undefined}
     */
    version: string | undefined;
}

type Options$1a = {
    /**
     * If set, only features of the given layers will be returned by the format when read.
     */
    layers?: string[] | undefined;
};
/**
 * @classdesc
 * Format for reading WMSGetFeatureInfo format. It uses
 * {@link module:ol/format/GML2~GML2} to read features.
 *
 * @api
 */
declare class WMSGetFeatureInfo extends XMLFeature {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1a);
    /**
     * @private
     * @type {string}
     */
    private featureNS_;
    /**
     * @private
     * @type {GML2}
     */
    private gmlFormat_;
    /**
     * @private
     * @type {Array<string>|null}
     */
    private layers_;
    /**
     * @return {Array<string>|null} layers
     */
    getLayers(): Array<string> | null;
    /**
     * @param {Array<string>|null} layers Layers to parse.
     */
    setLayers(layers: Array<string> | null): void;
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<import("../Feature.js").default>} Features.
     * @private
     */
    private readFeatures_;
}

/**
 * @classdesc
 * Format for reading WMTS capabilities data.
 *
 * @api
 */
declare class WMTSCapabilities extends XML {
    /**
     * @type {OWS}
     * @private
     */
    private owsParser_;
}
//# sourceMappingURL=WMTSCapabilities.d.ts.map

/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature n-ary logical filters.
 *
 * @abstract
 */
declare class LogicalNary extends Filter {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     * @param {Array<import("./Filter.js").default>} conditions Conditions.
     */
    constructor(tagName: string, conditions: Array<Filter>);
    /**
     * @type {Array<import("./Filter.js").default>}
     */
    conditions: Array<Filter>;
}
//# sourceMappingURL=LogicalNary.d.ts.map

/**
 * @classdesc
 * Represents a logical `<And>` operator between two or more filter conditions.
 *
 * @abstract
 */
declare class And extends LogicalNary {
    /**
     * @param {...import("./Filter.js").default} conditions Conditions.
     */
    constructor(...args: Filter[]);
}
//# sourceMappingURL=And.d.ts.map

/**
 * @classdesc
 * Represents a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @api
 */
declare class Bbox extends Filter {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../extent.js").Extent} extent Extent.
     * @param {string} [srsName] SRS name. No srsName attribute will be set
     * on geometries when this is not provided.
     */
    constructor(geometryName: string, extent: Extent$1, srsName?: string);
    /**
     * @type {!string}
     */
    geometryName: string;
    /**
     * @type {import("../../extent.js").Extent}
     */
    extent: Extent$1;
    /**
     * @type {string|undefined}
     */
    srsName: string | undefined;
}
//# sourceMappingURL=Bbox.d.ts.map

/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property comparison filters.
 *
 * @abstract
 */
declare class Comparison extends Filter {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     * @param {!string} propertyName Name of the context property to compare.
     */
    constructor(tagName: string, propertyName: string);
    /**
     * @type {!string}
     */
    propertyName: string;
}
//# sourceMappingURL=Comparison.d.ts.map

/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property binary comparison filters.
 *
 * @abstract
 */
declare class ComparisonBinary extends Comparison {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!(string|number)} expression The value to compare.
     * @param {boolean} [matchCase] Case-sensitive?
     */
    constructor(tagName: string, propertyName: string, expression: (string | number), matchCase?: boolean);
    /**
     * @type {!(string|number)}
     */
    expression: (string | number);
    /**
     * @type {boolean|undefined}
     */
    matchCase: boolean | undefined;
}
//# sourceMappingURL=ComparisonBinary.d.ts.map

/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Represents a spatial operator to test whether a geometry-valued property
 * relates to a given geometry.
 *
 * @abstract
 */
declare class Spatial extends Filter {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     */
    constructor(tagName: string, geometryName: string, geometry: Geometry$1, srsName?: string);
    /**
     * @type {!string}
     */
    geometryName: string;
    /**
     * @type {import("../../geom/Geometry.js").default}
     */
    geometry: Geometry$1;
    /**
     * @type {string|undefined}
     */
    srsName: string | undefined;
}
//# sourceMappingURL=Spatial.d.ts.map

/**
 * @classdesc
 * Represents a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 * @api
 */
declare class Contains extends Spatial {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     */
    constructor(geometryName: string, geometry: Geometry$1, srsName?: string);
}
//# sourceMappingURL=Contains.d.ts.map

/**
 * @classdesc
 * Represents a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 * @api
 */
declare class DWithin extends Spatial {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
     * @param {!number} distance Distance.
     * @param {!string} unit Unit.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     */
    constructor(geometryName: string, geometry: Geometry$1, distance: number, unit: string, srsName?: string);
    /**
     * @public
     * @type {!number}
     */
    public distance: number;
    /**
     * @public
     * @type {!string}
     */
    public unit: string;
}
//# sourceMappingURL=DWithin.d.ts.map

/**
 * @classdesc
 * Represents a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 * @api
 */
declare class Disjoint extends Spatial {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     */
    constructor(geometryName: string, geometry: Geometry$1, srsName?: string);
}
//# sourceMappingURL=Disjoint.d.ts.map

/**
 * @classdesc
 * Represents a `<During>` comparison operator.
 * @api
 */
declare class During extends Comparison {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!string} begin The begin date in ISO-8601 format.
     * @param {!string} end The end date in ISO-8601 format.
     */
    constructor(propertyName: string, begin: string, end: string);
    /**
     * @type {!string}
     */
    begin: string;
    /**
     * @type {!string}
     */
    end: string;
}
//# sourceMappingURL=During.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsEqualTo>` comparison operator.
 * @api
 */
declare class EqualTo extends ComparisonBinary {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!(string|number)} expression The value to compare.
     * @param {boolean} [matchCase] Case-sensitive?
     */
    constructor(propertyName: string, expression: (string | number), matchCase?: boolean);
}
//# sourceMappingURL=EqualTo.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThan>` comparison operator.
 * @api
 */
declare class GreaterThan extends ComparisonBinary {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!number} expression The value to compare.
     */
    constructor(propertyName: string, expression: number);
}
//# sourceMappingURL=GreaterThan.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 * @api
 */
declare class GreaterThanOrEqualTo extends ComparisonBinary {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!number} expression The value to compare.
     */
    constructor(propertyName: string, expression: number);
}
//# sourceMappingURL=GreaterThanOrEqualTo.d.ts.map

/**
 * @classdesc
 * Represents a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 * @api
 */
declare class Intersects extends Spatial {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     */
    constructor(geometryName: string, geometry: Geometry$1, srsName?: string);
}
//# sourceMappingURL=Intersects.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsBetween>` comparison operator.
 * @api
 */
declare class IsBetween extends Comparison {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!number} lowerBoundary The lower bound of the range.
     * @param {!number} upperBoundary The upper bound of the range.
     */
    constructor(propertyName: string, lowerBoundary: number, upperBoundary: number);
    /**
     * @type {!number}
     */
    lowerBoundary: number;
    /**
     * @type {!number}
     */
    upperBoundary: number;
}
//# sourceMappingURL=IsBetween.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsLike>` comparison operator.
 * @api
 */
declare class IsLike extends Comparison {
    /**
     * [constructor description]
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!string} pattern Text pattern.
     * @param {string} [wildCard] Pattern character which matches any sequence of
     *    zero or more string characters. Default is '*'.
     * @param {string} [singleChar] pattern character which matches any single
     *    string character. Default is '.'.
     * @param {string} [escapeChar] Escape character which can be used to escape
     *    the pattern characters. Default is '!'.
     * @param {boolean} [matchCase] Case-sensitive?
     */
    constructor(propertyName: string, pattern: string, wildCard?: string, singleChar?: string, escapeChar?: string, matchCase?: boolean);
    /**
     * @type {!string}
     */
    pattern: string;
    /**
     * @type {!string}
     */
    wildCard: string;
    /**
     * @type {!string}
     */
    singleChar: string;
    /**
     * @type {!string}
     */
    escapeChar: string;
    /**
     * @type {boolean|undefined}
     */
    matchCase: boolean | undefined;
}
//# sourceMappingURL=IsLike.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsNull>` comparison operator.
 * @api
 */
declare class IsNull extends Comparison {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     */
    constructor(propertyName: string);
}
//# sourceMappingURL=IsNull.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsLessThan>` comparison operator.
 * @api
 */
declare class LessThan extends ComparisonBinary {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!number} expression The value to compare.
     */
    constructor(propertyName: string, expression: number);
}
//# sourceMappingURL=LessThan.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 * @api
 */
declare class LessThanOrEqualTo extends ComparisonBinary {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!number} expression The value to compare.
     */
    constructor(propertyName: string, expression: number);
}
//# sourceMappingURL=LessThanOrEqualTo.d.ts.map

/**
 * @classdesc
 * Represents a logical `<Not>` operator for a filter condition.
 * @api
 */
declare class Not extends Filter {
    /**
     * @param {!import("./Filter.js").default} condition Filter condition.
     */
    constructor(condition: Filter);
    /**
     * @type {!import("./Filter.js").default}
     */
    condition: Filter;
}
//# sourceMappingURL=Not.d.ts.map

/**
 * @classdesc
 * Represents a `<PropertyIsNotEqualTo>` comparison operator.
 * @api
 */
declare class NotEqualTo extends ComparisonBinary {
    /**
     * @param {!string} propertyName Name of the context property to compare.
     * @param {!(string|number)} expression The value to compare.
     * @param {boolean} [matchCase] Case-sensitive?
     */
    constructor(propertyName: string, expression: (string | number), matchCase?: boolean);
}
//# sourceMappingURL=NotEqualTo.d.ts.map

/**
 * @classdesc
 * Represents a logical `<Or>` operator between two or more filter conditions.
 * @api
 */
declare class Or extends LogicalNary {
    /**
     * @param {...import("./Filter.js").default} conditions Conditions.
     */
    constructor(...args: Filter[]);
}
//# sourceMappingURL=Or.d.ts.map

/**
 * @classdesc
 *
 * @abstract
 */
declare class ResourceId extends Filter {
    /**
     * @type {!string}
     */
    rid: string;
}
//# sourceMappingURL=ResourceId.d.ts.map

/**
 * @classdesc
 * Represents a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 * @api
 */
declare class Within extends Spatial {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     */
    constructor(geometryName: string, geometry: Geometry$1, srsName?: string);
}
//# sourceMappingURL=Within.d.ts.map

/**
 * Create a logical `<And>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!And} `<And>` operator.
 * @api
 */
declare function and(...args: Filter[]): And;
/**
 * Create a logical `<Or>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!Or} `<Or>` operator.
 * @api
 */
declare function or(...args: Filter[]): Or;
/**
 * Represents a logical `<Not>` operator for a filter condition.
 *
 * @param {!import("./filter/Filter.js").default} condition Filter condition.
 * @return {!Not} `<Not>` operator.
 * @api
 */
declare function not(condition: Filter): Not;
/**
 * Create a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../extent.js").Extent} extent Extent.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Bbox} `<BBOX>` operator.
 * @api
 */
declare function bbox$1(geometryName: string, extent: Extent$1, srsName?: string): Bbox;
/**
 * Create a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Contains} `<Contains>` operator.
 * @api
 */
declare function contains(geometryName: string, geometry: Geometry$1, srsName?: string): Contains;
/**
 * Create a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Intersects} `<Intersects>` operator.
 * @api
 */
declare function intersects(geometryName: string, geometry: Geometry$1, srsName?: string): Intersects;
/**
 * Create a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Disjoint} `<Disjoint>` operator.
 * @api
 */
declare function disjoint(geometryName: string, geometry: Geometry$1, srsName?: string): Disjoint;
/**
 * Create a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Within} `<Within>` operator.
 * @api
 */
declare function within(geometryName: string, geometry: Geometry$1, srsName?: string): Within;
/**
 * Create a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {!number} distance Distance.
 * @param {!string} unit Unit.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!DWithin} `<DWithin>` operator.
 * @api
 */
declare function dwithin(geometryName: string, geometry: Geometry$1, distance: number, unit: string, srsName?: string): DWithin;
/**
 * Creates a `<PropertyIsEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!EqualTo} `<PropertyIsEqualTo>` operator.
 * @api
 */
declare function equalTo(propertyName: string, expression: (string | number), matchCase?: boolean): EqualTo;
/**
 * Creates a `<PropertyIsNotEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.
 * @api
 */
declare function notEqualTo(propertyName: string, expression: (string | number), matchCase?: boolean): NotEqualTo;
/**
 * Creates a `<PropertyIsLessThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThan} `<PropertyIsLessThan>` operator.
 * @api
 */
declare function lessThan(propertyName: string, expression: number): LessThan;
/**
 * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.
 * @api
 */
declare function lessThanOrEqualTo(propertyName: string, expression: number): LessThanOrEqualTo;
/**
 * Creates a `<PropertyIsGreaterThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.
 * @api
 */
declare function greaterThan(propertyName: string, expression: number): GreaterThan;
/**
 * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.
 * @api
 */
declare function greaterThanOrEqualTo(propertyName: string, expression: number): GreaterThanOrEqualTo;
/**
 * Creates a `<PropertyIsNull>` comparison operator to test whether a property value
 * is null.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @return {!IsNull} `<PropertyIsNull>` operator.
 * @api
 */
declare function isNull(propertyName: string): IsNull;
/**
 * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression
 * value lies within a range given by a lower and upper bound (inclusive).
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} lowerBoundary The lower bound of the range.
 * @param {!number} upperBoundary The upper bound of the range.
 * @return {!IsBetween} `<PropertyIsBetween>` operator.
 * @api
 */
declare function between(propertyName: string, lowerBoundary: number, upperBoundary: number): IsBetween;
/**
 * Represents a `<PropertyIsLike>` comparison operator that matches a string property
 * value against a text pattern.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} pattern Text pattern.
 * @param {string} [wildCard] Pattern character which matches any sequence of
 *    zero or more string characters. Default is '*'.
 * @param {string} [singleChar] pattern character which matches any single
 *    string character. Default is '.'.
 * @param {string} [escapeChar] Escape character which can be used to escape
 *    the pattern characters. Default is '!'.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!IsLike} `<PropertyIsLike>` operator.
 * @api
 */
declare function like(propertyName: string, pattern: string, wildCard?: string, singleChar?: string, escapeChar?: string, matchCase?: boolean): IsLike;
/**
 * Create a `<During>` temporal operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} begin The begin date in ISO-8601 format.
 * @param {!string} end The end date in ISO-8601 format.
 * @return {!During} `<During>` operator.
 * @api
 */
declare function during(propertyName: string, begin: string, end: string): During;
declare function resourceId(rid: any): ResourceId;

/**
 * @param {Element} node Node.
 * @return {string|null} href.
 */
declare function readHref(node: Element): string | null;

/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */
declare function readBoolean(node: Node): boolean | undefined;
/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */
declare function readBooleanString(string: string): boolean | undefined;
/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */
declare function readDateTime(node: Node): number | undefined;
/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */
declare function readDecimal(node: Node): number | undefined;
/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */
declare function readDecimalString(string: string): number | undefined;
/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */
declare function readPositiveInteger(node: Node): number | undefined;
/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */
declare function readNonNegativeIntegerString(string: string): number | undefined;
/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */
declare function readString(node: Node): string | undefined;
/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */
declare function writeBooleanTextNode(node: Node, bool: boolean): void;
/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */
declare function writeCDATASection(node: Node, string: string): void;
/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */
declare function writeDateTimeTextNode(node: Node, dateTime: number): void;
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */
declare function writeDecimalTextNode(node: Node, decimal: number): void;
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */
declare function writeNonNegativeIntegerTextNode(node: Node, nonNegativeInteger: number): void;
/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */
declare function writeStringTextNode(node: Node, string: string): void;

/**
 * @module ol/geom/flat/area
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
declare function linearRing(flatCoordinates: Array<number>, offset: number, end: number, stride: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
declare function linearRings(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
declare function linearRingss$1(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number): number;

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
declare function linearRingss(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number): Array<number>;

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
declare function maxSquaredDelta(flatCoordinates: Array<number>, offset: number, end: number, stride: number, max: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
declare function arrayMaxSquaredDelta(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, max: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
declare function multiArrayMaxSquaredDelta(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, max: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
declare function assignClosestPoint(flatCoordinates: Array<number>, offset: number, end: number, stride: number, maxDelta: number, isRing: boolean, x: number, y: number, closestPoint: Array<number>, minSquaredDistance: number, tmpPoint?: Array<number>): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
declare function assignClosestArrayPoint(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, maxDelta: number, isRing: boolean, x: number, y: number, closestPoint: Array<number>, minSquaredDistance: number, tmpPoint?: Array<number>): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
declare function assignClosestMultiArrayPoint(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, maxDelta: number, isRing: boolean, x: number, y: number, closestPoint: Array<number>, minSquaredDistance: number, tmpPoint?: Array<number>): number;

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
declare function linearRingContainsExtent(flatCoordinates: Array<number>, offset: number, end: number, stride: number, extent: Extent$1): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
declare function linearRingContainsXY(flatCoordinates: Array<number>, offset: number, end: number, stride: number, x: number, y: number): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
declare function linearRingsContainsXY(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, x: number, y: number): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
declare function linearRingssContainsXY(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, x: number, y: number): boolean;

/**
 * @module ol/geom/flat/deflate
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
declare function deflateCoordinate(flatCoordinates: Array<number>, offset: number, coordinate: Coordinate, stride: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
declare function deflateCoordinates(flatCoordinates: Array<number>, offset: number, coordinates: Array<Coordinate>, stride: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */
declare function deflateCoordinatesArray(flatCoordinates: Array<number>, offset: number, coordinatess: Array<Array<Coordinate>>, stride: number, ends?: Array<number>): Array<number>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */
declare function deflateMultiCoordinatesArray(flatCoordinates: Array<number>, offset: number, coordinatesss: Array<Array<Array<Coordinate>>>, stride: number, endss?: Array<Array<number>>): Array<Array<number>>;

/**
 * @module ol/geom/flat/flip
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [destOffset] Destination offset.
 * @return {Array<number>} Flat coordinates.
 */
declare function flipXY(flatCoordinates: Array<number>, offset: number, end: number, stride: number, dest?: Array<number>, destOffset?: number): Array<number>;

/**
 * Generate a great-circle arcs between two lat/lon points.
 * @param {number} lon1 Longitude 1 in degrees.
 * @param {number} lat1 Latitude 1 in degrees.
 * @param {number} lon2 Longitude 2 in degrees.
 * @param {number} lat2 Latitude 2 in degrees.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
declare function greatCircleArc(lon1: number, lat1: number, lon2: number, lat2: number, projection: Projection, squaredTolerance: number): Array<number>;
/**
 * Generate a meridian (line at constant longitude).
 * @param {number} lon Longitude.
 * @param {number} lat1 Latitude 1.
 * @param {number} lat2 Latitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
declare function meridian(lon: number, lat1: number, lat2: number, projection: Projection, squaredTolerance: number): Array<number>;
/**
 * Generate a parallel (line at constant latitude).
 * @param {number} lat Latitude.
 * @param {number} lon1 Longitude 1.
 * @param {number} lon2 Longitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
declare function parallel(lat: number, lon1: number, lon2: number, projection: Projection, squaredTolerance: number): Array<number>;

/**
 * @module ol/geom/flat/inflate
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
declare function inflateCoordinates(flatCoordinates: Array<number>, offset: number, end: number, stride: number, coordinates?: Array<Coordinate>): Array<Coordinate>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
declare function inflateCoordinatesArray(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, coordinatess?: Array<Array<Coordinate>>): Array<Array<Coordinate>>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
declare function inflateMultiCoordinatesArray(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, coordinatesss?: Array<Array<Array<Coordinate>>>): Array<Array<Array<Coordinate>>>;

/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
declare function getInteriorPointOfArray(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, flatCenters: Array<number>, flatCentersOffset: number, dest?: Array<number>): Array<number>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
declare function getInteriorPointsOfMultiArray(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, flatCenters: Array<number>): Array<number>;

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
declare function interpolatePoint(flatCoordinates: Array<number>, offset: number, end: number, stride: number, fraction: number, dest?: Array<number>, dimension?: number): Array<number>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
declare function lineStringCoordinateAtM(flatCoordinates: Array<number>, offset: number, end: number, stride: number, m: number, extrapolate: boolean): Coordinate | null;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
declare function lineStringsCoordinateAtM(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, m: number, extrapolate: boolean, interpolate: boolean): Coordinate | null;

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
declare function intersectsLineString(flatCoordinates: Array<number>, offset: number, end: number, stride: number, extent: Extent$1): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
declare function intersectsLineStringArray(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, extent: Extent$1): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
declare function intersectsLinearRing(flatCoordinates: Array<number>, offset: number, end: number, stride: number, extent: Extent$1): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
declare function intersectsLinearRingArray(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, extent: Extent$1): boolean;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
declare function intersectsLinearRingMultiArray(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, extent: Extent$1): boolean;

/**
 * @module ol/geom/flat/length
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
declare function lineStringLength(flatCoordinates: Array<number>, offset: number, end: number, stride: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
declare function linearRingLength(flatCoordinates: Array<number>, offset: number, end: number, stride: number): number;

/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean|undefined} Is clockwise.
 */
declare function linearRingIsClockwise(flatCoordinates: Array<number>, offset: number, end: number, stride: number): boolean | undefined;
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
declare function linearRingsAreOriented(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, right?: boolean): boolean;
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
declare function linearRingssAreOriented(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, right?: boolean): boolean;
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
declare function orientLinearRings(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, right?: boolean): number;
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
declare function orientLinearRingsArray(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, right?: boolean): number;
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */
declare function inflateEnds(flatCoordinates: Array<number>, ends: Array<number>): Array<Array<number>>;

/**
 * @module ol/geom/flat/reverse
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
declare function coordinates(flatCoordinates: Array<number>, offset: number, end: number, stride: number): void;

/**
 * @module ol/geom/flat/segments
 */
/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
declare function forEach<T>(flatCoordinates: Array<number>, offset: number, end: number, stride: number, callback: (arg0: Coordinate, arg1: Coordinate) => T): T | boolean;

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
declare function simplifyLineString(flatCoordinates: Array<number>, offset: number, end: number, stride: number, squaredTolerance: number, highQuality: boolean, simplifiedFlatCoordinates?: Array<number>): Array<number>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
declare function douglasPeucker(flatCoordinates: Array<number>, offset: number, end: number, stride: number, squaredTolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
declare function douglasPeuckerArray(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, squaredTolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number, simplifiedEnds: Array<number>): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
declare function douglasPeuckerMultiArray(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, squaredTolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number, simplifiedEndss: Array<Array<number>>): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
declare function radialDistance(flatCoordinates: Array<number>, offset: number, end: number, stride: number, squaredTolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number): number;
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
declare function snap(value: number, tolerance: number): number;
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
declare function quantize(flatCoordinates: Array<number>, offset: number, end: number, stride: number, tolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
declare function quantizeArray(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, tolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number, simplifiedEnds: Array<number>): number;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
declare function quantizeMultiArray(flatCoordinates: Array<number>, offset: number, endss: Array<Array<number>>, stride: number, tolerance: number, simplifiedFlatCoordinates: Array<number>, simplifiedOffset: number, simplifiedEndss: Array<Array<number>>): number;

/**
 * @module ol/geom/flat/straightchunk
 */
/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
declare function matchingChunk(maxAngle: number, flatCoordinates: Array<number>, offset: number, end: number, stride: number): Array<number>;

/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @param {boolean} keepUpright Whether the text needs to be kept upright
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
declare function drawTextOnPath(flatCoordinates: Array<number>, offset: number, end: number, stride: number, text: string, startM: number, maxAngle: number, scale: number, measureAndCacheTextWidth: (arg0: string, arg1: string, arg2: {
    [x: string]: number;
}) => number, font: string, cache: {
    [x: string]: number;
}, rotation: number, keepUpright?: boolean): Array<Array<any>> | null;

/**
 * Check if the linestring is a boundary.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring is a boundary.
 */
declare function lineStringIsClosed(flatCoordinates: Array<number>, offset: number, end: number, stride: number): boolean;

/**
 * @module ol/geom/flat/transform
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [destinationStride] Stride of destination coordinates; if unspecified, assumed to be 2.
 * @return {Array<number>} Transformed coordinates.
 */
declare function transform2D(flatCoordinates: Array<number>, offset: number, end: number, stride: number, transform: Transform, dest?: Array<number>, destinationStride?: number): Array<number>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
declare function rotate(flatCoordinates: Array<number>, offset: number, end: number, stride: number, angle: number, anchor: Array<number>, dest?: Array<number>): Array<number>;
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
declare function scale$1(flatCoordinates: Array<number>, offset: number, end: number, stride: number, sx: number, sy: number, anchor: Array<number>, dest?: Array<number>): Array<number>;
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
declare function translate$1(flatCoordinates: Array<number>, offset: number, end: number, stride: number, deltaX: number, deltaY: number, dest?: Array<number>): Array<number>;

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
declare const FIREFOX: boolean;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
declare const SAFARI: boolean;
/**
 * https://bugs.webkit.org/show_bug.cgi?id=237906
 * @type {boolean}
 */
declare const SAFARI_BUG_237906: boolean;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
declare const WEBKIT: boolean;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
declare const MAC: boolean;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
declare const DEVICE_PIXEL_RATIO: number;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
declare const WORKER_OFFSCREEN_CANVAS: boolean;
/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
declare const IMAGE_DECODE: boolean;
/**
 * createImageBitmap() is supported.
 * @type {boolean}
 */
declare const CREATE_IMAGE_BITMAP: boolean;
/**
 * @type {boolean}
 */
declare const PASSIVE_EVENT_LISTENERS: boolean;

type Options$19 = {
    /**
     * Animation duration in milliseconds. *
     */
    duration?: number | undefined;
    /**
     * The zoom delta applied on move of one pixel. *
     */
    delta?: number | undefined;
    /**
     * Should the down event be propagated to other interactions, or should be
     * stopped?
     */
    stopDown?: ((arg0: boolean) => boolean) | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds. *
 * @property {number} [delta=1] The zoom delta applied on move of one pixel. *
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */
/**
 * @classdesc
 * Allows the user to zoom the map by double tap/click then drag up/down
 * with one finger/left mouse.
 * @api
 */
declare class DblClickDragZoom extends Interaction {
    /**
     * @param {Options} [opt_options] Options.
     */
    constructor(opt_options?: Options$19);
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    stopDown(handled: boolean): boolean;
    /**
     * @private
     * @type {number}
     */
    private scaleDeltaByPixel_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
    /**
     * @type {boolean}
     * @private
     */
    private handlingDownUpSequence_;
    /**
     * @type {boolean}
     * @private
     */
    private handlingDoubleDownSequence_;
    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    private doubleTapTimeoutId_;
    /**
     * @type {!Object<string, PointerEvent>}
     * @private
     */
    private trackedPointers_;
    /**
     * @type {Array<PointerEvent>}
     * @protected
     */
    protected targetPointers: Array<PointerEvent>;
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    handleDragEvent(mapBrowserEvent: MapBrowserEvent<any>): void;
    lastDistance_: number | undefined;
    lastScaleDelta_: number | undefined;
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleDownEvent(mapBrowserEvent: MapBrowserEvent<any>): boolean;
    anchor_: any;
    down_: MapBrowserEvent<any> | undefined;
    /**
     * Handle pointer up events zooming out.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleUpEvent(mapBrowserEvent: MapBrowserEvent<any>): boolean;
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    private updateTrackedPointers_;
    /**
     * Wait the second double finger tap.
     * @private
     */
    private waitForDblTap_;
    /**
     * @private
     */
    private endInteraction_;
}

type Options$18 = {
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * The zoom delta applied on each double click.
     */
    delta?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */
/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
declare class DoubleClickZoom extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$18);
    /**
     * @private
     * @type {number}
     */
    private delta_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */
declare class DragAndDropEvent extends BaseEvent {
    /**
     * @param {DragAndDropEventType} type Type.
     * @param {File} file File.
     * @param {Array<import("../Feature.js").default>} [features] Features.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     */
    constructor(type: DragAndDropEventType, file: File, features?: Array<Feature$2>, projection?: Projection);
    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */
    features: Array<FeatureLike> | undefined;
    /**
     * The dropped file.
     * @type {File}
     * @api
     */
    file: File;
    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */
    projection: Projection | undefined;
}

type Options$17 = {
    /**
     * Format constructors
     * (and/or formats pre-constructed with options).
     */
    formatConstructors?: (typeof FeatureFormat | FeatureFormat<Feature$2<Geometry$1>>)[] | undefined;
    /**
     * Optional vector source where features will be added.  If a source is provided
     * all existing features will be removed and new features will be added when
     * they are dropped on the target.  If you want to add features to a vector
     * source without removing the existing features (append only), instead of
     * providing the source option listen for the "addfeatures" event.
     */
    source?: VectorSource<Feature$2<Geometry$1>> | undefined;
    /**
     * Target projection. By default, the map's view's projection is used.
     */
    projection?: ProjectionLike;
    /**
     * The element that is used as the drop target, default is the viewport element.
     */
    target?: HTMLElement | undefined;
};
/**
 * *
 */
type DragAndDropOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"addfeatures", DragAndDropEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "addfeatures", Return>;

type DragAndDropEventType = string;
declare namespace DragAndDropEventType {
    let ADD_FEATURES: string;
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'addfeatures', DragAndDropEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature
 */
/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 *
 * @api
 *
 * @fires DragAndDropEvent
 */
declare class DragAndDrop extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$17);
    /***
     * @type {DragAndDropOnSignature<import("../events").EventsKey>}
     */
    on: DragAndDropOnSignature<EventsKey>;
    /***
     * @type {DragAndDropOnSignature<import("../events").EventsKey>}
     */
    once: DragAndDropOnSignature<EventsKey>;
    /***
     * @type {DragAndDropOnSignature<void>}
     */
    un: DragAndDropOnSignature<void>;
    /**
     * @private
     * @type {boolean}
     */
    private readAsBuffer_;
    /**
     * @private
     * @type {Array<import("../format/Feature.js").default>}
     */
    private formats_;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    private projection_;
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    private dropListenKeys_;
    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */
    private source_;
    /**
     * @private
     * @type {HTMLElement|null}
     */
    private target;
    /**
     * @param {File} file File.
     * @param {Event} event Load event.
     * @private
     */
    private handleResult_;
    /**
     * @private
     */
    private registerListeners_;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    override setMap(map: Map): void;
    /**
     * @param {import("../format/Feature.js").default} format Format.
     * @param {string} text Text.
     * @param {import("../format/Feature.js").ReadOptions} options Read options.
     * @private
     * @return {Array<import("../Feature.js").default>} Features.
     */
    private tryReadFeatures_;
    /**
     * @private
     */
    private unregisterListeners_;
    /**
     * @param {DragEvent} event Event.
     */
    handleDrop(event: DragEvent): void;
    /**
     * @param {DragEvent} event Event.
     */
    handleStop(event: DragEvent): void;
}

type Options$16 = {
    /**
     * Function handling "down" events. If the function returns `true` then a drag
     * sequence is started.
     */
    handleDownEvent?: ((arg0: MapBrowserEvent<any>) => boolean) | undefined;
    /**
     * Function handling "drag" events. This function is called on "move" events
     * during a drag sequence.
     */
    handleDragEvent?: ((arg0: MapBrowserEvent<any>) => void) | undefined;
    /**
     * Method called by the map to notify the interaction that a browser event was
     * dispatched to the map. The function may return `false` to prevent the
     * propagation of the event to other interactions in the map's interactions
     * chain.
     */
    handleEvent?: ((arg0: MapBrowserEvent<any>) => boolean) | undefined;
    /**
     * Function handling "move" events. This function is called on "move" events.
     * This functions is also called during a drag sequence, so during a drag
     * sequence both the `handleDragEvent` function and this function are called.
     * If `handleDownEvent` is defined and it returns true this function will not
     * be called during a drag sequence.
     */
    handleMoveEvent?: ((arg0: MapBrowserEvent<any>) => void) | undefined;
    /**
     * Function handling "up" events. If the function returns `false` then the
     * current drag sequence is stopped.
     */
    handleUpEvent?: ((arg0: MapBrowserEvent<any>) => boolean) | undefined;
    /**
     * Should the down event be propagated to other interactions, or should be
     * stopped?
     */
    stopDown?: ((arg0: boolean) => boolean) | undefined;
};
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */
/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
declare class PointerInteraction extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$16);
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    protected handleDownEvent(mapBrowserEvent: MapBrowserEvent<any>): boolean;
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    protected handleDragEvent(mapBrowserEvent: MapBrowserEvent<any>): void;
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    protected handleMoveEvent(mapBrowserEvent: MapBrowserEvent<any>): void;
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    protected handleUpEvent(mapBrowserEvent: MapBrowserEvent<any>): boolean;
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    stopDown(handled: boolean): boolean;
    /**
     * @type {boolean}
     * @protected
     */
    protected handlingDownUpSequence: boolean;
    /**
     * @type {Array<PointerEvent>}
     * @protected
     */
    protected targetPointers: Array<PointerEvent>;
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */
    getPointerCount(): number;
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    private updateTrackedPointers_;
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
declare class DragBoxEvent extends BaseEvent {
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    constructor(type: string, coordinate: Coordinate, mapBrowserEvent: MapBrowserEvent<any>);
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    coordinate: Coordinate;
    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    mapBrowserEvent: MapBrowserEvent<any>;
}

/**
 * A function that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module :ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 */
type EndCondition = (this: unknown, arg1: MapBrowserEvent<any>, arg2: Pixel, arg3: Pixel) => boolean;
type Options$15 = {
    /**
     * CSS class name for styling the box.
     */
    className?: string | undefined;
    /**
     * A function that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link ol /events/condition~mouseActionButton}.
     */
    condition?: Condition | undefined;
    /**
     * The minimum area of the box in pixel, this value is used by the default
     * `boxEndCondition` function.
     */
    minArea?: number | undefined;
    /**
     * A function that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and two
     * {@link module :ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
     * Default is `true` if the area of the box is bigger than the `minArea` option.
     */
    boxEndCondition?: EndCondition | undefined;
    /**
     * Code to execute just
     * before `boxend` is fired.
     */
    onBoxEnd?: ((this: DragBox, arg1: MapBrowserEvent<any>) => void) | undefined;
};
/**
 * *
 */
type DragBoxOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"boxcancel" | "boxdrag" | "boxend" | "boxstart", DragBoxEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "boxcancel" | "boxdrag" | "boxend", Return>;

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */
declare class DragBox extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$15);
    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    on: DragBoxOnSignature<EventsKey>;
    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    once: DragBoxOnSignature<EventsKey>;
    /***
     * @type {DragBoxOnSignature<void>}
     */
    un: DragBoxOnSignature<void>;
    /**
     * @type {import("../render/Box.js").default}
     * @private
     */
    private box_;
    /**
     * @type {number}
     * @private
     */
    private minArea_;
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    onBoxEnd(event: MapBrowserEvent<any>): void;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    private startPixel_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {EndCondition}
     */
    private boxEndCondition_;
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */
    defaultBoxEndCondition(mapBrowserEvent: MapBrowserEvent<any>, startPixel: Pixel, endPixel: Pixel): boolean;
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
    getGeometry(): Polygon$1;
}

type Options$14 = {
    /**
     * A function that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link module :ol/events/condition.noModifierKeys} and {@link module :ol/events/condition.primaryAction}.
     */
    condition?: Condition | undefined;
    /**
     * When the map's target has a `tabindex` attribute set,
     * the interaction will only handle events when the map has the focus.
     */
    onFocusOnly?: boolean | undefined;
    /**
     * Kinetic inertia to apply to the pan.
     */
    kinetic?: Kinetic | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */
/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
declare class DragPan extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$14);
    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */
    private kinetic_;
    /**
     * @type {import("../pixel.js").Pixel}
     */
    lastCentroid: Pixel;
    /**
     * @type {number}
     * @private
     */
    private lastPointersCount_;
    /**
     * @type {boolean}
     * @private
     */
    private panning_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {boolean}
     */
    private noKinetic_;
}

type Options$13 = {
    /**
     * A function that takes a
     * {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link module :ol/events/condition.altShiftKeysOnly}.
     */
    condition?: Condition | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
declare class DragRotate extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$13);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {number|undefined}
     */
    private lastAngle_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
}

type Options$12 = {
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module :ol/events/condition.shiftKeyOnly}.
     */
    condition?: Condition | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
declare class DragRotateAndZoom extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$12);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {number|undefined}
     */
    private lastAngle_;
    /**
     * @private
     * @type {number|undefined}
     */
    private lastMagnitude_;
    /**
     * @private
     * @type {number}
     */
    private lastScaleDelta_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
}

type Options$11 = {
    /**
     * CSS class name for styling the
     * box.
     */
    className?: string | undefined;
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module :ol/events/condition.shiftKeyOnly}.
     */
    condition?: Condition | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * Use interaction for zooming out.
     */
    out?: boolean | undefined;
    /**
     * The minimum area of the box in pixel, this value is used by the parent default
     * `boxEndCondition` function.
     */
    minArea?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
declare class DragZoom extends DragBox {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$11);
    /**
     * @private
     * @type {number}
     */
    private duration_;
    /**
     * @private
     * @type {boolean}
     */
    private out_;
}

/**
 * @module ol/style/flat
 */
/**
 * @api
 * @fileoverview Vector layers can be styled with an object literal containing properties for
 * stroke, fill, image, and text styles.  The types below can be composed into a single object.
 * For example, a style with both stroke and fill properties could look like this:
 *
 *     const style = {
 *       'stroke-color': 'yellow',
 *       'stroke-width': 1.5,
 *       'fill-color': 'orange',
 *     };
 *
 * See details about the available properties depending on what type of symbolizer should be applied:
 *  * {@link module:ol/style/flat~FlatStroke Stroke} - properties for applying a stroke to lines and polygons
 *  * {@link module:ol/style/flat~FlatFill Fill} - properties for filling polygons
 *  * {@link module:ol/style/flat~FlatText Text} - properties for labeling points, lines, and polygons
 *  * {@link module:ol/style/flat~FlatIcon Icon} - properties for rendering points with an icon
 *  * {@link module:ol/style/flat~FlatCircle Circle} - properties for rendering points with a circle
 *  * {@link module:ol/style/flat~FlatShape Shape} - properties for rendering points with a regular shape
 *
 * To conditionally apply styles based on a filter, a list of {@link module:ol/style/flat~Rule rules} can be used.
 * For example, to style points with a big orange circle if the population is greater than 1 million and
 * a smaller blue circle otherwise:
 *
 *     const rules = [
 *       {
 *         filter: ['>', ['get', 'population'], 1_000_000],
 *         style: {
 *           'circle-radius': 10,
 *           'circle-fill-color': 'red',
 *         }
 *       },
 *       {
 *         else: true,
 *         style: {
 *           'circle-radius': 5,
 *           'circle-fill-color': 'blue',
 *         },
 *       },
 *     ];
 */
/**
 * A literal boolean (e.g. `true`) or an expression that evaluates to a boolean (e.g. `['>', ['get', 'population'], 1_000_000]`).
 *
 * @typedef {boolean|Array} BooleanExpression
 */
/**
 * A literal string (e.g. `'hello'`) or an expression that evaluates to a string (e.g. `['get', 'greeting']`).
 *
 * @typedef {string|Array} StringExpression
 */
/**
 * A literal number (e.g. `42`) or an expression that evaluates to a number (e.g. `['+', 40, 2]`).
 *
 * @typedef {number|Array} NumberExpression
 */
/**
 * A CSS named color (e.g. `'blue'`), an array of 3 RGB values (e.g. `[0, 255, 0]`), an array of 4 RGBA values
 * (e.g. `[0, 255, 0, 0.5]`), or an expression that evaluates to one of these color types (e.g. `['get', 'color']`).
 *
 * @typedef {import("../color.js").Color|string|Array} ColorExpression
 */
/**
 * An array of numbers (e.g. `[1, 2, 3]`) or an expression that evaluates to the same (e.g. `['get', 'values']`).
 *
 * @typedef {Array<number>|Array} NumberArrayExpression
 */
/**
 * An array of two numbers (e.g. `[10, 20]`) or an expression that evaluates to the same (e.g. `['get', 'size']`).
 *
 * @typedef {number|Array<number>|Array} SizeExpression
 */
/**
 * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 * @api
 *
 * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle
 */
/**
 * A flat style literal or an array of the same.
 *
 * @typedef {FlatStyle|Array<FlatStyle>|Array<Rule>} FlatStyleLike
 */
/**
 * Fill style properties applied to polygon features.
 *
 * @typedef {Object} FlatFill
 * @property {ColorExpression} [fill-color] The fill color. `'none'` means no fill and no hit detection.
 * @property {StringExpression} [fill-pattern-src] Fill pattern image URL.
 * @property {SizeExpression} [fill-pattern-size] Fill pattern image size in pixels.
 * Can be used together with `fill-pattern-offset` to define the sub-rectangle to use
 * from a fill pattern image sprite sheet.
 * @property {SizeExpression} [fill-pattern-offset] Fill pattern image offset in pixels.
 */
/**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 *
 * @typedef {Object} FlatStroke
 * @property {ColorExpression} [stroke-color] The stroke color.
 * @property {NumberExpression} [stroke-width] Stroke pixel width.
 * @property {StringExpression} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */
/**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 *
 * @typedef {Object} FlatText
 * @property {StringExpression} [text-value] Text content (with `\n` for line breaks).
 * @property {StringExpression} [text-font='10px sans-serif'] Font style as [CSS `font`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font) value.
 * @property {NumberExpression} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {NumberExpression} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {NumberExpression} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {BooleanExpression} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {StringExpression} [text-placement='point'] Text placement.
 * @property {NumberExpression} [text-repeat] Repeat interval in pixels. When set, the text will be repeated at this interval. Only available when
 * `text-placement` is set to `'line'`. Overrides `text-align`.
 * @property {SizeExpression} [text-scale] Scale.
 * @property {BooleanExpression} [text-rotate-with-view=false] Whether to rotate the text with the view.
 * @property {NumberExpression} [text-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {StringExpression} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `'text-placement': 'point'`. For `'text-placement': 'line'`, the default is to let the renderer choose a
 * placement where `text-max-angle` is not exceeded.
 * @property {StringExpression} [text-justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `text-justify` is ignored for immediate rendering and also for `'text-placement': 'line'`.
 * @property {StringExpression} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {NumberArrayExpression} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {ColorExpression} [text-fill-color] The fill color. `'none'` means no fill and no hit detection.
 * @property {ColorExpression} [text-background-fill-color] The fill color. `'none'` means no fill and no hit detection.
 * @property {ColorExpression} [text-stroke-color] The stroke color.
 * @property {StringExpression} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [text-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [text-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [text-stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [text-stroke-width] Stroke pixel width.
 * @property {ColorExpression} [text-background-stroke-color] The stroke color.
 * @property {StringExpression} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [text-background-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [text-background-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [text-background-stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [text-background-stroke-width] Stroke pixel width.
 * @property {import("./Style.js").DeclutterMode} [text-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */
/**
 * Icon style properties applied to point features. `icon-src` must be provided to render
 * points with an icon.
 *
 * @typedef {Object} FlatIcon
 * @property {string} [icon-src] Image source URI.
 * @property {NumberArrayExpression} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./Icon.js").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [icon-color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {NumberArrayExpression} [icon-displacement=[0,0]] Displacement of the icon.
 * @property {import("./Icon.js").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {NumberExpression} [icon-opacity=1] Opacity of the icon.
 * @property {SizeExpression} [icon-scale=1] Scale.
 * @property {number} [icon-width] Width of the icon. If not specified, the actual image width will be used. Cannot be combined
 * with `scale`.
 * @property {number} [icon-height] Height of the icon. If not specified, the actual image height will be used. Cannot be combined
 * with `scale`.
 * @property {NumberExpression} [icon-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {BooleanExpression} [icon-rotate-with-view=false] Whether to rotate the icon with the view.
 * @property {import("../size.js").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("./Style.js").DeclutterMode} [icon-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */
/**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 *
 * @typedef {Object} FlatShape
 * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {ColorExpression} [shape-fill-color] The fill color. `'none'` means no fill and no hit detection.
 * @property {ColorExpression} [shape-stroke-color] The stroke color.
 * @property {NumberExpression} [shape-stroke-width] Stroke pixel width.
 * @property {StringExpression} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [shape-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [shape-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [shape-stroke-miter-limit=10] Miter limit.
 * @property {number} [shape-radius] Radius of a regular polygon.
 * @property {number} [shape-radius2] Second radius to make a star instead of a regular polygon.
 * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {NumberArrayExpression} [shape-displacement=[0,0]] Displacement of the shape
 * @property {NumberExpression} [shape-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {BooleanExpression} [shape-rotate-with-view=false] Whether to rotate the shape with the view.
 * @property {SizeExpression} [shape-scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `shape-radius` and `shape-radius2`.
 * @property {import("./Style.js").DeclutterMode} [shape-declutter-mode] Declutter mode.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */
/**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 *
 * @typedef {Object} FlatCircle
 * @property {number} [circle-radius] Circle radius.
 * @property {ColorExpression} [circle-fill-color] The fill color. `'none'` means no fill and no hit detection.
 * @property {ColorExpression} [circle-stroke-color] The stroke color.
 * @property {NumberExpression} [circle-stroke-width] Stroke pixel width.
 * @property {StringExpression} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [circle-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [circle-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [circle-stroke-miter-limit=10] Miter limit.
 * @property {NumberArrayExpression} [circle-displacement=[0,0]] displacement
 * @property {SizeExpression} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
 * @property {NumberExpression} [circle-rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {BooleanExpression} [circle-rotate-with-view=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {import("./Style.js").DeclutterMode} [circle-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */
/**
 * These default style properties are applied when no other style is given.
 *
 * @typedef {Object} DefaultStyle
 * @property {string} fill-color `'rgba(255,255,255,0.4)'`
 * @property {string} stroke-color `'#3399CC'`
 * @property {number} stroke-width `1.25`
 * @property {number} circle-radius `5`
 * @property {string} circle-fill-color `'rgba(255,255,255,0.4)'`
 * @property {number} circle-stroke-width `1.25`
 * @property {string} circle-stroke-color `'#3399CC'`
 */
/**
 * @return {DefaultStyle} The default flat style.
 */
declare function createDefaultStyle(): DefaultStyle;
/**
 * A literal boolean (e.g. `true`) or an expression that evaluates to a boolean (e.g. `['>', ['get', 'population'], 1_000_000]`).
 */
type BooleanExpression = boolean | any[];
/**
 * A literal string (e.g. `'hello'`) or an expression that evaluates to a string (e.g. `['get', 'greeting']`).
 */
type StringExpression = string | any[];
/**
 * A literal number (e.g. `42`) or an expression that evaluates to a number (e.g. `['+', 40, 2]`).
 */
type NumberExpression = number | any[];
/**
 * A CSS named color (e.g. `'blue'`), an array of 3 RGB values (e.g. `[0, 255, 0]`), an array of 4 RGBA values
 * (e.g. `[0, 255, 0, 0.5]`), or an expression that evaluates to one of these color types (e.g. `['get', 'color']`).
 */
type ColorExpression$1 = Color | string | any[];
/**
 * An array of numbers (e.g. `[1, 2, 3]`) or an expression that evaluates to the same (e.g. `['get', 'values']`).
 */
type NumberArrayExpression = Array<number> | any[];
/**
 * An array of two numbers (e.g. `[10, 20]`) or an expression that evaluates to the same (e.g. `['get', 'size']`).
 */
type SizeExpression = number | Array<number> | any[];
/**
 * For static styling, the [layer.setStyle()]{@link module :ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 */
type FlatStyle$1 = FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle;
/**
 * A flat style literal or an array of the same.
 */
type FlatStyleLike = FlatStyle$1 | Array<FlatStyle$1> | Array<Rule>;
/**
 * Fill style properties applied to polygon features.
 */
type FlatFill = {
    /**
     * The fill color. `'none'` means no fill and no hit detection.
     */
    "fill-color"?: ColorExpression$1 | undefined;
    /**
     * Fill pattern image URL.
     */
    "fill-pattern-src"?: StringExpression | undefined;
    /**
     * Fill pattern image size in pixels.
     * Can be used together with `fill-pattern-offset` to define the sub-rectangle to use
     * from a fill pattern image sprite sheet.
     */
    "fill-pattern-size"?: SizeExpression | undefined;
    /**
     * Fill pattern image offset in pixels.
     */
    "fill-pattern-offset"?: SizeExpression | undefined;
};
/**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 */
type FlatStroke = {
    /**
     * The stroke color.
     */
    "stroke-color"?: ColorExpression$1 | undefined;
    /**
     * Stroke pixel width.
     */
    "stroke-width"?: NumberExpression | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    "stroke-line-cap"?: StringExpression | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    "stroke-line-join"?: StringExpression | undefined;
    /**
     * Line dash pattern.
     */
    "stroke-line-dash"?: NumberArrayExpression | undefined;
    /**
     * Line dash offset.
     */
    "stroke-line-dash-offset"?: NumberExpression | undefined;
    /**
     * Miter limit.
     */
    "stroke-miter-limit"?: NumberExpression | undefined;
    /**
     * The zIndex of the style.
     */
    "z-index"?: NumberExpression | undefined;
};
/**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 */
type FlatText = {
    /**
     * Text content (with `\n` for line breaks).
     */
    "text-value"?: StringExpression | undefined;
    /**
     * Font style as [CSS `font`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font) value.
     */
    "text-font"?: StringExpression | undefined;
    /**
     * When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
     * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
     */
    "text-max-angle"?: NumberExpression | undefined;
    /**
     * Horizontal text offset in pixels. A positive will shift the text right.
     */
    "text-offset-x"?: NumberExpression | undefined;
    /**
     * Vertical text offset in pixels. A positive will shift the text down.
     */
    "text-offset-y"?: NumberExpression | undefined;
    /**
     * For polygon labels or when `placement` is set to `'line'`, allow text to exceed
     * the width of the polygon at the label position or the length of the path that it follows.
     */
    "text-overflow"?: BooleanExpression | undefined;
    /**
     * Text placement.
     */
    "text-placement"?: StringExpression | undefined;
    /**
     * Repeat interval in pixels. When set, the text will be repeated at this interval. Only available when
     * `text-placement` is set to `'line'`. Overrides `text-align`.
     */
    "text-repeat"?: NumberExpression | undefined;
    /**
     * Scale.
     */
    "text-scale"?: SizeExpression | undefined;
    /**
     * Whether to rotate the text with the view.
     */
    "text-rotate-with-view"?: BooleanExpression | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    "text-rotation"?: NumberExpression | undefined;
    /**
     * Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
     * Default is `'center'` for `'text-placement': 'point'`. For `'text-placement': 'line'`, the default is to let the renderer choose a
     * placement where `text-max-angle` is not exceeded.
     */
    "text-align"?: StringExpression | undefined;
    /**
     * Text justification within the text box.
     * If not set, text is justified towards the `textAlign` anchor.
     * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
     * **Note:** `text-justify` is ignored for immediate rendering and also for `'text-placement': 'line'`.
     */
    "text-justify"?: StringExpression | undefined;
    /**
     * Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
     * `'hanging'`, `'ideographic'`.
     */
    "text-baseline"?: StringExpression | undefined;
    /**
     * Padding in pixels around the text for decluttering and background. The order of
     * values in the array is `[top, right, bottom, left]`.
     */
    "text-padding"?: NumberArrayExpression | undefined;
    /**
     * The fill color. `'none'` means no fill and no hit detection.
     */
    "text-fill-color"?: ColorExpression$1 | undefined;
    /**
     * The fill color. `'none'` means no fill and no hit detection.
     */
    "text-background-fill-color"?: ColorExpression$1 | undefined;
    /**
     * The stroke color.
     */
    "text-stroke-color"?: ColorExpression$1 | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    "text-stroke-line-cap"?: StringExpression | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    "text-stroke-line-join"?: StringExpression | undefined;
    /**
     * Line dash pattern.
     */
    "text-stroke-line-dash"?: NumberArrayExpression | undefined;
    /**
     * Line dash offset.
     */
    "text-stroke-line-dash-offset"?: NumberExpression | undefined;
    /**
     * Miter limit.
     */
    "text-stroke-miter-limit"?: NumberExpression | undefined;
    /**
     * Stroke pixel width.
     */
    "text-stroke-width"?: NumberExpression | undefined;
    /**
     * The stroke color.
     */
    "text-background-stroke-color"?: ColorExpression$1 | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    "text-background-stroke-line-cap"?: StringExpression | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    "text-background-stroke-line-join"?: StringExpression | undefined;
    /**
     * Line dash pattern.
     */
    "text-background-stroke-line-dash"?: NumberArrayExpression | undefined;
    /**
     * Line dash offset.
     */
    "text-background-stroke-line-dash-offset"?: NumberExpression | undefined;
    /**
     * Miter limit.
     */
    "text-background-stroke-miter-limit"?: NumberExpression | undefined;
    /**
     * Stroke pixel width.
     */
    "text-background-stroke-width"?: NumberExpression | undefined;
    /**
     * Declutter mode
     */
    "text-declutter-mode"?: DeclutterMode | undefined;
    /**
     * The zIndex of the style.
     */
    "z-index"?: NumberExpression | undefined;
};
/**
 * Icon style properties applied to point features. `icon-src` must be provided to render
 * points with an icon.
 */
type FlatIcon = {
    /**
     * Image source URI.
     */
    "icon-src"?: string | undefined;
    /**
     * Anchor. Default value is the icon center.
     */
    "icon-anchor"?: NumberArrayExpression | undefined;
    /**
     * Origin of the anchor: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    "icon-anchor-origin"?: IconOrigin | undefined;
    /**
     * Units in which the anchor x value is
     * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
     * the x value in pixels.
     */
    "icon-anchor-x-units"?: IconAnchorUnits | undefined;
    /**
     * Units in which the anchor y value is
     * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
     * the y value in pixels.
     */
    "icon-anchor-y-units"?: IconAnchorUnits | undefined;
    /**
     * Color to tint the icon. If not specified,
     * the icon will be left as is.
     */
    "icon-color"?: string | Color | undefined;
    /**
     * The `crossOrigin` attribute for loaded images. Note that you must provide a
     * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    "icon-cross-origin"?: string | null | undefined;
    /**
     * Offset, which, together with the size and the offset origin, define the
     * sub-rectangle to use from the original icon image.
     */
    "icon-offset"?: number[] | undefined;
    /**
     * Displacement of the icon.
     */
    "icon-displacement"?: NumberArrayExpression | undefined;
    /**
     * Origin of the offset: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    "icon-offset-origin"?: IconOrigin | undefined;
    /**
     * Opacity of the icon.
     */
    "icon-opacity"?: NumberExpression | undefined;
    /**
     * Scale.
     */
    "icon-scale"?: SizeExpression | undefined;
    /**
     * Width of the icon. If not specified, the actual image width will be used. Cannot be combined
     * with `scale`.
     */
    "icon-width"?: number | undefined;
    /**
     * Height of the icon. If not specified, the actual image height will be used. Cannot be combined
     * with `scale`.
     */
    "icon-height"?: number | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    "icon-rotation"?: NumberExpression | undefined;
    /**
     * Whether to rotate the icon with the view.
     */
    "icon-rotate-with-view"?: BooleanExpression | undefined;
    /**
     * Icon size in pixel. Can be used together with `icon-offset` to define the
     * sub-rectangle to use from the origin (sprite) icon image.
     */
    "icon-size"?: Size | undefined;
    /**
     * Declutter mode
     */
    "icon-declutter-mode"?: DeclutterMode | undefined;
    /**
     * The zIndex of the style.
     */
    "z-index"?: NumberExpression | undefined;
};
/**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 */
type FlatShape = {
    /**
     * Number of points for stars and regular polygons. In case of a polygon, the number of points
     * is the number of sides.
     */
    "shape-points"?: number | undefined;
    /**
     * The fill color. `'none'` means no fill and no hit detection.
     */
    "shape-fill-color"?: ColorExpression$1 | undefined;
    /**
     * The stroke color.
     */
    "shape-stroke-color"?: ColorExpression$1 | undefined;
    /**
     * Stroke pixel width.
     */
    "shape-stroke-width"?: NumberExpression | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    "shape-stroke-line-cap"?: StringExpression | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    "shape-stroke-line-join"?: StringExpression | undefined;
    /**
     * Line dash pattern.
     */
    "shape-stroke-line-dash"?: NumberArrayExpression | undefined;
    /**
     * Line dash offset.
     */
    "shape-stroke-line-dash-offset"?: NumberExpression | undefined;
    /**
     * Miter limit.
     */
    "shape-stroke-miter-limit"?: NumberExpression | undefined;
    /**
     * Radius of a regular polygon.
     */
    "shape-radius"?: number | undefined;
    /**
     * Second radius to make a star instead of a regular polygon.
     */
    "shape-radius2"?: number | undefined;
    /**
     * Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
     */
    "shape-angle"?: number | undefined;
    /**
     * Displacement of the shape
     */
    "shape-displacement"?: NumberArrayExpression | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    "shape-rotation"?: NumberExpression | undefined;
    /**
     * Whether to rotate the shape with the view.
     */
    "shape-rotate-with-view"?: BooleanExpression | undefined;
    /**
     * Scale. Unless two dimensional scaling is required a better
     * result may be obtained with appropriate settings for `shape-radius` and `shape-radius2`.
     */
    "shape-scale"?: SizeExpression | undefined;
    /**
     * Declutter mode.
     */
    "shape-declutter-mode"?: DeclutterMode | undefined;
    /**
     * The zIndex of the style.
     */
    "z-index"?: NumberExpression | undefined;
};
/**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 */
type FlatCircle = {
    /**
     * Circle radius.
     */
    "circle-radius"?: number | undefined;
    /**
     * The fill color. `'none'` means no fill and no hit detection.
     */
    "circle-fill-color"?: ColorExpression$1 | undefined;
    /**
     * The stroke color.
     */
    "circle-stroke-color"?: ColorExpression$1 | undefined;
    /**
     * Stroke pixel width.
     */
    "circle-stroke-width"?: NumberExpression | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    "circle-stroke-line-cap"?: StringExpression | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    "circle-stroke-line-join"?: StringExpression | undefined;
    /**
     * Line dash pattern.
     */
    "circle-stroke-line-dash"?: NumberArrayExpression | undefined;
    /**
     * Line dash offset.
     */
    "circle-stroke-line-dash-offset"?: NumberExpression | undefined;
    /**
     * Miter limit.
     */
    "circle-stroke-miter-limit"?: NumberExpression | undefined;
    /**
     * displacement
     */
    "circle-displacement"?: NumberArrayExpression | undefined;
    /**
     * Scale. A two dimensional scale will produce an ellipse.
     * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
     */
    "circle-scale"?: SizeExpression | undefined;
    /**
     * Rotation in radians
     * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
     */
    "circle-rotation"?: NumberExpression | undefined;
    /**
     * Whether to rotate the shape with the view
     * (meaningful only when used in conjunction with a two dimensional scale).
     */
    "circle-rotate-with-view"?: BooleanExpression | undefined;
    /**
     * Declutter mode
     */
    "circle-declutter-mode"?: DeclutterMode | undefined;
    /**
     * The zIndex of the style.
     */
    "z-index"?: NumberExpression | undefined;
};
/**
 * These default style properties are applied when no other style is given.
 */
type DefaultStyle = {
    /**
     * `'rgba(255,255,255,0.4)'`
     */
    "fill-color": string;
    /**
     * `'#3399CC'`
     */
    "stroke-color": string;
    /**
     * `1.25`
     */
    "stroke-width": number;
    /**
     * `5`
     */
    "circle-radius": number;
    /**
     * `'rgba(255,255,255,0.4)'`
     */
    "circle-fill-color": string;
    /**
     * `1.25`
     */
    "circle-stroke-width": number;
    /**
     * `'#3399CC'`
     */
    "circle-stroke-color": string;
};
/**
 * A rule is used to conditionally apply a style.  If the rule's filter evaluates to true,
 * the style will be applied.
 */
type Rule = {
    /**
     * The style to be applied if the filter matches.
     */
    style: FlatStyle$1 | Array<FlatStyle$1>;
    /**
     * The filter used
     * to determine if a style applies.  If no filter is included, the rule always applies
     * (unless it is an else rule).
     */
    filter?: EncodedExpression | undefined;
    /**
     * If true, the rule applies only if no other previous rule applies.
     * If the else rule also has a filter, the rule will not apply if the filter does not match.
     */
    else?: boolean | undefined;
};
/**
 * Style variables are provided as an object. The variables can be read in a {@link import ("../expr/expression.js").ExpressionValue style expression}
 * using the `['var', 'varName']` operator.
 * Each variable must hold a literal value (not an expression).
 */
type StyleVariables = {
    [x: string]: string | number | boolean | number[];
};

/**
 * @classdesc
 * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,
 * simplifying initialization and binding for rendering.
 */
declare class WebGLRenderTarget {
    /**
     * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
     * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
     */
    constructor(helper: WebGLHelper, size?: Array<number>);
    /**
     * @private
     * @type {import("./Helper.js").default}
     */
    private helper_;
    /**
     * @private
     * @type {WebGLTexture}
     */
    private texture_;
    /**
     * @private
     * @type {WebGLFramebuffer}
     */
    private framebuffer_;
    /**
     * @private
     * @type {WebGLRenderbuffer}
     */
    private depthbuffer_;
    /**
     * @type {Array<number>}
     * @private
     */
    private size_;
    /**
     * @type {Uint8Array}
     * @private
     */
    private data_;
    /**
     * @type {boolean}
     * @private
     */
    private dataCacheDirty_;
    /**
     * Changes the size of the render target texture. Note: will do nothing if the size
     * is already the same.
     * @param {Array<number>} size Expected size of the render target texture
     */
    setSize(size: Array<number>): void;
    /**
     * Returns the size of the render target texture
     * @return {Array<number>} Size of the render target texture
     */
    getSize(): Array<number>;
    /**
     * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
     * render target into memory, which is an expensive operation.
     * This content will be kept in cache but should be cleared after each new render.
     */
    clearCachedData(): void;
    /**
     * Returns the full content of the frame buffer as a series of r, g, b, a components
     * in the 0-255 range (unsigned byte).
     * @return {Uint8Array} Integer array of color values
     */
    readAll(): Uint8Array;
    /**
     * Reads one pixel of the frame buffer as an array of r, g, b, a components
     * in the 0-255 range (unsigned byte).
     * If x and/or y are outside of existing data, an array filled with 0 is returned.
     * @param {number} x Pixel coordinate
     * @param {number} y Pixel coordinate
     * @return {Uint8Array} Integer array with one color value (4 components)
     */
    readPixel(x: number, y: number): Uint8Array;
    /**
     * @return {WebGLTexture} Texture to render to
     */
    getTexture(): WebGLTexture;
    /**
     * @return {WebGLFramebuffer} Frame buffer of the render target
     */
    getFramebuffer(): WebGLFramebuffer;
    /**
     * @return {WebGLRenderbuffer} Depth buffer of the render target
     */
    getDepthbuffer(): WebGLRenderbuffer;
    /**
     * @private
     */
    private updateSize_;
}
//# sourceMappingURL=RenderTarget.d.ts.map

/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object} [attributes] Attributes.
 * @return {WebGLRenderingContext|null} WebGL rendering context.
 */
declare function getContext(canvas: HTMLCanvasElement, attributes?: any): WebGLRenderingContext | null;
/**
 * @return {Array<string>|null} List of supported WebGL extensions.
 */
declare function getSupportedExtensions(): Array<string> | null;
/**
 * Constants taken from goog.webgl
 */
/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as
 * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer
 * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).
 * @const
 * @type {number}
 * @api
 */
declare const ARRAY_BUFFER: number;
/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.
 * Index buffers are essentially lists of references to vertices defined in a vertex buffer
 * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.
 * @const
 * @type {number}
 * @api
 */
declare const ELEMENT_ARRAY_BUFFER: number;
/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
declare const STREAM_DRAW: number;
/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
declare const STATIC_DRAW: number;
/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */
declare const DYNAMIC_DRAW: number;
/**
 * @const
 * @type {number}
 */
declare const UNSIGNED_BYTE: number;
/**
 * @const
 * @type {number}
 */
declare const UNSIGNED_SHORT: number;
/**
 * @const
 * @type {number}
 */
declare const UNSIGNED_INT: number;
/**
 * @const
 * @type {number}
 */
declare const FLOAT: number;

/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 */
declare class WebGLArrayBuffer {
    /**
     * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
     * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
     * Default is `STATIC_DRAW`.
     */
    constructor(type: number, usage?: number);
    /**
     * @private
     * @type {Float32Array|Uint32Array|null}
     */
    private array_;
    /**
     * @private
     * @type {number}
     */
    private type_;
    /**
     * @private
     * @type {number}
     */
    private usage_;
    /**
     * Populates the buffer with an array of the given size (all values will be zeroes).
     * @param {number} size Array size
     * @return {WebGLArrayBuffer} This
     */
    ofSize(size: number): WebGLArrayBuffer;
    /**
     * Populates the buffer with an array of the given size.
     * @param {Array<number>} array Numerical array
     * @return {WebGLArrayBuffer} This
     */
    fromArray(array: Array<number>): WebGLArrayBuffer;
    /**
     * Populates the buffer with a raw binary array buffer.
     * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
     * initialized for the same typed array class.
     * @return {WebGLArrayBuffer} This
     */
    fromArrayBuffer(buffer: ArrayBuffer): WebGLArrayBuffer;
    /**
     * @return {number} Buffer type.
     */
    getType(): number;
    /**
     * Will return null if the buffer was not initialized
     * @return {Float32Array|Uint32Array|null} Array.
     */
    getArray(): Float32Array | Uint32Array | null;
    /**
     * @param {Float32Array|Uint32Array} array Array.
     */
    setArray(array: Float32Array | Uint32Array): void;
    /**
     * @return {number} Usage.
     */
    getUsage(): number;
    /**
     * Will return 0 if the buffer is not initialized
     * @return {number} Array size
     */
    getSize(): number;
}

/**
 * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.
 */
type ShaderType = number;
declare namespace ShaderType {
    let FRAGMENT_SHADER: number;
    let VERTEX_SHADER: number;
}
/**
 * Description of an attribute in a buffer
 */
type AttributeDescription = {
    /**
     * Attribute name to use in shaders
     */
    name: string;
    /**
     * Number of components per attributes
     */
    size: number;
    /**
     * Attribute type, i.e. number of bytes used to store the value. This is
     * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
     * Default is `FLOAT`.
     */
    type?: number | undefined;
};
type UniformLiteralValue = number | Array<number> | HTMLCanvasElement | HTMLImageElement | ImageData | WebGLTexture | Transform;
/**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 */
type UniformValue = UniformLiteralValue | ((arg0: FrameState) => UniformLiteralValue);
type PostProcessesOptions$1 = {
    /**
     * Scale ratio; if < 1, the post process will render to a texture smaller than
     * the main canvas which will then be sampled up (useful for saving resource on blur steps).
     */
    scaleRatio?: number | undefined;
    /**
     * Vertex shader source
     */
    vertexShader?: string | undefined;
    /**
     * Fragment shader source
     */
    fragmentShader?: string | undefined;
    /**
     * Uniform definitions for the post process step
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
};
type Options$10 = {
    /**
     * Uniform definitions; property names must match the uniform
     * names in the provided or default shaders.
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
    /**
     * Post-processes definitions
     */
    postProcesses?: PostProcessesOptions$1[] | undefined;
    /**
     * The cache key for the canvas.
     */
    canvasCacheKey?: string | undefined;
};
/**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls; note how a frameState is required to set up a program,
 *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program, frameState);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Specify the attribute names with
 *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 */
declare class WebGLHelper extends Disposable {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$10);
    /** @private */
    private boundHandleWebGLContextLost_;
    /** @private */
    private boundHandleWebGLContextRestored_;
    /**
     * @private
     * @type {string}
     */
    private canvasCacheKey_;
    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    private gl_;
    /**
     * @private
     * @type {!Object<string, BufferCacheEntry>}
     */
    private bufferCache_;
    /**
     * @private
     * @type {Object<string, Object>}
     */
    private extensionCache_;
    /**
     * @private
     * @type {WebGLProgram}
     */
    private currentProgram_;
    /**
     * @private
     * @type boolean
     */
    private needsToBeRecreated_;
    /**
     * @private
     * @type {import("../transform.js").Transform}
     */
    private offsetRotateMatrix_;
    /**
     * @private
     * @type {import("../transform.js").Transform}
     */
    private offsetScaleMatrix_;
    /**
     * @private
     * @type {Array<number>}
     */
    private tmpMat4_;
    /**
     * @private
     * @type {Object<string, Object<string, WebGLUniformLocation>>}
     */
    private uniformLocationsByProgram_;
    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    private attribLocationsByProgram_;
    /**
     * Holds info about custom uniforms used in the post processing pass.
     * If the uniform is a texture, the WebGL Texture object will be stored here.
     * @type {Array<UniformInternalDescription>}
     * @private
     */
    private uniforms_;
    /**
     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
     * options. If no post process was given, a default one is used (so as not to have to make an exception to
     * the frame buffer logic).
     * @type {Array<WebGLPostProcessingPass>}
     * @private
     */
    private postProcessPasses_;
    /**
     * @type {string|null}
     * @private
     */
    private shaderCompileErrors_;
    /**
     * @type {number}
     * @private
     */
    private startTime_;
    /**
     * @param {Object<string, UniformValue>} uniforms Uniform definitions.
     */
    setUniforms(uniforms: {
        [x: string]: UniformValue;
    }): void;
    /**
     * @param {Object<string, UniformValue>} uniforms Uniform definitions.
     */
    addUniforms(uniforms: {
        [x: string]: UniformValue;
    }): void;
    /**
     * @param {string} canvasCacheKey The canvas cache key.
     * @return {boolean} The provided key matches the one this helper was constructed with.
     */
    canvasCacheKeyMatches(canvasCacheKey: string): boolean;
    /**
     * Get a WebGL extension.  If the extension is not supported, null is returned.
     * Extensions are cached after they are enabled for the first time.
     * @param {string} name The extension name.
     * @return {Object|null} The extension or null if not supported.
     */
    getExtension(name: string): any | null;
    /**
     * Just bind the buffer if it's in the cache. Otherwise create
     * the WebGL buffer, bind it, populate it, and add an entry to
     * the cache.
     * @param {import("./Buffer").default} buffer Buffer.
     */
    bindBuffer(buffer: WebGLArrayBuffer): void;
    /**
     * Update the data contained in the buffer array; this is required for the
     * new data to be rendered
     * @param {import("./Buffer").default} buffer Buffer.
     */
    flushBufferData(buffer: WebGLArrayBuffer): void;
    /**
     * @param {import("./Buffer.js").default} buf Buffer.
     */
    deleteBuffer(buf: WebGLArrayBuffer): void;
    /**
     * Clear the buffer & set the viewport to draw.
     * Post process passes will be initialized here, the first one being bound as a render target for
     * subsequent draw calls.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
     * @param {boolean} [enableDepth] If true, enables depth testing.
     */
    prepareDraw(frameState: FrameState, disableAlphaBlend?: boolean, enableDepth?: boolean): void;
    /**
     * @param {WebGLFramebuffer|null} frameBuffer The frame buffer.
     * @param {WebGLTexture} [texture] The texture.
     */
    bindFrameBuffer(frameBuffer: WebGLFramebuffer | null, texture?: WebGLTexture): void;
    /**
     * Bind the frame buffer from the initial render.
     */
    bindInitialFrameBuffer(): void;
    /**
     * Prepare a program to use a texture.
     * @param {WebGLTexture} texture The texture.
     * @param {number} slot The texture slot.
     * @param {string} uniformName The corresponding uniform name.
     */
    bindTexture(texture: WebGLTexture, slot: number, uniformName: string): void;
    /**
     * Set up an attribute array buffer for use in the vertex shader.
     * @param {import("./Buffer").default} buffer The buffer.
     * @param {string} attributeName The attribute name.
     * @param {number} size The number of components per attribute vertex.
     */
    bindAttribute(buffer: WebGLArrayBuffer, attributeName: string, size: number): void;
    /**
     * Clear the render target & bind it for future draw operations.
     * This is similar to `prepareDraw`, only post processes will not be applied.
     * Note: the whole viewport will be drawn to the render target, regardless of its size.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
     * @param {boolean} [enableDepth] If true, enables depth testing.
     */
    prepareDrawToRenderTarget(frameState: FrameState, renderTarget: WebGLRenderTarget, disableAlphaBlend?: boolean, enableDepth?: boolean): void;
    /**
     * Execute a draw call based on the currently bound program, texture, buffers, attributes.
     * @param {number} start Start index.
     * @param {number} end End index.
     */
    drawElements(start: number, end: number): void;
    /**
     * Apply the successive post process passes which will eventually render to the actual canvas.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
     */
    finalizeDraw(frameState: FrameState, preCompose?: (arg0: WebGLRenderingContext, arg1: FrameState) => void, postCompose?: (arg0: WebGLRenderingContext, arg1: FrameState) => void): void;
    /**
     * @return {HTMLCanvasElement} Canvas.
     */
    getCanvas(): HTMLCanvasElement;
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     */
    getGL(): WebGLRenderingContext;
    /**
     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    applyFrameState(frameState: FrameState): void;
    /**
     * Sets the `u_hitDetection` uniform.
     * @param {boolean} enabled Whether to enable the hit detection code path
     */
    applyHitDetectionUniform(enabled: boolean): void;
    /**
     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    applyUniforms(frameState: FrameState): void;
    /**
     * Set up a program for use. The program will be set as the current one. Then, the uniforms used
     * in the program will be set based on the current frame state and the helper configuration.
     * @param {WebGLProgram} program Program.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     */
    useProgram(program: WebGLProgram, frameState?: FrameState): void;
    /**
     * Will attempt to compile a vertex or fragment shader based on source
     * On error, the shader will be returned but
     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
     * Use `gl.getShaderInfoLog(shader)` to have details
     * @param {string} source Shader source
     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
     * @return {WebGLShader} Shader object
     */
    compileShader(source: string, type: ShaderType): WebGLShader;
    /**
     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
     * @param {string} fragmentShaderSource Fragment shader source.
     * @param {string} vertexShaderSource Vertex shader source.
     * @return {WebGLProgram} Program
     */
    getProgram(fragmentShaderSource: string, vertexShaderSource: string): WebGLProgram;
    /**
     * Will get the location from the shader or the cache
     * @param {string} name Uniform name
     * @return {WebGLUniformLocation} uniformLocation
     */
    getUniformLocation(name: string): WebGLUniformLocation;
    /**
     * Will get the location from the shader or the cache
     * @param {string} name Attribute name
     * @return {number} attribLocation
     */
    getAttributeLocation(name: string): number;
    /**
     * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
     * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../transform").Transform} transform Transform to update.
     * @return {import("../transform").Transform} The updated transform object.
     */
    makeProjectionTransform(frameState: FrameState, transform: Transform): Transform;
    /**
     * Give a value for a standard float uniform
     * @param {string} uniform Uniform name
     * @param {number} value Value
     */
    setUniformFloatValue(uniform: string, value: number): void;
    /**
     * Give a value for a vec2 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Array of length 4.
     */
    setUniformFloatVec2(uniform: string, value: Array<number>): void;
    /**
     * Give a value for a vec4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Array of length 4.
     */
    setUniformFloatVec4(uniform: string, value: Array<number>): void;
    /**
     * Give a value for a standard matrix4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Matrix value
     */
    setUniformMatrixValue(uniform: string, value: Array<number>): void;
    /**
     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
     * internally.
     * @param {string} attribName Attribute name
     * @param {number} size Number of components per attributes
     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
     * @param {number} stride Stride in bytes (0 means attribs are packed)
     * @param {number} offset Offset in bytes
     * @private
     */
    private enableAttributeArray_;
    /**
     * Will enable the following attributes to be read from the currently bound buffer,
     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
     */
    enableAttributes(attributes: Array<AttributeDescription>): void;
    /**
     * WebGL context was lost
     * @param {WebGLContextEvent} event The context loss event.
     * @private
     */
    private handleWebGLContextLost;
    /**
     * WebGL context was restored
     * @private
     */
    private handleWebGLContextRestored;
    /**
     * Returns whether this helper needs to be recreated, as the context was lost and then restored.
     * @return {boolean} Whether this helper needs to be recreated.
     */
    needsToBeRecreated(): boolean;
    /**
     * Will create or reuse a given webgl texture and apply the given size. If no image data
     * specified, the texture will be empty, otherwise image data will be used and the `size`
     * parameter will be ignored.  If a Uint8Array is provided for data, a size must also be provided.
     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
     * @param {Array<number>} size Expected size of the texture
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|Uint8Array|null} data Image data/object to bind to the texture
     * @param {WebGLTexture} [texture] Existing texture to reuse
     * @param {boolean} [nearest] Use gl.NEAREST for min/mag filter.
     * @return {WebGLTexture} The generated texture
     */
    createTexture(size: Array<number>, data: ImageData | HTMLImageElement | HTMLCanvasElement | Uint8Array | null, texture?: WebGLTexture, nearest?: boolean): WebGLTexture;
}

type PostProcessesOptions = {
    /**
     * Scale ratio; if < 1, the post process will render to a texture smaller than
     * the main canvas that will then be sampled up (useful for saving resource on blur steps).
     */
    scaleRatio?: number | undefined;
    /**
     * Vertex shader source
     */
    vertexShader?: string | undefined;
    /**
     * Fragment shader source
     */
    fragmentShader?: string | undefined;
    /**
     * Uniform definitions for the post process step
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
};
type Options$$ = {
    /**
     * Uniform definitions for the post process steps
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
    /**
     * Post-processes definitions
     */
    postProcesses?: PostProcessesOptions[] | undefined;
};
/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */
/**
 * @typedef {Object} Options
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */
/**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
declare class WebGLLayerRenderer<LayerType extends Layer> extends LayerRenderer<LayerType> {
    /**
     * @param {LayerType} layer Layer.
     * @param {Options} [options] Options.
     */
    constructor(layer: LayerType, options?: Options$$);
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform is only
     * set before dispatching rendering events.
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private inversePixelTransform_;
    /**
     * @private
     */
    private postProcesses_;
    /**
     * @private
     */
    private uniforms_;
    /**
     * @type {WebGLHelper}
     * @protected
     */
    protected helper: WebGLHelper;
    onMapChanged_: () => void;
    /**
     * @param {WebGLRenderingContext} context The WebGL rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected dispatchPreComposeEvent(context: WebGLRenderingContext, frameState: FrameState): void;
    /**
     * @param {WebGLRenderingContext} context The WebGL rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected dispatchPostComposeEvent(context: WebGLRenderingContext, frameState: FrameState): void;
    /**
     * Reset options (only handles uniforms).
     * @param {Options} options Options.
     */
    reset(options: Options$$): void;
    /**
     * @protected
     */
    protected removeHelper(): void;
    /**
     * @protected
     */
    protected afterHelperCreated(): void;
    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @protected
     */
    protected prepareFrameInternal(frameState: FrameState): boolean;
    /**
     * @protected
     */
    protected clearCache(): void;
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    private dispatchRenderEvent_;
    /**
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected preRender(context: WebGLRenderingContext, frameState: FrameState): void;
    /**
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected postRender(context: WebGLRenderingContext, frameState: FrameState): void;
}

/**
 * A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 */
type CustomAttribute = {
    /**
     * Attribute name.
     */
    name: string;
    /**
     * This callback computes the numerical value of the
     * attribute for a given feature (properties are available as 2nd arg for quicker access).
     */
    callback: (arg0: Feature$2, arg1: {
        [x: string]: any;
    }) => number;
};
type Options$_ = {
    /**
     * A CSS class name to set to the canvas element.
     */
    className?: string | undefined;
    /**
     * These attributes will be read from the features in the source and then
     * passed to the GPU. The `name` property of each attribute will serve as its identifier:
     * * In the vertex shader as an `attribute` by prefixing it with `a_`
     * * In the fragment shader as a `varying` by prefixing it with `v_`
     * Please note that these can only be numerical values.
     */
    attributes?: CustomAttribute[] | undefined;
    /**
     * Vertex shader source, mandatory.
     */
    vertexShader: string;
    /**
     * Fragment shader source, mandatory.
     */
    fragmentShader: string;
    /**
     * Whether shader is hit detection aware.
     */
    hitDetectionEnabled?: boolean | undefined;
    /**
     * Uniform definitions for the post process steps
     * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
    /**
     * Post-processes definitions
     */
    postProcesses?: PostProcessesOptions[] | undefined;
};
/**
 * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 * @property {string} name Attribute name.
 * @property {function(import("../../Feature").default, Object<string, *>):number} callback This callback computes the numerical value of the
 * attribute for a given feature (properties are available as 2nd arg for quicker access).
 */
/**
 * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize
 * rebuildBuffers by accessing these objects quicker.
 * @property {import("../../Feature").default} feature Feature
 * @property {Object<string, *>} properties Feature properties
 * @property {import("../../geom").Geometry} geometry Feature geometry
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.
 * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then
 * passed to the GPU. The `name` property of each attribute will serve as its identifier:
 *  * In the vertex shader as an `attribute` by prefixing it with `a_`
 *  * In the fragment shader as a `varying` by prefixing it with `v_`
 * Please note that these can only be numerical values.
 * @property {string} vertexShader Vertex shader source, mandatory.
 * @property {string} fragmentShader Fragment shader source, mandatory.
 * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.
 * @property {Array<import("./Layer").PostProcessesOptions>} [postProcesses] Post-processes definitions
 */
/**
 * @classdesc
 * WebGL vector renderer optimized for points.
 * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU
 * every time the vector source changes.
 *
 * You need to provide vertex and fragment shaders for rendering. This can be done using
 * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute
 * containing the screen-space projected center of the quad, as well as a `a_index` attribute
 * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).
 *
 * To include variable attributes in the shaders, you need to declare them using the `attributes` property of
 * the options object like so:
 * ```js
 * new WebGLPointsLayerRenderer(layer, {
 *   attributes: [
 *     {
 *       name: 'size',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *     {
 *       name: 'weight',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *   ],
 *   vertexShader:
 *     // shader using attribute a_weight and a_size
 *   fragmentShader:
 *     // shader using varying v_weight and v_size
 * ```
 *
 * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`
 * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain
 * the final color that will have to be output for hit detection to work.
 *
 * The following uniform is used for the main texture: `u_texture`.
 * The following uniform is used for the layer opacity: `u_opacity`.
 *
 * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.
 *
 * Points are rendered as quads with the following structure:
 *
 * ```
 *   (u0, v1)      (u1, v1)
 *  [3]----------[2]
 *   |`           |
 *   |  `         |
 *   |    `       |
 *   |      `     |
 *   |        `   |
 *   |          ` |
 *  [0]----------[1]
 *   (u0, v0)      (u1, v0)
 *  ```
 *
 * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.
 *
 * @api
 */
declare class WebGLPointsLayerRenderer extends WebGLLayerRenderer<any> {
    /**
     * @param {import("../../layer/Layer.js").default} layer Layer.
     * @param {Options} options Options.
     */
    constructor(layer: Layer, options: Options$_);
    /**
     * @private
     */
    private sourceRevision_;
    /**
     * @private
     */
    private verticesBuffer_;
    /**
     * @private
     */
    private indicesBuffer_;
    /**
     * @private
     */
    private vertexShader_;
    /**
     * @private
     */
    private fragmentShader_;
    /**
     * @type {WebGLProgram}
     * @private
     */
    private program_;
    /**
     * @type {boolean}
     * @private
     */
    private hitDetectionEnabled_;
    /**
     * A list of attributes used by the renderer. By default only the position and
     * index of the vertex (0 to 3) are required.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */
    attributes: Array<AttributeDescription>;
    customAttributes: CustomAttribute[];
    /**
     * @private
     */
    private previousExtent_;
    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private currentTransform_;
    /**
     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private renderTransform_;
    /**
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private invertRenderTransform_;
    /**
     * @type {Float32Array}
     * @private
     */
    private renderInstructions_;
    /**
     * @type {WebGLRenderTarget}
     * @private
     */
    private hitRenderTarget_;
    /**
     * Keep track of latest message sent to worker
     * @type {number}
     * @private
     */
    private lastSentId;
    /**
     * @private
     */
    private worker_;
    /**
     * This object will be updated when the source changes. Key is uid.
     * @type {Object<string, FeatureCacheItem>}
     * @private
     */
    private featureCache_;
    /**
     * Amount of features in the cache.
     * @type {number}
     * @private
     */
    private featureCount_;
    /**
     * @private
     */
    private sourceListenKeys_;
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceFeatureAdded_;
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceFeatureChanged_;
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceFeatureDelete_;
    /**
     * @private
     */
    private handleSourceFeatureClear_;
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    override renderFrame(frameState: FrameState): HTMLElement;
    /**
     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
     * @param {import("../../Map").FrameState} frameState Frame state.
     * @private
     */
    private rebuildBuffers_;
    /**
     * Render the world, either to the main framebuffer or to the hit framebuffer
     * @param {import("../../Map.js").FrameState} frameState current frame state
     * @param {boolean} forHitDetection whether the rendering is for hit detection
     * @param {number} startWorld the world to render in the first iteration
     * @param {number} endWorld the last world to render
     * @param {number} worldWidth the width of the worlds being rendered
     */
    renderWorlds(frameState: FrameState, forHitDetection: boolean, startWorld: number, endWorld: number, worldWidth: number): void;
    renderDeclutter(): void;
}

type Options$Z<VectorSourceType extends VectorSource<FeatureType> = VectorSource<any>, FeatureType extends FeatureLike = ExtractedFeatureType$1<VectorSourceType>> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Render order. Function to be used when sorting
     * features before rendering. By default features are drawn in the order that they are created. Use
     * `null` to avoid the sort, but get an undefined draw order.
     */
    renderOrder?: OrderFunction | undefined;
    /**
     * The buffer in pixels around the viewport extent used by the
     * renderer when getting features from the vector source for the rendering or hit-detection.
     * Recommended value: the size of the largest symbol, line width or label.
     */
    renderBuffer?: number | undefined;
    /**
     * Source.
     */
    source?: VectorSourceType | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use [map.addLayer()]{@link import ("../Map.js").default#addLayer}.
     */
    map?: Map | undefined;
    /**
     * Declutter images and text on this layer. Any truthy value will enable
     * decluttering. The priority is defined by the `zIndex` of the style and the render order of features. Higher z-index means higher
     * priority. Within the same z-index, a feature rendered before another has higher priority. Items will
     * not be decluttered against or together with items on other layers with the same `declutter` value. If
     * that is needed, use {@link import ("../layer/Vector.js").default} instead.
     */
    declutter?: string | number | boolean | undefined;
    /**
     * Layer style. When set to `null`, only
     * features that have their own style will be rendered. See {@link module :ol/style/Style~Style} for the default style
     * which will be used if this is not set.
     */
    style?: StyleLike | FlatStyleLike | null | undefined;
    /**
     * Background color for the layer. If not specified, no background
     * will be rendered.
     */
    background?: BackgroundColor | undefined;
    /**
     * Ratio by which the rendered extent should be larger than the
     * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
     */
    imageRatio?: number | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("./BaseVector.js").ExtractedFeatureType<VectorSourceType>]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean|string|number} [declutter=false] Declutter images and text on this layer. Any truthy value will enable
 * decluttering. The priority is defined by the `zIndex` of the style and the render order of features. Higher z-index means higher
 * priority. Within the same z-index, a feature rendered before another has higher priority. Items will
 * not be decluttered against or together with items on other layers with the same `declutter` value. If
 * that is needed, use {@link import("../layer/Vector.js").default} instead.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the
 * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Vector data is rendered client-side, to an image. This layer type provides great performance
 * during panning and zooming, but point symbols and texts are always rotated with the view and
 * pixels are scaled during zoom animations. For more accurate rendering of vector data, use
 * {@link module:ol/layer/Vector~VectorLayer} instead.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("./BaseVector.js").ExtractedFeatureType<VectorSourceType>]
 * @extends {BaseVectorLayer<FeatureType, VectorSourceType, CanvasVectorImageLayerRenderer>}
 * @api
 */
declare class VectorImageLayer<VectorSourceType extends VectorSource<FeatureType> = VectorSource<any>, FeatureType extends FeatureLike = ExtractedFeatureType$1<VectorSourceType>> extends BaseVectorLayer<FeatureType, VectorSourceType, CanvasVectorImageLayerRenderer> {
    /**
     * @param {Options<VectorSourceType, FeatureType>} [options] Options.
     */
    constructor(options?: Options$Z<VectorSourceType, FeatureType>);
    /**
     * @type {number}
     * @private
     */
    private imageRatio_;
    /**
     * @return {number} Ratio between rendered extent size and viewport extent size.
     */
    getImageRatio(): number;
}

/**
 * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */
declare class ImageSourceEvent extends BaseEvent {
    /**
     * @param {string} type Type.
     * @param {import("../Image.js").default} image The image.
     */
    constructor(type: string, image: ImageWrapper);
    /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */
    image: ImageWrapper;
}

type ImageSourceEventTypes = "imageloadend" | "imageloaderror" | "imageloadstart";
/**
 * *
 */
type ImageSourceOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2, ObjectEvent, Return> & OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | ImageSourceEventTypes, Return>;
type Options$Y = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Loader. Can either be a custom loader, or one of the
     * loaders created with a `createLoader()` function ({@link module :ol/source/wms.createLoader wms},
     * {@link module :ol/source/arcgisRest.createLoader arcgisRest}, {@link module :ol/source/mapguide.createLoader mapguide},
     * {@link module :ol/source/static.createLoader static}).
     */
    loader?: Loader$3 | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * Resolutions.
     */
    resolutions?: number[] | undefined;
    /**
     * State.
     */
    state?: State$2 | undefined;
};

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../Image.js").Loader} [loader] Loader. Can either be a custom loader, or one of the
 * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},
 * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},
 * {@link module:ol/source/static.createLoader static}).
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {Array<number>} [resolutions] Resolutions.
 * @property {import("./Source.js").State} [state] State.
 */
/**
 * @classdesc
 * Base class for sources providing a single image.
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
declare class ImageSource extends Source {
    /**
     * @param {Options} options Single image source options.
     */
    constructor(options: Options$Y);
    /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */
    on: ImageSourceOnSignature<EventsKey>;
    /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */
    once: ImageSourceOnSignature<EventsKey>;
    /***
     * @type {ImageSourceOnSignature<void>}
     */
    un: ImageSourceOnSignature<void>;
    /**
     * @protected
     * @type {import("../Image.js").Loader}
     */
    protected loader: Loader$3;
    /**
     * @private
     * @type {Array<number>|null}
     */
    private resolutions_;
    /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */
    private reprojectedImage_;
    /**
     * @private
     * @type {number}
     */
    private reprojectedRevision_;
    /**
     * @protected
     * @type {import("../Image.js").default}
     */
    protected image: ImageWrapper;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private wantedExtent_;
    /**
     * @private
     * @type {number}
     */
    private wantedResolution_;
    /**
     * @private
     * @type {boolean}
     */
    private static_;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    private wantedProjection_;
    /**
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    override getResolutions(): Array<number> | null;
    /**
     * @param {Array<number>|null} resolutions Resolutions.
     */
    setResolutions(resolutions: Array<number> | null): void;
    /**
     * @protected
     * @param {number} resolution Resolution.
     * @return {number} Resolution.
     */
    protected findNearestResolution(resolution: number): number;
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
    getImage(extent: Extent$1, resolution: number, pixelRatio: number, projection: Projection): ImageWrapper;
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     * @protected
     */
    protected getImageInternal(extent: Extent$1, resolution: number, pixelRatio: number, projection: Projection): ImageWrapper;
    /**
     * Handle image change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    protected handleImageChange(event: BaseEvent): void;
}

type Options$X<ImageSourceType extends ImageSource> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link import ("../Map.js").default#addLayer map.addLayer()}.
     */
    map?: Map | undefined;
    /**
     * Source for this layer.
     */
    source?: ImageSourceType | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @template {import("../source/Image.js").default} ImageSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {ImageSourceType} [source] Source for this layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<ImageSourceType, RendererType>}
 * @api
 */
declare class BaseImageLayer<ImageSourceType extends ImageSource, RendererType extends LayerRenderer<any>> extends Layer<ImageSourceType, RendererType> {
    /**
     * @param {Options<ImageSourceType>} [options] Layer options.
     */
    constructor(options?: Options$X<ImageSourceType>);
}

/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}
 * @api
 */
declare class ImageLayer<ImageSourceType extends ImageSource> extends BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer> {
    /**
     * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
     */
    constructor(options?: Options$X<ImageSourceType>);
}
//# sourceMappingURL=Image.d.ts.map

/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
declare class CanvasLayerRenderer<LayerType extends Layer> extends LayerRenderer<LayerType> {
    /**
     * @protected
     * @type {HTMLElement}
     */
    protected container: HTMLElement;
    /**
     * @protected
     * @type {number}
     */
    protected renderedResolution: number;
    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    protected tempTransform: Transform;
    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    protected pixelTransform: Transform;
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    protected inversePixelTransform: Transform;
    /**
     * @type {CanvasRenderingContext2D}
     */
    context: CanvasRenderingContext2D;
    /**
     * @private
     * @type {ZIndexContext}
     */
    private deferredContext_;
    /**
     * @type {boolean}
     */
    containerReused: boolean;
    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    protected frameState: FrameState | null;
    /**
     * @param {import('../../DataTile.js').ImageLike} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */
    getImageData(image: ImageLike, col: number, row: number): Uint8ClampedArray | null;
    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
    getBackground(frameState: FrameState): string;
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */
    useContainer(target: HTMLElement, transform: string, backgroundColor?: string): void;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
    protected clipUnrotated(context: CanvasRenderingContext2D, frameState: FrameState, extent: Extent$1): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @protected
     */
    protected prepareContainer(frameState: FrameState, target: HTMLElement): void;
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    private dispatchRenderEvent_;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected preRender(context: CanvasRenderingContext2D, frameState: FrameState): void;
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected postRender(context: CanvasRenderingContext2D, frameState: FrameState): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeferredInternal(frameState: FrameState): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
     */
    getRenderContext(frameState: FrameState): ZIndexContextProxy;
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
    protected getRenderTransform(center: Coordinate, resolution: number, rotation: number, pixelRatio: number, width: number, height: number, offsetX: number): Transform;
}

/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
declare class CanvasImageLayerRenderer extends CanvasLayerRenderer<any> {
    /**
     * @param {import("../../layer/Image.js").default} imageLayer Image layer.
     */
    constructor(imageLayer: ImageLayer<any>);
    /**
     * @protected
     * @type {?import("../../Image.js").default}
     */
    protected image: ImageWrapper | null;
    /**
     * @return {import('../../DataTile.js').ImageLike} Image.
     */
    getImage(): ImageLike;
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     * @override
     */
    override getData(pixel: Pixel): Uint8ClampedArray;
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    override renderFrame(frameState: FrameState, target: HTMLElement): HTMLElement;
}
//# sourceMappingURL=ImageLayer.d.ts.map

/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
declare class CanvasVectorImageLayerRenderer extends CanvasImageLayerRenderer {
    /**
     * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
     */
    constructor(layer: VectorImageLayer);
    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */
    private vectorRenderer_;
    /**
     * @private
     * @type {number}
     */
    private layerImageRatio_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private coordinateToVectorPixelTransform_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private renderedPixelToCoordinateTransform_;
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
     * @override
     */
    override getFeatures(pixel: Pixel): Promise<Array<Feature$2>>;
    /**
     * @override
     */
    override preRender(): void;
    /**
     * @override
     */
    override postRender(): void;
    /**
     */
    renderDeclutter(): void;
}
//# sourceMappingURL=VectorImageLayer.d.ts.map

type Options$W = {
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * If `true` hidpi tiles will be requested.
     */
    hidpi?: boolean | undefined;
    /**
     * Culture code.
     */
    culture?: string | undefined;
    /**
     * Bing Maps API key. Get yours at https://www.bingmapsportal.com/.
     */
    key: string;
    /**
     * Type of imagery.
     */
    imagerySet: string;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Max zoom. Default is what's advertized by the BingMaps service.
     */
    maxZoom?: number | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
    /**
     * Whether to show BingMaps placeholder tiles when zoomed past the maximum level provided in an area. When `false`, requests beyond
     * the maximum zoom level will return no tile. When `true`, the placeholder tile will be returned. When not set, the default behaviour of the imagery set takes place,
     * which is unique for each imagery set in BingMaps.
     */
    placeholderTiles?: boolean | undefined;
};
type BingMapsImageryMetadataResponse = {
    /**
     * The response status code
     */
    statusCode: number;
    /**
     * The response status description
     */
    statusDescription: string;
    /**
     * The authentication result code
     */
    authenticationResultCode: string;
    /**
     * The array of resource sets
     */
    resourceSets: Array<ResourceSet>;
};
type ResourceSet = {
    /**
     * Resources.
     */
    resources: Array<Resource>;
};
type Resource = {
    /**
     * The image height
     */
    imageHeight: number;
    /**
     * The image width
     */
    imageWidth: number;
    /**
     * The minimum zoom level
     */
    zoomMin: number;
    /**
     * The maximum zoom level
     */
    zoomMax: number;
    /**
     * The image URL
     */
    imageUrl: string;
    /**
     * The image URL subdomains for rotation
     */
    imageUrlSubdomains: Array<string>;
    /**
     * The array of ImageryProviders
     */
    imageryProviders?: ImageryProvider[] | undefined;
};
type ImageryProvider = {
    /**
     * The coverage areas
     */
    coverageAreas: Array<CoverageArea>;
    /**
     * The attribution
     */
    attribution?: string | undefined;
};
type CoverageArea = {
    /**
     * The minimum zoom
     */
    zoomMin: number;
    /**
     * The maximum zoom
     */
    zoomMax: number;
    /**
     * The coverage bounding box
     */
    bbox: Array<number>;
};
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {boolean} [hidpi=false] If `true` hidpi tiles will be requested.
 * @property {string} [culture='en-us'] Culture code.
 * @property {string} key Bing Maps API key. Get yours at https://www.bingmapsportal.com/.
 * @property {string} imagerySet Type of imagery.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=21] Max zoom. Default is what's advertized by the BingMaps service.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {boolean} [placeholderTiles] Whether to show BingMaps placeholder tiles when zoomed past the maximum level provided in an area. When `false`, requests beyond
 * the maximum zoom level will return no tile. When `true`, the placeholder tile will be returned. When not set, the default behaviour of the imagery set takes place,
 * which is unique for each imagery set in BingMaps.
 */
/**
 * @typedef {Object} BingMapsImageryMetadataResponse
 * @property {number} statusCode The response status code
 * @property {string} statusDescription The response status description
 * @property {string} authenticationResultCode The authentication result code
 * @property {Array<ResourceSet>} resourceSets The array of resource sets
 */
/**
 * @typedef {Object} ResourceSet
 * @property {Array<Resource>} resources Resources.
 */
/**
 * @typedef {Object} Resource
 * @property {number} imageHeight The image height
 * @property {number} imageWidth The image width
 * @property {number} zoomMin The minimum zoom level
 * @property {number} zoomMax The maximum zoom level
 * @property {string} imageUrl The image URL
 * @property {Array<string>} imageUrlSubdomains The image URL subdomains for rotation
 * @property {Array<ImageryProvider>} [imageryProviders] The array of ImageryProviders
 */
/**
 * @typedef {Object} ImageryProvider
 * @property {Array<CoverageArea>} coverageAreas The coverage areas
 * @property {string} [attribution] The attribution
 */
/**
 * @typedef {Object} CoverageArea
 * @property {number} zoomMin The minimum zoom
 * @property {number} zoomMax The maximum zoom
 * @property {Array<number>} bbox The coverage bounding box
 */
/**
 * @classdesc
 * Layer source for Bing Maps tile data.
 * @api
 */
declare class BingMaps extends TileImage {
    /**
     * @param {Options} options Bing Maps options.
     */
    constructor(options: Options$W);
    /**
     * @private
     * @type {boolean}
     */
    private hidpi_;
    /**
     * @private
     * @type {string}
     */
    private culture_;
    /**
     * @private
     * @type {number}
     */
    private maxZoom_;
    /**
     * @private
     * @type {string}
     */
    private apiKey_;
    /**
     * @private
     * @type {string}
     */
    private imagerySet_;
    /**
     * @private
     * @type {boolean|undefined}
     */
    private placeholderTiles_;
    /**
     * Get the api key used for this source.
     *
     * @return {string} The api key.
     * @api
     */
    getApiKey(): string;
    /**
     * Get the imagery set associated with this source.
     *
     * @return {string} The imagery set.
     * @api
     */
    getImagerySet(): string;
    /**
     * @param {BingMapsImageryMetadataResponse} response Response.
     */
    handleImageryMetadataResponse(response: BingMapsImageryMetadataResponse): void;
}

type Options$V = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional max zoom level. Not used if `tileGrid` is provided.
     */
    maxZoom?: number | undefined;
    /**
     * Optional min zoom level. Not used if `tileGrid` is provided.
     */
    minZoom?: number | undefined;
    /**
     * Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
     */
    maxResolution?: number | undefined;
    /**
     * Tile grid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * Deprecated.  Use an ImageTile source with a loader
     * instead.  Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * The pixel ratio used by the tile service.
     * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     */
    tilePixelRatio?: number | undefined;
    /**
     * The tile size used by the tile service.
     * Not used if `tileGrid` is provided.
     */
    tileSize?: number | Size | undefined;
    /**
     * The size in pixels of the gutter around image tiles to ignore.
     * This allows artifacts of rendering at tile edges to be ignored.
     * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
     */
    gutter?: number | undefined;
    /**
     * Deprecated.  Use an ImageTile source and provide a function
     * for the url option instead.
     */
    tileUrlFunction?: UrlFunction | undefined;
    /**
     * URL template. Must include `{x}`, `{y}` or `{-y}`,
     * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
     * may be used instead of defining each one separately in the `urls` option.
     */
    url?: string | undefined;
    /**
     * Deprecated.  Use an ImageTile source and provide an array of URLs for the
     * url option instead.
     */
    urls?: string[] | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Deprecated.  Use an ImageTile source with a loader
 * instead.  Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function
 * for the url option instead.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] Deprecated.  Use an ImageTile source and provide an array of URLs for the
 * url option instead.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
declare class XYZ extends TileImage {
    /**
     * @param {Options} [options] XYZ options.
     */
    constructor(options?: Options$V);
    /**
     * @private
     * @type {number}
     */
    private gutter_;
}

type Options$U = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * Max zoom.
     */
    maxZoom?: number | undefined;
    /**
     * Minimum zoom.
     */
    minZoom?: number | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * If using anonymous maps, the CartoDB config to use. See
     * https://carto.com/developers/maps-api/guides/anonymous-maps/
     * for more detail.
     * If using named maps, a key-value lookup with the template parameters.
     * See https://carto.com/developers/maps-api/guides/named-maps/
     * for more detail.
     */
    config?: any;
    /**
     * If using named maps, this will be the name of the template to load.
     * See https://carto.com/developers/maps-api/guides/named-maps/
     * for more detail.
     */
    map?: string | undefined;
    /**
     * Username as used to access public Carto dashboard at https://{username}.carto.com/.
     */
    account?: string | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [maxZoom=18] Max zoom.
 * @property {number} [minZoom] Minimum zoom.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See
 * https://carto.com/developers/maps-api/guides/anonymous-maps/
 * for more detail.
 * If using named maps, a key-value lookup with the template parameters.
 * See https://carto.com/developers/maps-api/guides/named-maps/
 * for more detail.
 * @property {string} [map] If using named maps, this will be the name of the template to load.
 * See https://carto.com/developers/maps-api/guides/named-maps/
 * for more detail.
 * @property {string} [account] Username as used to access public Carto dashboard at https://{username}.carto.com/.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @typedef {Object} CartoDBLayerInfo
 * @property {string} layergroupid The layer group ID
 * @property {{https: string}} cdn_url The CDN URL
 */
/**
 * @classdesc
 * Layer source for the CartoDB Maps API.
 * @api
 */
declare class CartoDB extends XYZ {
    /**
     * @param {Options} options CartoDB options.
     */
    constructor(options: Options$U);
    /**
     * @type {string}
     * @private
     */
    private account_;
    /**
     * @type {string}
     * @private
     */
    private mapId_;
    /**
     * @type {!Object}
     * @private
     */
    private config_;
    /**
     * @type {!Object<string, CartoDBLayerInfo>}
     * @private
     */
    private templateCache_;
    /**
     * Returns the current config.
     * @return {!Object} The current configuration.
     * @api
     */
    getConfig(): any;
    /**
     * Updates the carto db config.
     * @param {Object} config a key-value lookup. Values will replace current values
     *     in the config.
     * @api
     */
    updateConfig(config: any): void;
    /**
     * Sets the CartoDB config
     * @param {Object} config In the case of anonymous maps, a CartoDB configuration
     *     object.
     * If using named maps, a key-value lookup with the template parameters.
     * @api
     */
    setConfig(config: any): void;
    /**
     * Issue a request to initialize the CartoDB map.
     * @private
     */
    private initializeMap_;
    /**
     * Handle map initialization response.
     * @param {string} paramHash a hash representing the parameter set that was used
     *     for the request
     * @param {Event} event Event.
     * @private
     */
    private handleInitResponse_;
    /**
     * @private
     * @param {Event} event Event.
     */
    private handleInitError_;
    /**
     * Apply the new tile urls returned by carto db
     * @param {CartoDBLayerInfo} data Result of carto db call.
     * @private
     */
    private applyTemplate_;
}

type Options$T<FeatureType extends FeatureLike> = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Distance in pixels within which features will
     * be clustered together.
     */
    distance?: number | undefined;
    /**
     * Minimum distance in pixels between clusters.
     * Will be capped at the configured distance.
     * By default no minimum distance is guaranteed. This config can be used to avoid
     * overlapping icons. As a tradoff, the cluster feature's position will no longer be
     * the center of all its features.
     */
    minDistance?: number | undefined;
    /**
     * Function that takes a {@link module :ol/Feature~Feature} as argument and returns a
     * {@link module :ol/geom/Point~Point} as cluster calculation point for the feature. When a
     * feature should not be considered for clustering, the function should return
     * `null`. The default, which works when the underlying source contains point
     * features only, is
     * ```js
     * function(feature) {
     * return feature.getGeometry();
     * }
     * ```
     * See {@link module :ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
     * calculation point for polygons.
     */
    geometryFunction?: ((arg0: FeatureType) => (Point$1 | null)) | undefined;
    /**
     * Function that takes the cluster's center {@link module :ol/geom/Point~Point} and an array
     * of {@link module :ol/Feature~Feature} included in this cluster. Must return a
     * {@link module :ol/Feature~Feature} that will be used to render. Default implementation is:
     * ```js
     * function(point, features) {
     * return new Feature({
     * geometry: point,
     * features: features
     * });
     * }
     * ```
     */
    createCluster?: ((arg0: Point$1, arg1: Array<FeatureType>) => Feature$2) | undefined;
    /**
     * Source.
     */
    source?: VectorSource<FeatureType> | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
};
/**
 * @template {import("../Feature.js").FeatureLike} FeatureType
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Distance in pixels within which features will
 * be clustered together.
 * @property {number} [minDistance=0] Minimum distance in pixels between clusters.
 * Will be capped at the configured distance.
 * By default no minimum distance is guaranteed. This config can be used to avoid
 * overlapping icons. As a tradoff, the cluster feature's position will no longer be
 * the center of all its features.
 * @property {function(FeatureType):(Point|null)} [geometryFunction]
 * Function that takes a {@link module:ol/Feature~Feature} as argument and returns a
 * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underlying source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {function(Point, Array<FeatureType>):Feature} [createCluster]
 * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array
 * of {@link module:ol/Feature~Feature} included in this cluster. Must return a
 * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:
 * ```js
 * function(point, features) {
 *   return new Feature({
 *     geometry: point,
 *     features: features
 *   });
 * }
 * ```
 * @property {VectorSource<FeatureType>} [source=null] Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */
/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * If the instance is disposed without also disposing the underlying
 * source `setSource(null)` has to be called to remove the listener reference
 * from the wrapped source.
 * @api
 * @template {import('../Feature.js').FeatureLike} FeatureType
 * @extends {VectorSource<Feature<import("../geom/Geometry.js").default>>}
 */
declare class Cluster<FeatureType extends FeatureLike> extends VectorSource<Feature$2<Geometry$1>> {
    /**
     * @param {Options<FeatureType>} [options] Cluster options.
     */
    constructor(options?: Options$T<FeatureType>);
    /**
     * @type {number|undefined}
     * @protected
     */
    protected resolution: number | undefined;
    /**
     * @type {number}
     * @protected
     */
    protected distance: number;
    /**
     * @type {number}
     * @protected
     */
    protected minDistance: number;
    /**
     * @type {number}
     * @protected
     */
    protected interpolationRatio: number;
    /**
     * @type {Array<Feature>}
     * @protected
     */
    protected features: Array<Feature$2>;
    /**
     * @param {FeatureType} feature Feature.
     * @return {Point} Cluster calculation point.
     * @protected
     */
    protected geometryFunction: (arg0: FeatureType) => (Point$1 | null);
    /**
     * @type {function(Point, Array<FeatureType>):Feature}
     * @private
     */
    private createCustomCluster_;
    /**
     * @type {VectorSource<FeatureType>|null}
     * @protected
     */
    protected source: VectorSource<FeatureType> | null;
    /**
     * @private
     */
    private boundRefresh_;
    /**
     * Get the distance in pixels between clusters.
     * @return {number} Distance.
     * @api
     */
    getDistance(): number;
    /**
     * Get a reference to the wrapped source.
     * @return {VectorSource<FeatureType>|null} Source.
     * @api
     */
    getSource(): VectorSource<FeatureType> | null;
    /**
     * Set the distance within which features will be clusterd together.
     * @param {number} distance The distance in pixels.
     * @api
     */
    setDistance(distance: number): void;
    /**
     * Set the minimum distance between clusters. Will be capped at the
     * configured distance.
     * @param {number} minDistance The minimum distance in pixels.
     * @api
     */
    setMinDistance(minDistance: number): void;
    /**
     * The configured minimum distance between clusters.
     * @return {number} The minimum distance in pixels.
     * @api
     */
    getMinDistance(): number;
    /**
     * Replace the wrapped source.
     * @param {VectorSource<FeatureType>|null} source The new source for this instance.
     * @api
     */
    setSource(source: VectorSource<FeatureType> | null): void;
    /**
     * Update the distances and refresh the source if necessary.
     * @param {number} distance The new distance.
     * @param {number} minDistance The new minimum distance.
     */
    updateDistance(distance: number, minDistance: number): void;
    /**
     * @protected
     */
    protected cluster(): void;
    /**
     * @param {Array<FeatureType>} features Features
     * @param {import("../extent.js").Extent} extent The searched extent for these features.
     * @return {Feature} The cluster feature.
     * @protected
     */
    protected createCluster(features: Array<FeatureType>, extent: Extent$1): Feature$2;
}

type CrossOriginAttribute = "anonymous" | "use-credentials";
type LoaderOptions$4 = {
    /**
     * An abort controller signal.
     */
    signal: AbortSignal;
    /**
     * The cross-origin attribute for images.
     */
    crossOrigin?: CrossOriginAttribute | undefined;
    /**
     * The maximum y coordinate at the given z level.  Will be undefined if the
     * underlying tile grid does not have a known extent.
     */
    maxY?: number | undefined;
};
/**
 * Data tile loading function.  The function is called with z, x, and y tile coordinates and
 * returns {@link import ("../DataTile.js").Data data} for a tile or a promise for the same.
 */
type Loader$1 = (arg0: number, arg1: number, arg2: number, arg3: LoaderOptions$4) => (Data | Promise<Data>);
type Options$S = {
    /**
     * Data loader.  Called with z, x, and y tile coordinates.
     * Returns {@link import ("../DataTile.js").Data data} for a tile or a promise for the same.
     * For loaders that generate images, the promise should not resolve until the image is loaded.
     */
    loader?: Loader$1 | undefined;
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Optional max zoom level. Not used if `tileGrid` is provided.
     */
    maxZoom?: number | undefined;
    /**
     * Optional min zoom level. Not used if `tileGrid` is provided.
     */
    minZoom?: number | undefined;
    /**
     * The pixel width and height of the source tiles.
     * This may be different than the rendered pixel size if a `tileGrid` is provided.
     */
    tileSize?: number | Size | undefined;
    /**
     * The size in pixels of the gutter around data tiles to ignore.
     * This allows artifacts of rendering at tile edges to be ignored.
     * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.
     */
    gutter?: number | undefined;
    /**
     * Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
     */
    maxResolution?: number | undefined;
    /**
     * Tile projection.
     */
    projection?: ProjectionLike;
    /**
     * Tile grid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * The source state.
     */
    state?: State$2 | undefined;
    /**
     * Render tiles beyond the antimeridian.
     */
    wrapX?: boolean | undefined;
    /**
     * Transition time when fading in new tiles (in milliseconds).
     */
    transition?: number | undefined;
    /**
     * Number of bands represented in the data.
     */
    bandCount?: number | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
    /**
     * The crossOrigin property to pass to loaders for image data.
     */
    crossOrigin?: CrossOriginAttribute | undefined;
    /**
     * Key for use in caching tiles.
     */
    key?: string | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute
 */
/**
 * @typedef {Object} LoaderOptions
 * @property {AbortSignal} signal An abort controller signal.
 * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.
 * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the
 * underlying tile grid does not have a known extent.
 */
/**
 * Data tile loading function.  The function is called with z, x, and y tile coordinates and
 * returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
 * @typedef {function(number, number, number, LoaderOptions) : (import("../DataTile.js").Data|Promise<import("../DataTile.js").Data>)} Loader
 */
/**
 * @typedef {Object} Options
 * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.
 * Returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.
 * This may be different than the rendered pixel size if a `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Tile projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("./Source.js").State} [state] The source state.
 * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.
 * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).
 * @property {number} [bandCount=4] Number of bands represented in the data.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.
 * @property {string} [key] Key for use in caching tiles.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * A source for typed array data tiles.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @template {import("../Tile.js").default} [TileType=DataTile]
 * @extends TileSource<TileType>
 * @api
 */
declare class DataTileSource<TileType extends Tile$1 = DataTile> extends TileSource<TileType> {
    /**
     * @param {Options} options DataTile source options.
     */
    constructor(options: Options$S);
    /**
     * @private
     * @type {number}
     */
    private gutter_;
    /**
     * @private
     * @type {import('../size.js').Size|null}
     */
    private tileSize_;
    /**
     * @private
     * @type {Array<import('../size.js').Size>|null}
     */
    private tileSizes_;
    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    private tileLoadingKeys_;
    /**
     * @private
     */
    private loader_;
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     */
    handleTileChange_(event: BaseEvent): void;
    /**
     * @type {number}
     */
    bandCount: number;
    /**
     * @private
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    private tileGridForProjection_;
    /**
     * @private
     * @type {CrossOriginAttribute}
     */
    private crossOrigin_;
    /**
     * @type {import("../transform.js").Transform|null}
     */
    transformMatrix: Transform | null;
    /**
     * Set the source tile sizes.  The length of the array is expected to match the number of
     * levels in the tile grid.
     * @protected
     * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.
     */
    protected setTileSizes(tileSizes: Array<Size>): void;
    /**
     * Get the source tile size at the given zoom level.  This may be different than the rendered tile
     * size.
     * @protected
     * @param {number} z Tile zoom level.
     * @return {import('../size.js').Size} The source tile size.
     */
    protected getTileSize(z: number): Size;
    /**
     * @param {Loader} loader The data loader.
     * @protected
     */
    protected setLoader(loader: Loader$1): void;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../proj/Projection.js").default} targetProj The output projection.
     * @param {import("../proj/Projection.js").default} sourceProj The input projection.
     * @return {!TileType} Tile.
     */
    getReprojTile_(z: number, x: number, y: number, targetProj: Projection, sourceProj: Projection): TileType;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {TileType|null} Tile (or null if outside source extent).
     * @override
     */
    override getTile(z: number, x: number, y: number, pixelRatio: number, projection?: Projection): TileType | null;
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
    setTileGridForProjection(projection: ProjectionLike, tilegrid: TileGrid): void;
}

/**
 * @module pool
 */
/**
 * Pool for workers to decode chunks of the images.
 */
declare class Pool {
    /**
     * @constructor
     * @param {Number} [size] The size of the pool. Defaults to the number of CPUs
     *                      available. When this parameter is `null` or 0, then the
     *                      decoding will be done in the main thread.
     * @param {function(): Worker} [createWorker] A function that creates the decoder worker.
     * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`
     * function is expected to return a `Worker` compatible with Web Workers. For code that
     * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.
     *
     * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:
     * ```js
     * import { addDecoder, getDecoder } from 'geotiff';
     * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));
     * self.addEventListener('message', async (e) => {
     *   const { id, fileDirectory, buffer } = e.data;
     *   const decoder = await getDecoder(fileDirectory);
     *   const decoded = await decoder.decode(fileDirectory, buffer);
     *   self.postMessage({ decoded, id }, [decoded]);
     * });
     * ```
     * The way the above code is built into a worker by the `createWorker()` function
     * depends on the used bundler. For most bundlers, something like this will work:
     * ```js
     * function createWorker() {
     *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));
     * }
     * ```
     */
    constructor(size?: number | undefined, createWorker?: (() => Worker) | undefined);
    workers: any[] | null;
    _awaitingDecoder: Promise<any> | null;
    size: number;
    messageId: number;
    /**
     * Decode the given block of bytes with the set compression method.
     * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
     * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`
     */
    decode(fileDirectory: any, buffer: ArrayBuffer): Promise<ArrayBuffer>;
    destroy(): void;
}
//# sourceMappingURL=pool.d.ts.map

/**
 * @typedef Slice
 * @property {number} offset
 * @property {number} length
 */
declare class BaseSource {
    /**
     *
     * @param {Slice[]} slices
     * @returns {ArrayBuffer[]}
     */
    fetch(slices: Slice[], signal?: undefined): ArrayBuffer[];
    /**
     *
     * @param {Slice} slice
     * @returns {ArrayBuffer}
     */
    fetchSlice(slice: Slice): ArrayBuffer;
    /**
     * Returns the filesize if already determined and null otherwise
     */
    get fileSize(): null;
    close(): Promise<void>;
}
type Slice = {
    offset: number;
    length: number;
};

type ReadRasterOptions = {
    /**
     * window] the subset to read data from in pixels.
     */
    window?: number[] | undefined;
    /**
     * image] the subset to read data from in
     *      geographical coordinates.
     */
    bbox?: number[] | undefined;
    /**
     * samples] the selection of samples to read from. Default is all samples.
     */
    samples?: number[] | undefined;
    /**
     * whether the data shall be read
     *       in one single array or separate
     *       arrays.
     */
    interleave?: boolean | undefined;
    /**
     * The optional decoder pool to use.
     */
    pool?: any;
    /**
     * The desired width of the output. When the width is not the
     *       same as the images, resampling will be performed.
     */
    width?: number | undefined;
    /**
     * The desired height of the output. When the width is not the
     *       same as the images, resampling will be performed.
     */
    height?: number | undefined;
    /**
     * The desired resampling method.
     */
    resampleMethod?: string | undefined;
    /**
     * An AbortSignal that may be signalled if the request is
     *       to be aborted
     */
    signal?: AbortSignal | undefined;
    /**
     * The value to use for parts of the image
     *       outside of the images extent. When multiple
     *       samples are requested, an array of fill values
     *       can be passed.
     */
    fillValue?: number | number[] | undefined;
};
type ReadRasterResult$1 = ReadRasterResult;
/**
 * GeoTIFF sub-file image.
 */
declare class GeoTIFFImage$1 {
    /**
     * @constructor
     * @param {Object} fileDirectory The parsed file directory
     * @param {Object} geoKeys The parsed geo-keys
     * @param {DataView} dataView The DataView for the underlying file.
     * @param {Boolean} littleEndian Whether the file is encoded in little or big endian
     * @param {Boolean} cache Whether or not decoded tiles shall be cached
     * @param {import('./source/basesource').BaseSource} source The datasource to read from
     */
    constructor(fileDirectory: any, geoKeys: any, dataView: DataView, littleEndian: boolean, cache: boolean, source: BaseSource);
    fileDirectory: any;
    geoKeys: any;
    dataView: DataView;
    littleEndian: boolean;
    tiles: {} | null;
    isTiled: boolean;
    planarConfiguration: any;
    source: BaseSource;
    /**
     * Returns the associated parsed file directory.
     * @returns {Object} the parsed file directory
     */
    getFileDirectory(): any;
    /**
     * Returns the associated parsed geo keys.
     * @returns {Object} the parsed geo keys
     */
    getGeoKeys(): any;
    /**
     * Returns the width of the image.
     * @returns {Number} the width of the image
     */
    getWidth(): number;
    /**
     * Returns the height of the image.
     * @returns {Number} the height of the image
     */
    getHeight(): number;
    /**
     * Returns the number of samples per pixel.
     * @returns {Number} the number of samples per pixel
     */
    getSamplesPerPixel(): number;
    /**
     * Returns the width of each tile.
     * @returns {Number} the width of each tile
     */
    getTileWidth(): number;
    /**
     * Returns the height of each tile.
     * @returns {Number} the height of each tile
     */
    getTileHeight(): number;
    getBlockWidth(): number;
    getBlockHeight(y: any): number;
    /**
     * Calculates the number of bytes for each pixel across all samples. Only full
     * bytes are supported, an exception is thrown when this is not the case.
     * @returns {Number} the bytes per pixel
     */
    getBytesPerPixel(): number;
    getSampleByteSize(i: any): number;
    getReaderForSample(sampleIndex: any): (byteOffset: number, littleEndian?: boolean | undefined) => number;
    getSampleFormat(sampleIndex?: number): any;
    getBitsPerSample(sampleIndex?: number): any;
    getArrayForSample(sampleIndex: any, size: any): Uint8Array | Uint16Array | Uint32Array | Int32Array | Int8Array | Int16Array | Float32Array | Float64Array;
    /**
     * Returns the decoded strip or tile.
     * @param {Number} x the strip or tile x-offset
     * @param {Number} y the tile y-offset (0 for stripped images)
     * @param {Number} sample the sample to get for separated samples
     * @param {import("./geotiff").Pool|import("./geotiff").BaseDecoder} poolOrDecoder the decoder or decoder pool
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise.<ArrayBuffer>}
     */
    getTileOrStrip(x: number, y: number, sample: number, poolOrDecoder: Pool | BaseDecoder, signal?: AbortSignal | undefined): Promise<ArrayBuffer>;
    /**
     * Internal read function.
     * @private
     * @param {Array} imageWindow The image window in pixel coordinates
     * @param {Array} samples The selected samples (0-based indices)
     * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into
     * @param {Boolean} interleave Whether or not to write in an interleaved manner
     * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
     * @param {number} width the width of window to be read into
     * @param {number} height the height of window to be read into
     * @param {number} resampleMethod the resampling method to be used when interpolating
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise<ReadRasterResult>}
     */
    private _readRaster;
    /**
     * Reads raster data from the image. This function reads all selected samples
     * into separate arrays of the correct type for that sample or into a single
     * combined array when `interleave` is set. When provided, only a subset
     * of the raster is read for each sample.
     *
     * @param {ReadRasterOptions} [options={}] optional parameters
     * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise
     */
    readRasters({ window: wnd, samples, interleave, pool, width, height, resampleMethod, fillValue, signal, }?: ReadRasterOptions | undefined): Promise<ReadRasterResult$1>;
    /**
     * Reads raster data from the image as RGB. The result is always an
     * interleaved typed array.
     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.
     * When no other method is applicable, the first sample is used to produce a
     * grayscale image.
     * When provided, only a subset of the raster is read for each sample.
     *
     * @param {Object} [options] optional parameters
     * @param {Array<number>} [options.window] the subset to read data from in pixels.
     * @param {boolean} [options.interleave=true] whether the data shall be read
     *                                             in one single array or separate
     *                                             arrays.
     * @param {import("./geotiff").Pool} [options.pool=null] The optional decoder pool to use.
     * @param {number} [options.width] The desired width of the output. When the width is no the
     *                                 same as the images, resampling will be performed.
     * @param {number} [options.height] The desired height of the output. When the width is no the
     *                                  same as the images, resampling will be performed.
     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
     * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.
     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
     *                                       to be aborted
     * @returns {Promise<ReadRasterResult>} the RGB array as a Promise
     */
    readRGB({ window, interleave, pool, width, height, resampleMethod, enableAlpha, signal }?: {
        window?: number[] | undefined;
        interleave?: boolean | undefined;
        pool?: Pool | undefined;
        width?: number | undefined;
        height?: number | undefined;
        resampleMethod?: string | undefined;
        enableAlpha?: boolean | undefined;
        signal?: AbortSignal | undefined;
    } | undefined): Promise<ReadRasterResult$1>;
    /**
     * Returns an array of tiepoints.
     * @returns {Object[]}
     */
    getTiePoints(): any[];
    /**
     * Returns the parsed GDAL metadata items.
     *
     * If sample is passed to null, dataset-level metadata will be returned.
     * Otherwise only metadata specific to the provided sample will be returned.
     *
     * @param {number} [sample=null] The sample index.
     * @returns {Object}
     */
    getGDALMetadata(sample?: number | undefined): any;
    /**
     * Returns the GDAL nodata value
     * @returns {number|null}
     */
    getGDALNoData(): number | null;
    /**
     * Returns the image origin as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @returns {Array<number>} The origin as a vector
     */
    getOrigin(): Array<number>;
    /**
     * Returns the image resolution as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from
     *                                             in cases when the current image does not have the
     *                                             required tags on its own.
     * @returns {Array<number>} The resolution as a vector
     */
    getResolution(referenceImage?: GeoTIFFImage$1 | undefined): Array<number>;
    /**
     * Returns whether or not the pixels of the image depict an area (or point).
     * @returns {Boolean} Whether the pixels are a point
     */
    pixelIsArea(): boolean;
    /**
     * Returns the image bounding box as an array of 4 values: min-x, min-y,
     * max-x and max-y. When the image has no affine transformation, then an
     * exception is thrown.
     * @param {boolean} [tilegrid=false] If true return extent for a tilegrid
     *                                   without adjustment for ModelTransformation.
     * @returns {Array<number>} The bounding box
     */
    getBoundingBox(tilegrid?: boolean | undefined): Array<number>;
}

declare class BaseDecoder {
    decode(fileDirectory: any, buffer: any): Promise<any>;
}

type TypedArray = Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array;
type Dimensions = {
    height: number;
    width: number;
};
/**
 * The autogenerated docs are a little confusing here. The effective type is:
 *
 * `TypedArray & { height: number; width: number}`
 */
type TypedArrayWithDimensions = TypedArray & Dimensions;
/**
 * The autogenerated docs are a little confusing here. The effective type is:
 *
 * `TypedArray[] & { height: number; width: number}`
 */
type TypedArrayArrayWithDimensions = TypedArray[] & Dimensions;
/**
 * The autogenerated docs are a little confusing here. The effective type is:
 *
 * `(TypedArray | TypedArray[]) & { height: number; width: number}`
 */
type ReadRasterResult = TypedArrayWithDimensions | TypedArrayArrayWithDimensions;

type SourceInfo$1 = {
    /**
     * URL for the source GeoTIFF.
     */
    url?: string | undefined;
    /**
     * List of any overview URLs, only applies if the url parameter is given.
     */
    overviews?: string[] | undefined;
    /**
     * Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.
     */
    blob?: Blob | undefined;
    /**
     * The minimum source data value.  Rendered values are scaled from 0 to 1 based on
     * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
     * If neither are available, the minimum for the data type will be used.  To disable this behavior, set
     * the `normalize` option to `false` in the constructor.
     */
    min?: number | undefined;
    /**
     * The maximum source data value.  Rendered values are scaled from 0 to 1 based on
     * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
     * If neither are available, the maximum for the data type will be used.  To disable this behavior, set
     * the `normalize` option to `false` in the constructor.
     */
    max?: number | undefined;
    /**
     * Values to discard (overriding any nodata values in the metadata).
     * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata
     * will include information about nodata values, so you should only need to set this property if
     * you find that it is not already extracted from the metadata.
     */
    nodata?: number | undefined;
    /**
     * Band numbers to be read from (where the first band is `1`). If not provided, all bands will
     * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the
     * near-infrared band, configure `bands: [4]`.
     */
    bands?: number[] | undefined;
};
type GeoTIFFImage = GeoTIFFImage$1;
type GeoTIFFSourceOptions = {
    /**
     * Whether to force the usage of the browsers XMLHttpRequest API.
     */
    forceXHR?: boolean | undefined;
    /**
     * additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.
     */
    headers?: {
        [x: string]: string;
    } | undefined;
    /**
     * How credentials shall be handled. See
     * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values
     */
    credentials?: string | undefined;
    /**
     * The maximum amount of ranges to request in a single multi-range request.
     * By default only a single range is used.
     */
    maxRanges?: number | undefined;
    /**
     * Whether or not a full file is accepted when only a portion is
     * requested. Only use this when you know the source image to be small enough to fit in memory.
     */
    allowFullFile?: boolean | undefined;
    /**
     * The block size to use.
     */
    blockSize?: number | undefined;
    /**
     * The number of blocks that shall be held in a LRU cache.
     */
    cacheSize?: number | undefined;
};
type Options$R = {
    /**
     * List of information about GeoTIFF sources.
     * Multiple sources can be combined when their resolution sets are equal after applying a scale.
     * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and
     * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,
     * use the {@link import ("./GeoTIFF.js").SourceInfo bands} property. If, for example, you specify two
     * sources, one with 3 bands and {@link import ("./GeoTIFF.js").SourceInfo nodata} configured, and
     * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha
     * band from the first source, and 1 band from the second source.
     */
    sources: Array<SourceInfo$1>;
    /**
     * Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.
     */
    sourceOptions?: GeoTIFFSourceOptions | undefined;
    /**
     * By default, bands from the sources are read as-is. When
     * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will
     * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,
     * CIELab, and ICCLab images will automatically be converted to RGB.
     */
    convertToRGB?: boolean | "auto" | undefined;
    /**
     * By default, the source data is normalized to values between
     * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.
     * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option
     * to `false` will make it so any `min` and `max` properties on sources are ignored.
     */
    normalize?: boolean | undefined;
    /**
     * Source projection.  If not provided, the GeoTIFF metadata
     * will be read for projection information.
     */
    projection?: ProjectionLike;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Render tiles beyond the tile grid extent.
     */
    wrapX?: boolean | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.
     */
    interpolate?: boolean | undefined;
};
/**
 * @typedef {Object} GeoTIFFSourceOptions
 * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.
 * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.
 * @property {string} [credentials] How credentials shall be handled. See
 * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values
 * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.
 * By default only a single range is used.
 * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is
 * requested. Only use this when you know the source image to be small enough to fit in memory.
 * @property {number} [blockSize=65536] The block size to use.
 * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.
 */
/**
 * @typedef {Object} Options
 * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.
 * Multiple sources can be combined when their resolution sets are equal after applying a scale.
 * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and
 * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,
 * use the {@link import("./GeoTIFF.js").SourceInfo bands} property. If, for example, you specify two
 * sources, one with 3 bands and {@link import("./GeoTIFF.js").SourceInfo nodata} configured, and
 * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha
 * band from the first source, and 1 band from the second source.
 * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.
 * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When
 * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will
 * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,
 * CIELab, and ICCLab images will automatically be converted to RGB.
 * @property {boolean} [normalize=true] By default, the source data is normalized to values between
 * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.
 * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option
 * to `false` will make it so any `min` and `max` properties on sources are ignored.
 * @property {import("../proj.js").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata
 * will be read for projection information.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.
 */
/**
 * @classdesc
 * A source for working with GeoTIFF data.
 * **Note for users of the full build**: The `GeoTIFF` source requires the
 * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.
 *
 * @api
 */
declare class GeoTIFFSource extends DataTileSource<DataTile> {
    /**
     * @param {Options} options Data tile options.
     */
    constructor(options: Options$R);
    /**
     * @type {Array<SourceInfo>}
     * @private
     */
    private sourceInfo_;
    /**
     * @type {Object}
     * @private
     */
    private sourceOptions_;
    /**
     * @type {Array<Array<GeoTIFFImage>>}
     * @private
     */
    private sourceImagery_;
    /**
     * @type {Array<Array<GeoTIFFImage>>}
     * @private
     */
    private sourceMasks_;
    /**
     * @type {Array<number>}
     * @private
     */
    private resolutionFactors_;
    /**
     * @type {Array<number>}
     * @private
     */
    private samplesPerPixel_;
    /**
     * @type {Array<Array<number>>}
     * @private
     */
    private nodataValues_;
    /**
     * @type {Array<Array<GDALMetadata>>}
     * @private
     */
    private metadata_;
    /**
     * @type {boolean}
     * @private
     */
    private normalize_;
    /**
     * @type {boolean}
     * @private
     */
    private addAlpha_;
    /**
     * @type {Error}
     * @private
     */
    private error_;
    /**
     * @type {true|false|'auto'}
     * @private
     */
    private convertToRGB_;
    /**
     * @return {Error} A source loading error. When the source state is `error`, use this function
     * to get more information about the error. To debug a faulty configuration, you may want to use
     * a listener like
     * ```js
     * geotiffSource.on('change', () => {
     *   if (geotiffSource.getState() === 'error') {
     *     console.error(geotiffSource.getError());
     *   }
     * });
     * ```
     */
    getError(): Error;
    /**
     * Determine the projection of the images in this GeoTIFF.
     * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey
     * of each image in turn.
     * You can override this method in a subclass to support more projections.
     *
     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
     * from a single GeoTIFF.
     */
    determineProjection(sources: Array<Array<GeoTIFFImage>>): void;
    /**
     * Determine any transform matrix for the images in this GeoTIFF.
     *
     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
     * from a single GeoTIFF.
     */
    determineTransformMatrix(sources: Array<Array<GeoTIFFImage>>): void;
    /**
     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF
     * must have the same internal tiled structure.
     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
     * from a single GeoTIFF.
     * @private
     */
    private configure_;
    /**
     * @param {number} z The z tile index.
     * @param {number} x The x tile index.
     * @param {number} y The y tile index.
     * @param {import('./DataTile.js').LoaderOptions} options The loader options.
     * @return {Promise} The composed tile data.
     * @private
     */
    private loadTile_;
    /**
     * @param {import("../size.js").Size} sourceTileSize The source tile size.
     * @param {Array} sourceSamples The source samples.
     * @return {import("../DataTile.js").Data} The composed tile data.
     * @private
     */
    private composeTile_;
}

type Options$Q = {
    /**
     * Google Map Tiles API key. Get yours at https://developers.google.com/maps/documentation/tile/get-api-key.
     */
    key: string;
    /**
     * The type of [base map](https://developers.google.com/maps/documentation/tile/session_tokens#required_fields).
     */
    mapType?: string | undefined;
    /**
     * An [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) for information displayed on the tiles.
     */
    language?: string | undefined;
    /**
     * A [Common Locale Data Repository](https://cldr.unicode.org/) (CLDR) region identifier that represents the user location.
     */
    region?: string | undefined;
    /**
     * The image format used for the map tiles (e.g. `'jpeg'`, or `'png'`).
     */
    imageFormat?: string | undefined;
    /**
     * Scale for map elements (`'scaleFactor1x'`, `'scaleFactor2x'`, or `'scaleFactor4x'`).
     */
    scale?: string | undefined;
    /**
     * Use high-resolution tiles.
     */
    highDpi?: boolean | undefined;
    /**
     * The layer types added to the map (e.g. `'layerRoadmap'`, `'layerStreetview'`, or `'layerTraffic'`).
     */
    layerTypes?: string[] | undefined;
    /**
     * Display only the `layerTypes` and not the underlying `mapType` (only works if `layerTypes` is provided).
     */
    overlay?: boolean | undefined;
    /**
     * [Custom styles](https://developers.google.com/maps/documentation/tile/style-reference) applied to the map.
     */
    styles?: any[] | undefined;
    /**
     * Allow the attributions to be collapsed.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
     */
    cacheSize?: number | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * An array of values specifying additional options to apply.
     */
    apiOptions?: string[] | undefined;
    /**
     * Wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} key Google Map Tiles API key. Get yours at https://developers.google.com/maps/documentation/tile/get-api-key.
 * @property {string} [mapType='roadmap'] The type of [base map](https://developers.google.com/maps/documentation/tile/session_tokens#required_fields).
 * @property {string} [language='en-US'] An [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) for information displayed on the tiles.
 * @property {string} [region='US'] A [Common Locale Data Repository](https://cldr.unicode.org/) (CLDR) region identifier that represents the user location.
 * @property {string} [imageFormat] The image format used for the map tiles (e.g. `'jpeg'`, or `'png'`).
 * @property {string} [scale] Scale for map elements (`'scaleFactor1x'`, `'scaleFactor2x'`, or `'scaleFactor4x'`).
 * @property {boolean} [highDpi=false] Use high-resolution tiles.
 * @property {Array<string>} [layerTypes] The layer types added to the map (e.g. `'layerRoadmap'`, `'layerStreetview'`, or `'layerTraffic'`).
 * @property {boolean} [overlay=false] Display only the `layerTypes` and not the underlying `mapType` (only works if `layerTypes` is provided).
 * @property {Array<Object>} [styles] [Custom styles](https://developers.google.com/maps/documentation/tile/style-reference) applied to the map.
 * @property {boolean} [attributionsCollapsible=true] Allow the attributions to be collapsed.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [apiOptions] An array of values specifying additional options to apply.
 * @property {boolean} [wrapX=true] Wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @typedef {Object} SessionTokenRequest
 * @property {string} mapType The map type.
 * @property {string} language The language.
 * @property {string} region The region.
 * @property {string} [imageFormat] The image format.
 * @property {string} [scale] The scale.
 * @property {boolean} [highDpi] Use high resolution tiles.
 * @property {Array<string>} [layerTypes] The layer types.
 * @property {boolean} [overlay] The overlay.
 * @property {Array<Object>} [styles] The styles.
 * @property {Array<string>} [apiOptions] An array of values specifying additional options to apply.
 */
/**
 * @typedef {Object} SessionTokenResponse
 * @property {string} session The session token.
 * @property {string} expiry The session token expiry (seconds since the epoch as a string).
 * @property {number} tileWidth The tile width.
 * @property {number} tileHeight The tile height.
 * @property {string} imageFormat The image format.
 */
/**
 * @classdesc
 * A tile layer source that renders tiles from the Google [Map Tiles API](https://developers.google.com/maps/documentation/tile/overview).
 * The constructor takes options that are passed to the request to create a session token.  Refer to the
 * [documentation](https://developers.google.com/maps/documentation/tile/session_tokens#required_fields)
 * for additional details.
 * @api
 */
declare class Google extends TileImage {
    /**
     * @param {Options} options Google Maps options.
     */
    constructor(options: Options$Q);
    /**
     * @type {string}
     * @private
     */
    private apiKey_;
    /**
     * @type {Error|null}
     * @private
     */
    private error_;
    /**
     * @type {SessionTokenRequest}
     * @private
     */
    private sessionTokenRequest_;
    /**
     * @type {string}
     * @private
     */
    private sessionTokenValue_;
    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    private sessionRefreshId_;
    /**
     * @type {string}
     * @private
     */
    private previousViewportAttribution_;
    /**
     * @type {string}
     * @private
     */
    private previousViewportExtent_;
    /**
     * @return {Error|null} A source loading error. When the source state is `error`, use this function
     * to get more information about the error. To debug a faulty configuration, you may want to use
     * a listener like
     * ```js
     * source.on('change', () => {
     *   if (source.getState() === 'error') {
     *     console.error(source.getError());
     *   }
     * });
     * ```
     */
    getError(): Error | null;
    /**
     * Exposed here so it can be overridden in the tests.
     * @param {string} url The URL.
     * @param {RequestInit} config The config.
     * @return {Promise<Response>} A promise that resolves with the response.
     */
    fetchSessionToken(url: string, config: RequestInit): Promise<Response>;
    /**
     * Get or renew a session token for use with tile requests.
     * @private
     */
    private createSession_;
    /**
     * @param {import('../Map.js').FrameState} frameState The frame state.
     * @return {Promise<string>} The attributions.
     * @private
     */
    private fetchAttributions_;
}

type Options$P = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting the image from
     * the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * Optional function to load an image given
     * a URL.
     */
    imageLoadFunction?: LoadFunction | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * ArcGIS Rest parameters. This field is optional. Service
     * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
     * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
     * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
     * https://developers.arcgis.com/rest/services-reference/export-map.htm
     * for further reference.
     */
    params?: {
        [x: string]: any;
    } | undefined;
    /**
     * Projection. Default is the view projection.
     * The projection code must contain a numeric end portion separated by :
     * or the entire code must form a valid ArcGIS SpatialReference definition.
     */
    projection?: ProjectionLike;
    /**
     * Ratio. `1` means image requests are the size of the map viewport,
     * `2` means twice the size of the map viewport, and so on.
     */
    ratio?: number | undefined;
    /**
     * Resolutions. If specified, requests will be made for
     * these resolutions only.
     */
    resolutions?: number[] | undefined;
    /**
     * ArcGIS Rest service URL for a Map Service or Image Service. The url
     * should include /MapServer or /ImageServer.
     */
    url?: string | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given
 * a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for
 * these resolutions only.
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 */
/**
 * @classdesc
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 *
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {@link module:ol/source/TileArcGISRest~TileArcGISRest} data source.
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
declare class ImageArcGISRest extends ImageSource {
    /**
     * @param {Options} [options] Image ArcGIS Rest Options.
     */
    constructor(options?: Options$P);
    /**
     * @private
     * @type {?string}
     */
    private crossOrigin_;
    /**
     * @private
     * @type {boolean}
     */
    private hidpi_;
    /**
     * @private
     * @type {string|undefined}
     */
    private url_;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    private imageLoadFunction_;
    /**
     * @private
     * @type {!Object}
     */
    private params_;
    /**
     * @private
     * @type {import("../size.js").Size}
     */
    private imageSize_;
    /**
     * @private
     * @type {number}
     */
    private renderedRevision_;
    /**
     * @private
     * @type {number}
     */
    private ratio_;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    private loaderProjection_;
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams(): any;
    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
    getImageLoadFunction(): LoadFunction;
    /**
     * Return the URL used for this ArcGIS source.
     * @return {string|undefined} URL.
     * @api
     */
    getUrl(): string | undefined;
    /**
     * Set the image load function of the source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
    setImageLoadFunction(imageLoadFunction: LoadFunction): void;
    /**
     * Set the URL to use for requests.
     * @param {string|undefined} url URL.
     * @api
     */
    setUrl(url: string | undefined): void;
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(params: any): void;
}

/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module :ol/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the pixel ratio of the map, {@link module :ol/size~Size} the image size,
 * and {@link module :ol/proj/Projection~Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module :ol/source/ImageCanvas~ImageCanvasSource}.
 */
type FunctionType$1 = (this: ImageCanvas, arg1: Extent$1, arg2: number, arg3: number, arg4: Size, arg5: Projection) => HTMLCanvasElement;
type Options$O = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Canvas function.
     * The function returning the canvas element used by the source
     * as an image. The arguments passed to the function are: {@link import ("../extent.js").Extent} the
     * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,
     * {@link import ("../size.js").Size} the image size, and {@link import ("../proj/Projection.js").default} the image
     * projection. The canvas returned by this function is cached by the source. If
     * the value returned by the function is later changed then
     * `changed` should be called on the source for the source to
     * invalidate the current cached image. See: {@link module :ol/Observable~Observable#changed}
     */
    canvasFunction?: FunctionType$1 | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
     * width and height of the map viewport, and so on. Must be `1` or higher.
     */
    ratio?: number | undefined;
    /**
     * Resolutions.
     * If specified, new canvases will be created for these resolutions
     */
    resolutions?: number[] | undefined;
    /**
     * Source state.
     */
    state?: State$2 | undefined;
};
/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the pixel ratio of the map, {@link module:ol/size~Size} the image size,
 * and {@link module:ol/proj/Projection~Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module:ol/source/ImageCanvas~ImageCanvasSource}.
 *
 * @typedef {function(this:import("../ImageCanvas.js").default, import("../extent.js").Extent, number,
 *     number, import("../size.js").Size, import("../proj/Projection.js").default): HTMLCanvasElement} FunctionType
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {FunctionType} [canvasFunction] Canvas function.
 * The function returning the canvas element used by the source
 * as an image. The arguments passed to the function are: {@link import("../extent.js").Extent} the
 * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,
 * {@link import("../size.js").Size} the image size, and {@link import("../proj/Projection.js").default} the image
 * projection. The canvas returned by this function is cached by the source. If
 * the value returned by the function is later changed then
 * `changed` should be called on the source for the source to
 * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
 * width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, new canvases will be created for these resolutions
 * @property {import("./Source.js").State} [state] Source state.
 */
/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 * @api
 */
declare class ImageCanvasSource extends ImageSource {
    /**
     * @param {Options} [options] ImageCanvas options.
     */
    constructor(options?: Options$O);
    /**
     * @private
     * @type {FunctionType}
     */
    private canvasFunction_;
    /**
     * @private
     * @type {import("../ImageCanvas.js").default}
     */
    private canvas_;
    /**
     * @private
     * @type {number}
     */
    private renderedRevision_;
    /**
     * @private
     * @type {number}
     */
    private ratio_;
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../ImageCanvas.js").default} Single image.
     * @override
     */
    override getImageInternal(extent: Extent$1, resolution: number, pixelRatio: number, projection: Projection): ImageCanvas;
}

type Options$N = {
    /**
     * The mapagent url.
     */
    url?: string | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * The display resolution.
     */
    displayDpi?: number | undefined;
    /**
     * The meters-per-unit value.
     */
    metersPerUnit?: number | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
     */
    useOverlay?: boolean | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Ratio. `1` means image requests are the size of the map viewport, `2` means
     * twice the width and height of the map viewport, and so on. Must be `1` or higher.
     */
    ratio?: number | undefined;
    /**
     * Resolutions.
     * If specified, requests will be made for these resolutions only.
     */
    resolutions?: number[] | undefined;
    /**
     * Optional function to load an image given a URL.
     */
    imageLoadFunction?: LoadFunction | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Additional parameters.
     */
    params?: any;
};
/**
 * @typedef {Object} Options
 * @property {string} [url] The mapagent url.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [displayDpi=96] The display resolution.
 * @property {number} [metersPerUnit=1] The meters-per-unit value.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object} [params] Additional parameters.
 */
/**
 * @classdesc
 * Source for images from Mapguide servers
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
declare class ImageMapGuide extends ImageSource {
    /**
     * @param {Options} options ImageMapGuide options.
     */
    constructor(options: Options$N);
    /**
     * @private
     * @type {?string}
     */
    private crossOrigin_;
    /**
     * @private
     * @type {number}
     */
    private displayDpi_;
    /**
     * @private
     * @type {!Object}
     */
    private params_;
    /**
     * @private
     * @type {string|undefined}
     */
    private url_;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    private imageLoadFunction_;
    /**
     * @private
     * @type {boolean}
     */
    private hidpi_;
    /**
     * @private
     * @type {number}
     */
    private metersPerUnit_;
    /**
     * @private
     * @type {number}
     */
    private ratio_;
    /**
     * @private
     * @type {boolean}
     */
    private useOverlay_;
    /**
     * @private
     * @type {number}
     */
    private renderedRevision_;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    private loaderProjection_;
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams(): any;
    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
    getImageLoadFunction(): LoadFunction;
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(params: any): void;
    /**
     * Set the image load function of the MapGuide source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
    setImageLoadFunction(imageLoadFunction: LoadFunction): void;
}

type Options$M = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Extent of the image in map coordinates.
     * This is the [left, bottom, right, top] map coordinates of your image.
     */
    imageExtent: Extent$1;
    /**
     * Optional function to load an image given a URL.
     */
    imageLoadFunction?: LoadFunction | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Image URL.
     */
    url: string;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} imageExtent Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {string} url Image URL.
 */
/**
 * @classdesc
 * A layer source for displaying a single, static image.
 * @api
 */
declare class Static extends ImageSource {
    /**
     * @param {Options} options ImageStatic options.
     */
    constructor(options: Options$M);
    /**
     * @private
     * @type {string}
     */
    private url_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private imageExtent_;
    /**
     * Returns the image extent
     * @return {import("../extent.js").Extent} image extent.
     * @api
     */
    getImageExtent(): Extent$1;
    /**
     * Return the URL used for this image source.
     * @return {string} URL.
     * @api
     */
    getUrl(): string;
}

/**
 * Image tile loading function.  The function is called with z, x, and y tile coordinates and
 * returns an {@link import ("../DataTile.js").ImageLike image} or a promise for the same.
 */
type Loader = (arg0: number, arg1: number, arg2: number, arg3: LoaderOptions$4) => (ImageLike | Promise<ImageLike>);
type UrlGetter = (arg0: number, arg1: number, arg2: number, arg3: LoaderOptions$4) => string;
type UrlLike = string | Array<string> | UrlGetter;
type Options$L = {
    /**
     * The image URL template.  In addition to a single URL template, an array of URL templates or a function
     * can be provided.  If a function is provided, it will be called with z, x, y tile coordinates and loader options and should
     * return a URL.
     */
    url?: UrlLike | undefined;
    /**
     * Data loader.  Called with z, x, and y tile coordinates.
     * Returns an {@link import ("../DataTile.js").ImageLike image} for a tile or a promise for the same.
     * The promise should not resolve until the image is loaded.  If the `url` option is provided, a loader will be created.
     */
    loader?: Loader | undefined;
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Optional max zoom level. Not used if `tileGrid` is provided.
     */
    maxZoom?: number | undefined;
    /**
     * Optional min zoom level. Not used if `tileGrid` is provided.
     */
    minZoom?: number | undefined;
    /**
     * The pixel width and height of the source tiles.
     * This may be different than the rendered pixel size if a `tileGrid` is provided.
     */
    tileSize?: number | Size | undefined;
    /**
     * The size in pixels of the gutter around data tiles to ignore.
     * This allows artifacts of rendering at tile edges to be ignored.
     * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.
     */
    gutter?: number | undefined;
    /**
     * Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
     */
    maxResolution?: number | undefined;
    /**
     * Tile projection.
     */
    projection?: ProjectionLike;
    /**
     * Tile grid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * The source state.
     */
    state?: State$2 | undefined;
    /**
     * Render tiles beyond the antimeridian.
     */
    wrapX?: boolean | undefined;
    /**
     * Transition time when fading in new tiles (in miliseconds).
     */
    transition?: number | undefined;
    /**
     * Use interpolated values when resampling.
     */
    interpolate?: boolean | undefined;
    /**
     * The crossOrigin property to pass to loaders for image data.
     */
    crossOrigin?: CrossOriginAttribute | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @classdesc
 * A source for typed array data tiles.
 *
 * @extends DataTileSource<import("../ImageTile.js").default>
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
declare class ImageTileSource extends DataTileSource<ImageTile> {
    /**
     * @param {Options} [options] DataTile source options.
     */
    constructor(options?: Options$L);
    /**
     * @param {UrlLike} url The new URL.
     * @api
     */
    setUrl(url: UrlLike): void;
}

/**
 * @api
 * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType
 * Set the server type to use implementation-specific parameters beyond the WMS specification.
 *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
 *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)
 *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)
 *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)
 */
/**
 * @param {string} baseUrl Base URL.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {import("../size.js").Size} size Size.
 * @param {import("../proj/Projection.js").default} projection Projection.
 * @param {Object} params WMS params. Will be modified in place.
 * @return {string} Request URL.
 */
declare function getRequestUrl$1(baseUrl: string, extent: Extent$1, size: Size, projection: Projection, params: any): string;
/**
 * @param {import("../extent").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio pixel ratio.
 * @param {import("../proj.js").Projection} projection Projection.
 * @param {string} url WMS service url.
 * @param {Object} params WMS params.
 * @param {import("./wms.js").ServerType} serverType The type of the remote WMS server.
 * @return {string} Image src.
 */
declare function getImageSrc(extent: Extent$1, resolution: number, pixelRatio: number, projection: Projection, url: string, params: any, serverType: ServerType): string;
/**
 * @param {Object} params WMS params.
 * @param {string} request WMS `REQUEST`.
 * @return {Object} WMS params with required properties set.
 */
declare function getRequestParams(params: any, request: string): any;
/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {Object<string,*>} [params] WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set
 * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {string} url WMS service URL.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */
/**
 * Creates a loader for WMS images.
 * @param {LoaderOptions} options Loader options.
 * @return {import("../Image.js").ImageObjectPromiseLoader} Loader.
 * @api
 */
declare function createLoader$3(options: LoaderOptions$3): ImageObjectPromiseLoader;
/**
 * Get the GetFeatureInfo URL for the passed coordinate and resolution. Returns `undefined` if the
 * GetFeatureInfo URL cannot be constructed.
 * @param {LoaderOptions} options Options passed the `createWMSLoader()` function. In addition to
 * the params required by the loader, `INFO_FORMAT` should be specified, it defaults to
 * `application/json`. If `QUERY_LAYERS` is not provided, then the layers specified in the `LAYERS`
 * parameter will be used.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @return {string|undefined} GetFeatureInfo URL.
 * @api
 */
declare function getFeatureInfoUrl(options: LoaderOptions$3, coordinate: Coordinate, resolution: number): string | undefined;
/**
 * Get the GetLegendGraphic URL, optionally optimized for the passed resolution and possibly
 * including any passed specific parameters. Returns `undefined` if the GetLegendGraphic URL
 * cannot be constructed.
 *
 * @param {LoaderOptions} options Options passed the `createWMSLoader()` function.
 * @param {number} [resolution] Resolution. If not provided, `SCALE` will not be calculated and
 * included in URL.
 * @return {string|undefined} GetLegendGraphic URL.
 * @api
 */
declare function getLegendUrl(options: LoaderOptions$3, resolution?: number): string | undefined;
/**
 * Default WMS version.
 * @type {string}
 */
declare const DEFAULT_VERSION: string;
/**
 * Set the server type to use implementation-specific parameters beyond the WMS specification.
 * - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
 * - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)
 * - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)
 * - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)
 */
type ServerType = "carmentaserver" | "geoserver" | "mapserver" | "qgis";
type LoaderOptions$3 = {
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * WMS request parameters.
     * At least a `LAYERS` param is required. `STYLES` is
     * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set
     * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.
     */
    params?: {
        [x: string]: any;
    } | undefined;
    /**
     * Projection. Default is 'EPSG:3857'.
     */
    projection?: ProjectionLike;
    /**
     * Ratio. `1` means image requests are the size of the map viewport, `2` means
     * twice the width and height of the map viewport, and so on. Must be `1` or higher.
     */
    ratio?: number | undefined;
    /**
     * The type of
     * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
     * Only needed if `hidpi` is `true`.
     */
    serverType?: ServerType | undefined;
    /**
     * WMS service URL.
     */
    url: string;
    /**
     * Function
     * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
     * returns a promise resolving to the loaded or decoded image. Default is {@link module :ol/Image.decode}.
     */
    load?: ((arg0: HTMLImageElement, arg1: string) => Promise<ImageLike>) | undefined;
};

type Options$K = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * The type of
     * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
     * Only needed if `hidpi` is `true`.
     */
    serverType?: ServerType | undefined;
    /**
     * Optional function to load an image given a URL.
     */
    imageLoadFunction?: LoadFunction | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * WMS request parameters.
     * At least a `LAYERS` param is required. `STYLES` is
     * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
     * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
     */
    params?: {
        [x: string]: any;
    } | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Ratio. `1` means image requests are the size of the map viewport, `2` means
     * twice the width and height of the map viewport, and so on. Must be `1` or higher.
     */
    ratio?: number | undefined;
    /**
     * Resolutions.
     * If specified, requests will be made for these resolutions only.
     */
    resolutions?: number[] | undefined;
    /**
     * WMS service URL.
     */
    url?: string | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {string} [url] WMS service URL.
 */
/**
 * @classdesc
 * Source for WMS servers providing single, untiled images.
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
declare class ImageWMS extends ImageSource {
    /**
     * @param {Options} [options] ImageWMS options.
     */
    constructor(options?: Options$K);
    /**
     * @private
     * @type {?string}
     */
    private crossOrigin_;
    /**
     * @private
     * @type {string|undefined}
     */
    private url_;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */
    private imageLoadFunction_;
    /**
     * @private
     * @type {!Object}
     */
    private params_;
    /**
     * @private
     * @type {import("./wms.js").ServerType}
     */
    private serverType_;
    /**
     * @private
     * @type {boolean}
     */
    private hidpi_;
    /**
     * @private
     * @type {number}
     */
    private renderedRevision_;
    /**
     * @private
     * @type {number}
     */
    private ratio_;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    private loaderProjection_;
    /**
     * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
     * projection. Return `undefined` if the GetFeatureInfo URL cannot be
     * constructed.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
     *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
     *     in the `LAYERS` parameter will be used. `VERSION` should not be
     *     specified here.
     * @return {string|undefined} GetFeatureInfo URL.
     * @api
     */
    getFeatureInfoUrl(coordinate: Coordinate, resolution: number, projection: ProjectionLike, params: any): string | undefined;
    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */
    getLegendUrl(resolution?: number, params?: any): string | undefined;
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams(): any;
    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
    getImageLoadFunction(): LoadFunction;
    /**
     * Return the URL used for this WMS source.
     * @return {string|undefined} URL.
     * @api
     */
    getUrl(): string | undefined;
    /**
     * Set the image load function of the source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
    setImageLoadFunction(imageLoadFunction: LoadFunction): void;
    /**
     * Set the URL to use for requests.
     * @param {string|undefined} url URL.
     * @api
     */
    setUrl(url: string | undefined): void;
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(params: any): void;
}

type Options$J = {
    /**
     * URL to the OGC Map Tileset endpoint.
     */
    url: string;
    /**
     * A lookup of values to use in the tile URL template.  The `{tileMatrix}`
     * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
     */
    context?: any;
    /**
     * The content type for the tiles (e.g. "image/png").  If not provided,
     * the source will try to find a link with rel="item" that uses a supported image type.
     */
    mediaType?: string | undefined;
    /**
     * Projection. By default, the projection
     * will be derived from the `crs` of the `tileMatrixSet`.  You can override this by supplying
     * a projection to the constructor.
     */
    projection?: ProjectionLike;
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(tile, src) {
     * tile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * A list of geospatial data sub-resources to include. If not provided, the entire dataset will
     * be included. This option is not applicable when requesting the tileset for a single collection.
     */
    collections?: string[] | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} url URL to the OGC Map Tileset endpoint.
 * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`
 * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
 * @property {string} [mediaType] The content type for the tiles (e.g. "image/png").  If not provided,
 * the source will try to find a link with rel="item" that uses a supported image type.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. By default, the projection
 * will be derived from the `crs` of the `tileMatrixSet`.  You can override this by supplying
 * a projection to the constructor.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(tile, src) {
 *   tile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {Array<string>} [collections] A list of geospatial data sub-resources to include. If not provided, the entire dataset will
 * be included. This option is not applicable when requesting the tileset for a single collection.
 */
/**
 * @classdesc
 * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides "map" type tiles.
 * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)
 * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes. For supporting the `collections`
 * option, the service must conform to the collections selection
 * (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection) conformance class.
 * @api
 */
declare class OGCMapTile extends TileImage {
    /**
     * @param {Options} options OGC map tile options.
     */
    constructor(options: Options$J);
    /**
     * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
     * @private
     */
    private handleTileSetInfo_;
    /**
     * @private
     * @param {Error} error The error.
     */
    private handleError_;
}

type Options$I<FeatureType extends FeatureLike = RenderFeature> = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
     */
    cacheSize?: number | undefined;
    /**
     * Extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * Feature format for tiles. Used and required by the default.
     */
    format?: FeatureFormat<FeatureType> | undefined;
    /**
     * This source may have overlapping geometries. Setting this
     * to `false` (e.g. for sources with polygons that represent administrative
     * boundaries or TopoJSON sources) allows the renderer to optimise fill and
     * stroke operations.
     */
    overlaps?: boolean | undefined;
    /**
     * Projection of the tile grid.
     */
    projection?: ProjectionLike;
    /**
     * Source state.
     */
    state?: State$2 | undefined;
    /**
     * Class used to instantiate tiles.
     * Default is {@link module :ol/VectorTile~VectorTile}.
     */
    tileClass?: typeof VectorTile$1 | undefined;
    /**
     * Optional max zoom level. Not used if `tileGrid` is provided.
     */
    maxZoom?: number | undefined;
    /**
     * Optional min zoom level. Not used if `tileGrid` is provided.
     */
    minZoom?: number | undefined;
    /**
     * Optional tile size. Not used if `tileGrid` is provided.
     */
    tileSize?: number | Size | undefined;
    /**
     * Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
     */
    maxResolution?: number | undefined;
    /**
     * Tile grid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * Optional function to load a tile given a URL. Could look like this for pbf tiles:
     * ```js
     * function(tile, url) {
     * tile.setLoader(function(extent, resolution, projection) {
     * fetch(url).then(function(response) {
     * response.arrayBuffer().then(function(data) {
     * const format = tile.getFormat() // ol/format/MVT configured as source format
     * const features = format.readFeatures(data, {
     * extent: extent,
     * featureProjection: projection
     * });
     * tile.setFeatures(features);
     * });
     * });
     * });
     * }
     * ```
     * If you do not need extent, resolution and projection to get the features for a tile (e.g.
     * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure
     * to call `setFeatures()` on the tile:
     * ```js
     * const format = new GeoJSON({featureProjection: map.getView().getProjection()});
     * async function tileLoadFunction(tile, url) {
     * const response = await fetch(url);
     * const data = await response.json();
     * tile.setFeatures(format.readFeatures(data));
     * }
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * Optional function to get tile URL given a tile coordinate and the projection.
     */
    tileUrlFunction?: UrlFunction | undefined;
    /**
     * URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
     * used instead of defining each one separately in the `urls` option.
     */
    url?: string | undefined;
    /**
     * A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     */
    transition?: number | undefined;
    /**
     * An array of URL templates.
     */
    urls?: string[] | undefined;
    /**
     * Whether to wrap the world horizontally.
     * When set to `false`, only one world
     * will be rendered. When set to `true`, tiles will be wrapped horizontally to
     * render multiple worlds.
     */
    wrapX?: boolean | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../render/Feature.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {import("../format/Feature.js").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate tiles.
 * Default is {@link module:ol/VectorTile~VectorTile}.
 * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. Could look like this for pbf tiles:
 * ```js
 * function(tile, url) {
 *   tile.setLoader(function(extent, resolution, projection) {
 *     fetch(url).then(function(response) {
 *       response.arrayBuffer().then(function(data) {
 *         const format = tile.getFormat() // ol/format/MVT configured as source format
 *         const features = format.readFeatures(data, {
 *           extent: extent,
 *           featureProjection: projection
 *         });
 *         tile.setFeatures(features);
 *       });
 *     });
 *   });
 * }
 * ```
 * If you do not need extent, resolution and projection to get the features for a tile (e.g.
 * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure
 * to call `setFeatures()` on the tile:
 * ```js
 * const format = new GeoJSON({featureProjection: map.getView().getProjection()});
 * async function tileLoadFunction(tile, url) {
 *   const response = await fetch(url);
 *   const data = await response.json();
 *   tile.setFeatures(format.readFeatures(data));
 * }
 * ```
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature
 * editing.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../render/Feature.js").default]
 */
declare class VectorTile<FeatureType extends FeatureLike = RenderFeature> extends UrlTile {
    /**
     * @param {!Options<FeatureType>} options Vector tile options.
     */
    constructor(options: Options$I<FeatureType>);
    /**
     * @private
     * @type {import("../format/Feature.js").default<FeatureType>|null}
     */
    private format_;
    /**
     * @type {Object<string, Array<string>>}
     * @private
     */
    private tileKeysBySourceTileUrl_;
    /**
     @type {Object<string, Tile<FeatureType>>}
     */
    sourceTiles_: {
        [x: string]: VectorTile$1<FeatureType>;
    };
    /**
     * @private
     * @type {boolean}
     */
    private overlaps_;
    /**
     * @protected
     * @type {typeof import("../VectorTile.js").default}
     */
    protected tileClass: typeof VectorTile$1;
    /**
     * @private
     * @type {Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    private tileGrids_;
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps(): boolean;
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection").default} projection Projection.
     * @param {VectorRenderTile} tile Vector render tile.
     * @return {Array<import("../VectorTile").default>} Tile keys.
     */
    getSourceTiles(pixelRatio: number, projection: Projection, tile: VectorRenderTile): Array<VectorTile$1<any>>;
    /**
     * @param {VectorRenderTile} tile Vector render tile.
     */
    removeSourceTiles(tile: VectorRenderTile): void;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!VectorRenderTile} Tile.
     * @override
     */
    override getTile(z: number, x: number, y: number, pixelRatio: number, projection: Projection): VectorRenderTile;
    /**
     * @param {boolean} overlaps The source has overlapping geometries.
     */
    setOverlaps(overlaps: boolean): void;
}

type Options$H<FeatureType extends FeatureLike = RenderFeature> = {
    /**
     * URL to the OGC Vector Tileset endpoint.
     */
    url: string;
    /**
     * A lookup of values to use in the tile URL template.  The `{tileMatrix}`
     * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
     */
    context?: any;
    /**
     * Feature format for tiles. Used and required by the default.
     */
    format?: FeatureFormat<FeatureType> | undefined;
    /**
     * The content type for the tiles (e.g. "application/vnd.mapbox-vector-tile").  If not provided,
     * the source will try to find a link with rel="item" that uses a vector type supported by the configured format.
     */
    mediaType?: string | undefined;
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * This source may have overlapping geometries. Setting this
     * to `false` (e.g. for sources with polygons that represent administrative
     * boundaries or TopoJSON sources) allows the renderer to optimise fill and
     * stroke operations.
     */
    overlaps?: boolean | undefined;
    /**
     * Projection of the tile grid.
     */
    projection?: ProjectionLike;
    /**
     * Class used to instantiate image tiles.
     * Default is {@link module :ol/VectorTile~VectorTile}.
     */
    tileClass?: typeof VectorTile$1 | undefined;
    /**
     * A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     */
    transition?: number | undefined;
    /**
     * Whether to wrap the world horizontally.
     * When set to `false`, only one world
     * will be rendered. When set to `true`, tiles will be wrapped horizontally to
     * render multiple worlds.
     */
    wrapX?: boolean | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
    /**
     * A list of geospatial data sub-resources to include. If not provided, the entire dataset will
     * be included. This option is not applicable when requesting the tileset for a single collection.
     */
    collections?: string[] | undefined;
};
/**
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../render/Feature.js").default]
 * @typedef {Object} Options
 * @property {string} url URL to the OGC Vector Tileset endpoint.
 * @property {Object} [context] A lookup of values to use in the tile URL template.  The `{tileMatrix}`
 * (zoom level), `{tileRow}`, and `{tileCol}` variables in the URL will always be provided by the source.
 * @property {import("../format/Feature.js").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.
 * @property {string} [mediaType] The content type for the tiles (e.g. "application/vnd.mapbox-vector-tile").  If not provided,
 * the source will try to find a link with rel="item" that uses a vector type supported by the configured format.
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/VectorTile~VectorTile}.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {Array<string>} [collections] A list of geospatial data sub-resources to include. If not provided, the entire dataset will
 * be included. This option is not applicable when requesting the tileset for a single collection.
 */
/**
 * @classdesc
 * Layer source for map tiles from an [OGC API - Tiles](https://ogcapi.ogc.org/tiles/) service that provides "vector" type tiles.
 * The service must conform to at least the core (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/core)
 * and tileset (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/tileset) conformance classes. For supporting the `collections`
 * option, the service must conform to the collections selection
 * (http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection) conformance class.
 *
 * Vector tile sets may come in a variety of formats (e.g. GeoJSON, MVT).  The `format` option is used to determine
 * which of the advertised media types is used.  If you need to force the use of a particular media type, you can
 * provide the `mediaType` option.
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../render/Feature.js").default]
 * @extends {VectorTileSource<FeatureType>}
 */
declare class OGCVectorTile<FeatureType extends FeatureLike = RenderFeature> extends VectorTile<FeatureType> {
    /**
     * @param {Options<FeatureType>} options OGC vector tile options.
     */
    constructor(options: Options$H<FeatureType>);
    /**
     * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
     * @private
     */
    private handleTileSetInfo_;
    /**
     * @private
     * @param {Error} error The error.
     */
    private handleError_;
}

type Options$G = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Max zoom.
     */
    maxZoom?: number | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * URL template.
     * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     */
    url?: string | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
declare class OSM extends XYZ {
    /**
     * @param {Options} [options] Open Street Map options.
     */
    constructor(options?: Options$G);
}

/**
 * @typedef {'pixel' | 'image'} RasterOperationType
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 */
/**
 * @typedef {import("./Image.js").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this
 * type.
 */
declare class RasterSourceEvent extends BaseEvent {
    /**
     * @param {string} type Type.
     * @param {import("../Map.js").FrameState} frameState The frame state.
     * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
     * this will be an array of objects if more than one thread is used.
     */
    constructor(type: string, frameState: FrameState, data: any | Array<any>);
    /**
     * The raster extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    extent: Extent$1;
    /**
     * The pixel resolution (map units per pixel).
     * @type {number}
     * @api
     */
    resolution: number;
    /**
     * An object made available to all operations.  This can be used by operations
     * as a storage object (e.g. for calculating statistics).
     * @type {Object}
     * @api
     */
    data: any;
}

/**
 * A function that takes an array of input data, performs some operation, and
 * returns an array of output data.
 * For `pixel` type operations, the function will be called with an array of
 * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
 * range of 0 - 255. It should return a single pixel array.
 * For `'image'` type operations, functions will be called with an array of
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)
 * and should return a single
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).
 * The operations
 * are called with a second "data" argument, which can be used for storage.  The
 * data object is accessible from raster events, where it can be initialized in
 * "beforeoperations" and accessed again in "afteroperations".
 */
type Operation = (arg0: (Array<Array<number>> | Array<ImageData>), arg1: any) => (Array<number> | ImageData);
/**
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 */
type RasterOperationType = "pixel" | "image";
type RasterSourceEventTypes = ImageSourceEventTypes | "beforeoperations" | "afteroperations";
type Options$F = {
    /**
     * Input
     * sources or layers.  For vector data, use an VectorImage layer.
     */
    sources: Array<Source | Layer>;
    /**
     * Raster operation.
     * The operation will be called with data from input sources
     * and the output will be assigned to the raster source.
     */
    operation?: Operation | undefined;
    /**
     * Functions that will be made available to operations run in a worker.
     */
    lib?: any;
    /**
     * By default, operations will be run in a single worker thread.
     * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
     * be run in multiple worker threads.  Note that there is additional overhead in
     * transferring data to multiple workers, and that depending on the user's
     * system, it may not be possible to parallelize the work.
     */
    threads?: number | undefined;
    /**
     * Operation type.
     * Supported values are `'pixel'` and `'image'`.  By default,
     * `'pixel'` operations are assumed, and operations will be called with an
     * array of pixels from input sources.  If set to `'image'`, operations will
     * be called with an array of ImageData objects from input sources.
     */
    operationType?: RasterOperationType | undefined;
    /**
     * Resolutions. If specified, raster operations will only
     * be run at the given resolutions.  By default, the resolutions of the first source with resolutions
     * specified will be used, if any. Set to `null` to use any view resolution instead.
     */
    resolutions?: number[] | null | undefined;
};
/**
 * *
 */
type RasterSourceOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2, ObjectEvent, Return> & OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> & OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | RasterSourceEventTypes, Return>;

/**
 * @typedef {Object} Options
 * @property {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources Input
 * sources or layers.  For vector data, use an VectorImage layer.
 * @property {Operation} [operation] Raster operation.
 * The operation will be called with data from input sources
 * and the output will be assigned to the raster source.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} [threads] By default, operations will be run in a single worker thread.
 * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
 * be run in multiple worker threads.  Note that there is additional overhead in
 * transferring data to multiple workers, and that depending on the user's
 * system, it may not be possible to parallelize the work.
 * @property {RasterOperationType} [operationType='pixel'] Operation type.
 * Supported values are `'pixel'` and `'image'`.  By default,
 * `'pixel'` operations are assumed, and operations will be called with an
 * array of pixels from input sources.  If set to `'image'`, operations will
 * be called with an array of ImageData objects from input sources.
 * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only
 * be run at the given resolutions.  By default, the resolutions of the first source with resolutions
 * specified will be used, if any. Set to `null` to use any view resolution instead.
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./Image.js").ImageSourceEventTypes, import("./Image.js").ImageSourceEvent, Return> &
 *   import("../Observable").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature
 */
/**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link module:ol/source/Raster~Operation} function to transform input pixel values into
 * output pixel values.
 *
 * @fires module:ol/source/Raster.RasterSourceEvent
 * @api
 */
declare class RasterSource extends ImageSource {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options$F);
    /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */
    on: RasterSourceOnSignature<EventsKey>;
    /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */
    once: RasterSourceOnSignature<EventsKey>;
    /***
     * @type {RasterSourceOnSignature<void>}
     */
    un: RasterSourceOnSignature<void>;
    /**
     * @private
     * @type {Processor}
     */
    private processor_;
    /**
     * @private
     * @type {RasterOperationType}
     */
    private operationType_;
    /**
     * @private
     * @type {number}
     */
    private threads_;
    /**
     * @private
     * @type {Array<import("../layer/Layer.js").default>}
     */
    private layers_;
    /**
     * @private
     * @type {boolean}
     */
    private useResolutions_;
    /**
     * @private
     * @type {import("../TileQueue.js").default}
     */
    private tileQueue_;
    /**
     * The most recently requested frame state.
     * @type {import("../Map.js").FrameState}
     * @private
     */
    private requestedFrameState_;
    /**
     * The most recently rendered image canvas.
     * @type {import("../ImageCanvas.js").default}
     * @private
     */
    private renderedImageCanvas_;
    /**
     * The most recently rendered revision.
     * @type {number}
     * @private
     */
    private renderedRevision_;
    /**
     * @private
     * @type {import("../Map.js").FrameState}
     */
    private frameState_;
    /**
     * Set the operation.
     * @param {Operation} operation New operation.
     * @param {Object} [lib] Functions that will be available to operations run
     *     in a worker.
     * @api
     */
    setOperation(operation: Operation, lib?: any): void;
    /**
     * Update the stored frame state.
     * @param {import("../extent.js").Extent} extent The view extent (in map units).
     * @param {number} resolution The view resolution.
     * @param {import("../proj/Projection.js").default} projection The view projection.
     * @return {import("../Map.js").FrameState} The updated frame state.
     * @private
     */
    private updateFrameState_;
    /**
     * Determine if all sources are ready.
     * @return {boolean} All sources are ready.
     * @private
     */
    private allSourcesReady_;
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../ImageCanvas.js").default} Single image.
     * @override
     */
    override getImage(extent: Extent$1, resolution: number, pixelRatio: number, projection: Projection): ImageCanvas;
    /**
     * Start processing source data.
     * @private
     */
    private processSources_;
    /**
     * Called when pixel processing is complete.
     * @param {import("../Map.js").FrameState} frameState The frame state.
     * @param {Error} err Any error during processing.
     * @param {ImageData} output The output image data.
     * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
     * @private
     */
    private onWorkerComplete_;
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    override getResolutions(projection?: Projection): Array<number> | null;
}

type Options$E = {
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Layer name. Valid values: `alidade_smooth`, `alidade_smooth_dark`, `outdoors`, `stamen_terrain`, `stamen_terrain_background`, `stamen_terrain_labels`, `stamen_terrain_lines`, `stamen_toner_background`, `stamen_toner`, `stamen_toner_labels`, `stamen_toner_lines`, `stamen_toner_lite`, `stamen_watercolor`, and `osm_bright`.
     */
    layer: string;
    /**
     * Minimum zoom.
     */
    minZoom?: number | undefined;
    /**
     * Maximum zoom.
     */
    maxZoom?: number | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     */
    url?: string | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
    /**
     * Stadia Maps API key. Not required for localhost or most public web deployments. See https://docs.stadiamaps.com/authentication/ for details.
     */
    apiKey?: string | undefined;
    /**
     * Use retina tiles (if available; not available for Stamen Watercolor).
     */
    retina?: boolean | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {string} layer Layer name. Valid values: `alidade_smooth`, `alidade_smooth_dark`, `outdoors`, `stamen_terrain`, `stamen_terrain_background`, `stamen_terrain_labels`, `stamen_terrain_lines`, `stamen_toner_background`, `stamen_toner`, `stamen_toner_labels`, `stamen_toner_lines`, `stamen_toner_lite`, `stamen_watercolor`, and `osm_bright`.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {string} [apiKey] Stadia Maps API key. Not required for localhost or most public web deployments. See https://docs.stadiamaps.com/authentication/ for details.
 * @property {boolean} [retina] Use retina tiles (if available; not available for Stamen Watercolor).
 */
/**
 * @classdesc
 * Layer source for the Stadia Maps tile server.
 * @api
 */
declare class StadiaMaps extends XYZ {
    /**
     * @param {Options} options StadiaMaps options.
     */
    constructor(options: Options$E);
}

type Options$D = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * ArcGIS Rest parameters. This field is optional. Service defaults will be
     * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by
     * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,
     * and `IMAGESR` will be set dynamically. Set `LAYERS` to
     * override the default service layer visibility. See
     * https://developers.arcgis.com/rest/services-reference/export-map.htm
     * for further reference.
     */
    params?: {
        [x: string]: any;
    } | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * Tile grid. Base this on the resolutions,
     * tilesize and extent supported by the server.
     * If this is not defined, a default grid will be used: if there is a projection
     * extent, the grid will be based on that; if not, a grid based on a global
     * extent with origin at 0,0 will be used.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * Projection. Default is the view projection.
     * The projection code must contain a numeric end portion separated by :
     * or the entire code must form a valid ArcGIS SpatialReference definition.
     */
    projection?: ProjectionLike;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Optional function to load a tile given a URL.
     * The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * ArcGIS Rest service URL for a Map Service or Image Service. The
     * url should include /MapServer or /ImageServer.
     */
    url?: string | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.  To disable the opacity
     * transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS
     * Service supports multiple urls for export requests.
     */
    urls?: string[] | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be
 * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by
 * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,
 * and `IMAGESR` will be set dynamically. Set `LAYERS` to
 * override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.
 * The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The
 * url should include /MapServer or /ImageServer.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity
 * transition, pass `transition: 0`.
 * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS
 * Service supports multiple urls for export requests.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 *
 * For cached ArcGIS services, better performance is available using the
 * {@link module:ol/source/XYZ~XYZ} data source.
 * @api
 */
declare class TileArcGISRest extends TileImage {
    /**
     * @param {Options} [options] Tile ArcGIS Rest options.
     */
    constructor(options?: Options$D);
    /**
     * @private
     * @type {!Object}
     */
    private params_;
    /**
     * @private
     * @type {boolean}
     */
    private hidpi_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private tmpExtent_;
    /**
     * @private
     * @return {string} The key for the current params.
     */
    private getKeyForParams_;
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams(): any;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../size.js").Size} tileSize Tile size.
     * @param {import("../extent.js").Extent} tileExtent Tile extent.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {Object} params Params.
     * @return {string|undefined} Request URL.
     * @private
     */
    private getRequestUrl_;
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(params: any): void;
}

type Options$C = {
    /**
     * Optional projection.
     */
    projection?: ProjectionLike;
    /**
     * Tile grid.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Set to `1` when debugging `VectorTile` sources with a default configuration.
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
    /**
     * Tile source.
     * This allows `projection`, `tileGrid`, `wrapX` and `zDirection` to be copied from another source.
     * If both `source` and individual options are specified the individual options will have precedence.
     */
    source?: TileSource<Tile$1> | undefined;
    /**
     * Template for labeling the tiles.
     * Should include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     */
    template?: string | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Optional projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Set to `1` when debugging `VectorTile` sources with a default configuration.
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 * @property {import("./Tile.js").default} [source] Tile source.
 * This allows `projection`, `tileGrid`, `wrapX` and `zDirection` to be copied from another source.
 * If both `source` and individual options are specified the individual options will have precedence.
 * @property {string} [template='z:{z} x:{x} y:{y}'] Template for labeling the tiles.
 * Should include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 */
/**
 * @classdesc
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 * @api
 */
declare class TileDebug extends ImageTileSource {
    /**
     * @param {Options} [options] Debug tile options.
     */
    constructor(options?: Options$C);
}

type Config = {
    /**
     * The name.
     */
    name?: string | undefined;
    /**
     * The description.
     */
    description?: string | undefined;
    /**
     * The version.
     */
    version?: string | undefined;
    /**
     * The attribution.
     */
    attribution?: string | undefined;
    /**
     * The template.
     */
    template?: string | undefined;
    /**
     * The legend.
     */
    legend?: string | undefined;
    /**
     * The scheme.
     */
    scheme?: string | undefined;
    /**
     * The tile URL templates.
     */
    tiles: Array<string>;
    /**
     * Optional grids.
     */
    grids?: string[] | undefined;
    /**
     * Minimum zoom level.
     */
    minzoom?: number | undefined;
    /**
     * Maximum zoom level.
     */
    maxzoom?: number | undefined;
    /**
     * Optional bounds.
     */
    bounds?: number[] | undefined;
    /**
     * Optional center.
     */
    center?: number[] | undefined;
};
type Options$B = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Use JSONP with callback to load the TileJSON.
     * Useful when the server does not support CORS..
     */
    jsonp?: boolean | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * TileJSON configuration for this source.
     * If not provided, `url` must be configured.
     */
    tileJSON?: Config | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * The tile size used by the tile service.
     * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.
     */
    tileSize?: number | Size | undefined;
    /**
     * URL to the TileJSON file. If not provided, `tileJSON` must be configured.
     */
    url?: string | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Config
 * @property {string} [name] The name.
 * @property {string} [description] The description.
 * @property {string} [version] The version.
 * @property {string} [attribution] The attribution.
 * @property {string} [template] The template.
 * @property {string} [legend] The legend.
 * @property {string} [scheme] The scheme.
 * @property {Array<string>} tiles The tile URL templates.
 * @property {Array<string>} [grids] Optional grids.
 * @property {number} [minzoom] Minimum zoom level.
 * @property {number} [maxzoom] Maximum zoom level.
 * @property {Array<number>} [bounds] Optional bounds.
 * @property {Array<number>} [center] Optional center.
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.
 * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 * @api
 */
declare class TileJSON extends TileImage {
    /**
     * @param {Options} options TileJSON options.
     */
    constructor(options: Options$B);
    /**
     * @type {Config}
     * @private
     */
    private tileJSON_;
    /**
     * @type {number|import("../size.js").Size}
     * @private
     */
    private tileSize_;
    /**
     * @private
     * @param {Event} event The load event.
     */
    private onXHRLoad_;
    /**
     * @private
     * @param {Event} event The error event.
     */
    private onXHRError_;
    /**
     * @return {Config} The tilejson object.
     * @api
     */
    getTileJSON(): Config;
    /**
     * @protected
     * @param {Config} tileJSON Tile JSON.
     */
    protected handleTileJSONResponse(tileJSON: Config): void;
    /**
     * @protected
     */
    protected handleTileJSONError(): void;
}

type Options$A = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * WMS request parameters.
     * At least a `LAYERS` param is required. `STYLES` is
     * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
     * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
     */
    params: {
        [x: string]: any;
    };
    /**
     * The size in pixels of the gutter around image tiles to ignore. By setting
     * this property to a non-zero value, images will be requested that are wider
     * and taller than the tile size by a value of `2 x gutter`.
     * Using a non-zero value allows artifacts of rendering at tile edges to be
     * ignored. If you control the WMS service it is recommended to address
     * "artifacts at tile edges" issues by properly configuring the WMS service. For
     * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
     * this. See https://mapserver.org/output/tile_mode.html.
     */
    gutter?: number | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Class used to instantiate image tiles.
     * Default is {@link module :ol/ImageTile~ImageTile}.
     */
    tileClass?: typeof ImageTile | undefined;
    /**
     * Tile grid. Base this on the resolutions,
     * tilesize and extent supported by the server.
     * If this is not defined, a default grid will be used: if there is a projection
     * extent, the grid will be based on that; if not, a grid based on a global
     * extent with origin at 0,0 will be used.
     */
    tileGrid?: TileGrid | undefined;
    /**
     * The type of
     * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
     * Only needed if `hidpi` is `true`.
     */
    serverType?: ServerType | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * WMS service URL.
     */
    url?: string | undefined;
    /**
     * WMS service urls.
     * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
     */
    urls?: string[] | undefined;
    /**
     * Whether to wrap the world horizontally.
     * When set to `false`, only one world
     * will be rendered. When `true`, tiles will be requested for one world only,
     * but they will be wrapped horizontally to render multiple worlds.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See https://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */
declare class TileWMS extends TileImage {
    /**
     * @param {Options} [options] Tile WMS options.
     */
    constructor(options?: Options$A);
    /**
     * @private
     * @type {number}
     */
    private gutter_;
    /**
     * @private
     * @type {!Object}
     */
    private params_;
    /**
     * @private
     * @type {boolean}
     */
    private v13_;
    /**
     * @private
     * @type {import("./wms.js").ServerType}
     */
    private serverType_;
    /**
     * @private
     * @type {boolean}
     */
    private hidpi_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private tmpExtent_;
    /**
     * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
     * projection. Return `undefined` if the GetFeatureInfo URL cannot be
     * constructed.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
     *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
     *     in the `LAYERS` parameter will be used. `VERSION` should not be
     *     specified here.
     * @return {string|undefined} GetFeatureInfo URL.
     * @api
     */
    getFeatureInfoUrl(coordinate: Coordinate, resolution: number, projection: ProjectionLike, params: any): string | undefined;
    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */
    getLegendUrl(resolution?: number, params?: any): string | undefined;
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams(): any;
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} tileExtent Tile extent.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {Object} params Params.
     * @return {string|undefined} Request URL.
     * @private
     */
    private getRequestUrl_;
    /**
     * @private
     * @return {string} The key for the current params.
     */
    private getKeyForParams_;
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(params: any): void;
    /**
     * @private
     */
    private updateV13_;
}

/**
 * @typedef {Object} UTFGridJSON
 * @property {Array<string>} grid The grid.
 * @property {Array<string>} keys The keys.
 * @property {Object<string, Object>} [data] Optional data.
 */
declare class CustomTile extends Tile$1 {
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {import("../extent.js").Extent} extent Extent of the tile.
     * @param {boolean} preemptive Load the tile when visible (before it's needed).
     * @param {boolean} jsonp Load the tile as a script.
     */
    constructor(tileCoord: TileCoord, state: any, src: string, extent: Extent$1, preemptive: boolean, jsonp: boolean);
    /**
     * @private
     * @type {string}
     */
    private src_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private extent_;
    /**
     * @private
     * @type {boolean}
     */
    private preemptive_;
    /**
     * @private
     * @type {Array<string>}
     */
    private grid_;
    /**
     * @private
     * @type {Array<string>}
     */
    private keys_;
    /**
     * @private
     * @type {Object<string, Object>|undefined}
     */
    private data_;
    /**
     * @private
     * @type {boolean}
     */
    private jsonp_;
    /**
     * Get the image element for this tile.
     * @return {HTMLImageElement} Image.
     */
    getImage(): HTMLImageElement;
    /**
     * Synchronously returns data at given coordinate (if available).
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {*} The data.
     */
    getData(coordinate: Coordinate): any;
    /**
     * Calls the callback (synchronously by default) with the available data
     * for given coordinate (or `null` if not yet loaded).
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(*): void} callback Callback.
     * @param {boolean} [request] If `true` the callback is always async.
     *                               The tile data is requested if not yet loaded.
     */
    forDataAtCoordinate(coordinate: Coordinate, callback: (arg0: any) => void, request?: boolean): void;
    /**
     * @private
     */
    private handleError_;
    /**
     * @param {!UTFGridJSON} json UTFGrid data.
     * @private
     */
    private handleLoad_;
    /**
     * @private
     */
    private loadInternal_;
    /**
     * @private
     * @param {Event} event The load event.
     */
    private onXHRLoad_;
    /**
     * @private
     * @param {Event} event The error event.
     */
    private onXHRError_;
}

type Options$z = {
    /**
     * If `true` the UTFGrid source loads the tiles based on their "visibility".
     * This improves the speed of response, but increases traffic.
     * Note that if set to `false` (lazy loading), you need to pass `true` as
     * `request` to the `forDataAtCoordinateAndResolution` method otherwise no
     * data will ever be loaded.
     */
    preemptive?: boolean | undefined;
    /**
     * Use JSONP with callback to load the TileJSON.
     * Useful when the server does not support CORS..
     */
    jsonp?: boolean | undefined;
    /**
     * TileJSON configuration for this source.
     * If not provided, `url` must be configured.
     */
    tileJSON?: Config | undefined;
    /**
     * TileJSON endpoint that provides the configuration for this source.
     * Request will be made through JSONP. If not provided, `tileJSON` must be configured.
     */
    url?: string | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};

/**
 * @typedef {Object} Options
 * @property {boolean} [preemptive=true]
 * If `true` the UTFGrid source loads the tiles based on their "visibility".
 * This improves the speed of response, but increases traffic.
 * Note that if set to `false` (lazy loading), you need to pass `true` as
 * `request` to the `forDataAtCoordinateAndResolution` method otherwise no
 * data will ever be loaded.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {import("./TileJSON.js").Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {string} [url] TileJSON endpoint that provides the configuration for this source.
 * Request will be made through JSONP. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 * @api
 */
declare class UTFGrid extends TileSource<Tile$1> {
    /**
     * @param {Options} options Source options.
     */
    constructor(options: Options$z);
    /**
     * @private
     * @type {boolean}
     */
    private preemptive_;
    /**
     * @private
     * @type {!import("../Tile.js").UrlFunction}
     */
    private tileUrlFunction_;
    /**
     * @private
     * @type {string|undefined}
     */
    private template_;
    /**
     * @private
     * @type {boolean}
     */
    private jsonp_;
    /**
     * @private
     * @param {Event} event The load event.
     */
    private onXHRLoad_;
    /**
     * @private
     * @param {Event} event The error event.
     */
    private onXHRError_;
    /**
     * Return the template from TileJSON.
     * @return {string|undefined} The template from TileJSON.
     * @api
     */
    getTemplate(): string | undefined;
    /**
     * Calls the callback (synchronously by default) with the available data
     * for given coordinate and resolution (or `null` if not yet loaded or
     * in case of an error).
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {function(*): void} callback Callback.
     * @param {boolean} [request] If `true` the callback is always async.
     *                               The tile data is requested if not yet loaded.
     * @api
     */
    forDataAtCoordinateAndResolution(coordinate: Coordinate, resolution: number, callback: (arg0: any) => void, request?: boolean): void;
    /**
     * @protected
     */
    protected handleTileJSONError(): void;
    /**
     * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse
     * @protected
     * @param {import("./TileJSON.js").Config} tileJSON Tile JSON.
     */
    protected handleTileJSONResponse(tileJSON: Config): void;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!CustomTile} Tile.
     * @override
     */
    override getTile(z: number, x: number, y: number, pixelRatio: number, projection: Projection): CustomTile;
}

/**
 * Request encoding. One of 'KVP', 'REST'.
 */
type RequestEncoding = "KVP" | "REST";
type Options$y = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Attributions are collapsible.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Tile grid.
     */
    tileGrid: WMTSTileGrid;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * Request encoding.
     */
    requestEncoding?: RequestEncoding | undefined;
    /**
     * Layer name as advertised in the WMTS capabilities.
     */
    layer: string;
    /**
     * Style name as advertised in the WMTS capabilities.
     */
    style: string;
    /**
     * Class used to instantiate image tiles. Default is {@link module :ol/ImageTile~ImageTile}.
     */
    tileClass?: typeof ImageTile | undefined;
    /**
     * The pixel ratio used by the tile service.
     * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     */
    tilePixelRatio?: number | undefined;
    /**
     * Image format. Only used when `requestEncoding` is `'KVP'`.
     */
    format?: string | undefined;
    /**
     * WMTS version.
     */
    version?: string | undefined;
    /**
     * Matrix set.
     */
    matrixSet: string;
    /**
     * Additional "dimensions" for tile requests.
     * This is an object with properties named like the advertised WMTS dimensions.
     */
    dimensions?: any;
    /**
     * A URL for the service.
     * For the RESTful request encoding, this is a URL
     * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
     * for example `subdomain{a-f}.domain.com`, may be used instead of defining
     * each one separately in the `urls` option.
     */
    url?: string | undefined;
    /**
     * Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     * imageTile.getImage().src = src;
     * };
     * ```
     */
    tileLoadFunction?: LoadFunction$1 | undefined;
    /**
     * An array of URLs.
     * Requests will be distributed among the URLs in this array.
     */
    urls?: string[] | undefined;
    /**
     * Whether to wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};
/**
 * Request encoding. One of 'KVP', 'REST'.
 * @typedef {'KVP' | 'REST'} RequestEncoding
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {RequestEncoding} [requestEncoding='KVP'] Request encoding.
 * @property {string} layer Layer name as advertised in the WMTS capabilities.
 * @property {string} style Style name as advertised in the WMTS capabilities.
 * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
 * @property {string} [version='1.0.0'] WMTS version.
 * @property {string} matrixSet Matrix set.
 * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
 * This is an object with properties named like the advertised WMTS dimensions.
 * @property {string} [url]  A URL for the service.
 * For the RESTful request encoding, this is a URL
 * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
 * for example `subdomain{a-f}.domain.com`, may be used instead of defining
 * each one separately in the `urls` option.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [urls] An array of URLs.
 * Requests will be distributed among the URLs in this array.
 * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 * @api
 */
declare class WMTS extends TileImage {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(options: Options$y);
    /**
     * @private
     * @type {string}
     */
    private version_;
    /**
     * @private
     * @type {string}
     */
    private format_;
    /**
     * @private
     * @type {!Object}
     */
    private dimensions_;
    /**
     * @private
     * @type {string}
     */
    private layer_;
    /**
     * @private
     * @type {string}
     */
    private matrixSet_;
    /**
     * @private
     * @type {string}
     */
    private style_;
    /**
     * @private
     * @type {RequestEncoding}
     */
    private requestEncoding_;
    /**
     * Get the dimensions, i.e. those passed to the constructor through the
     * "dimensions" option, and possibly updated using the updateDimensions
     * method.
     * @return {!Object} Dimensions.
     * @api
     */
    getDimensions(): any;
    /**
     * Return the image format of the WMTS source.
     * @return {string} Format.
     * @api
     */
    getFormat(): string;
    /**
     * Return the layer of the WMTS source.
     * @return {string} Layer.
     * @api
     */
    getLayer(): string;
    /**
     * Return the matrix set of the WMTS source.
     * @return {string} MatrixSet.
     * @api
     */
    getMatrixSet(): string;
    /**
     * Return the request encoding, either "KVP" or "REST".
     * @return {RequestEncoding} Request encoding.
     * @api
     */
    getRequestEncoding(): RequestEncoding;
    /**
     * Return the style of the WMTS source.
     * @return {string} Style.
     * @api
     */
    getStyle(): string;
    /**
     * Return the version of the WMTS source.
     * @return {string} Version.
     * @api
     */
    getVersion(): string;
    /**
     * @private
     * @return {string} The key for the current dimensions.
     */
    private getKeyForDimensions_;
    /**
     * Update the dimensions.
     * @param {Object} dimensions Dimensions.
     * @api
     */
    updateDimensions(dimensions: any): void;
    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
    createFromWMTSTemplate(template: string): UrlFunction;
}

type TierSizeCalculation = "default" | "truncated";
type Options$x = {
    /**
     * Attributions.
     */
    attributions?: AttributionLike | undefined;
    /**
     * Deprecated.  Use the cacheSize option on the layer instead.
     */
    cacheSize?: number | undefined;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Projection.
     */
    projection?: ProjectionLike;
    /**
     * The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`
     */
    tilePixelRatio?: number | undefined;
    /**
     * Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     */
    reprojectionErrorThreshold?: number | undefined;
    /**
     * URL template or base URL of the Zoomify service.
     * A base URL is the fixed part
     * of the URL, excluding the tile group, z, x, and y folder structure, e.g.
     * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include
     * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.
     * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.
     * Internet Imaging Protocol (IIP) with JTL extension can be also used with
     * `{tileIndex}` and `{z}` placeholders, e.g.
     * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.
     * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
     * used instead of defining each one separately in the `urls` option.
     */
    url: string;
    /**
     * Tier size calculation method: `default` or `truncated`.
     */
    tierSizeCalculation?: TierSizeCalculation | undefined;
    /**
     * Size.
     */
    size: Size;
    /**
     * Extent for the TileGrid that is created.
     * Default sets the TileGrid in the
     * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the
     * extent to the first quadrant (the default for OpenLayers 2) set the extent
     * as `[0, 0, width, height]`.
     */
    extent?: Extent$1 | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
    /**
     * Tile size. Same tile size is used for all zoom levels.
     */
    tileSize?: number | undefined;
    /**
     * Choose whether to use tiles with a higher or lower zoom level when between integer
     * zoom levels. See {@link module :ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
     */
    zDirection?: number | NearestDirectionFunction | undefined;
};

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {number} [tilePixelRatio] The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {string} url URL template or base URL of the Zoomify service.
 * A base URL is the fixed part
 * of the URL, excluding the tile group, z, x, and y folder structure, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include
 * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.
 * Internet Imaging Protocol (IIP) with JTL extension can be also used with
 * `{tileIndex}` and `{z}` placeholders, e.g.
 * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {TierSizeCalculation} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.
 * @property {import("../size.js").Size} size Size.
 * @property {import("../extent.js").Extent} [extent] Extent for the TileGrid that is created.
 * Default sets the TileGrid in the
 * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the
 * extent to the first quadrant (the default for OpenLayers 2) set the extent
 * as `[0, 0, width, height]`.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data in Zoomify format (both Zoomify and Internet
 * Imaging Protocol are supported).
 * @api
 */
declare class Zoomify extends TileImage {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options$x);
}

/**
 * @param {string} baseUrl Base URL for the ArcGIS Rest service.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("../proj/Projection.js").default} projection Projection.
 * @param {Object} params Params.
 * @return {string} Request URL.
 */
declare function getRequestUrl(baseUrl: string, extent: Extent$1, resolution: number, pixelRatio: number, projection: Projection, params: any): string;
/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * https://developers.arcgis.com/rest/services-reference/export-map.htm
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.
 * The projection code must contain a numeric end portion separated by :
 * or the entire code must form a valid ArcGIS SpatialReference definition.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {string} url ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */
/**
 * Creates a loader for ArcGIS Rest images.
 * @param {LoaderOptions} options Image ArcGIS Rest Options.
 * @return {import('../Image.js').ImageObjectPromiseLoader} ArcGIS Rest image.
 * @api
 */
declare function createLoader$2(options: LoaderOptions$2): ImageObjectPromiseLoader;
type LoaderOptions$2 = {
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting the image from
     * the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * ArcGIS Rest parameters. This field is optional. Service
     * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
     * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
     * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
     * https://developers.arcgis.com/rest/services-reference/export-map.htm
     * for further reference.
     */
    params?: {
        [x: string]: any;
    } | undefined;
    /**
     * Projection. Default is 'EPSG:3857'.
     * The projection code must contain a numeric end portion separated by :
     * or the entire code must form a valid ArcGIS SpatialReference definition.
     */
    projection?: ProjectionLike;
    /**
     * Ratio. `1` means image requests are the size of the map viewport,
     * `2` means twice the size of the map viewport, and so on.
     */
    ratio?: number | undefined;
    /**
     * ArcGIS Rest service URL for a Map Service or Image Service. The url
     * should include /MapServer or /ImageServer.
     */
    url: string;
    /**
     * Function
     * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
     * returns a promise resolving to the loaded or decoded image. Default is {@link module :ol/Image.decode}.
     */
    load?: ((arg0: HTMLImageElement, arg1: string) => Promise<ImageLike>) | undefined;
};

/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} imageExtent Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image. When using this loader with an
 * `ol/source/Image`, the same extent must be set as `extent` of the `ol/layer/Image`.
 * @property {string} url Image URL.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */
/**
 * Creates a loader for static images.
 * @param {LoaderOptions} options Loader options.
 * @return {import("../Image.js").ImageObjectPromiseLoader} Loader.
 * @api
 */
declare function createLoader$1(options: LoaderOptions$1): ImageObjectPromiseLoader;
type LoaderOptions$1 = {
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * Extent of the image in map coordinates.
     * This is the [left, bottom, right, top] map coordinates of your image. When using this loader with an
     * `ol/source/Image`, the same extent must be set as `extent` of the `ol/layer/Image`.
     */
    imageExtent: Extent$1;
    /**
     * Image URL.
     */
    url: string;
    /**
     * Function
     * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
     * returns a promise resolving to the loaded or decoded image. Default is {@link module :ol/Image.decode}.
     */
    load?: ((arg0: HTMLImageElement, arg1: string) => Promise<ImageLike>) | undefined;
};

/**
 * Creates a loader for MapGuide images.
 * @param {LoaderOptions} options Image ArcGIS Rest Options.
 * @return {import('../Image.js').ImageObjectPromiseLoader} ArcGIS Rest image.
 * @api
 */
declare function createLoader(options: LoaderOptions): ImageObjectPromiseLoader;
type LoaderOptions = {
    /**
     * The mapagent url.
     */
    url: string;
    /**
     * The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    crossOrigin?: string | null | undefined;
    /**
     * The display resolution.
     */
    displayDpi?: number | undefined;
    /**
     * The meters-per-unit value.
     */
    metersPerUnit?: number | undefined;
    /**
     * Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     */
    hidpi?: boolean | undefined;
    /**
     * If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
     */
    useOverlay?: boolean | undefined;
    /**
     * Ratio. `1` means image requests are the size of the map viewport, `2` means
     * twice the width and height of the map viewport, and so on. Must be `1` or higher.
     */
    ratio?: number | undefined;
    /**
     * Additional query parameters.
     */
    params?: any;
    /**
     * Function
     * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
     * returns a promise resolving to the loaded or decoded image. Default is {@link module :ol/Image.decode}.
     */
    load?: ((arg0: HTMLImageElement, arg1: string) => Promise<ImageLike>) | undefined;
};

/**
 * Creates a sources function from a tile grid. This function can be used as value for the
 * `sources` property of the {@link module:ol/layer/Layer~Layer} subclasses that support it.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @param {function(import("./tilecoord.js").TileCoord): import("./source/Source.js").default} factory Source factory.
 * This function takes a {@link module:ol/tilecoord~TileCoord} as argument and is expected to return a
 * {@link module:ol/source/Source~Source}. **Note**: The returned sources should have a tile grid with
 * a limited set of resolutions, matching the resolution range of a single zoom level of the pyramid
 * `tileGrid` that `sourcesFromTileGrid` was called with.
 * @return {function(import("./extent.js").Extent, number): Array<import("./source/Source.js").default>} Sources function.
 * @api
 */
declare function sourcesFromTileGrid(tileGrid: TileGrid, factory: (arg0: TileCoord) => Source): (arg0: Extent$1, arg1: number) => Array<Source>;

/**
 * *
 */
type VectorTileLayerOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<BaseLayerObjectEventTypes | LayerEventType | "change:preload" | "change:useInterimTilesOnError", ObjectEvent, Return> & OnSignature<LayerRenderEventTypes, RenderEvent, Return> & CombinedOnSignature<EventTypes | BaseLayerObjectEventTypes | LayerEventType | "change:preload" | "change:useInterimTilesOnError" | LayerRenderEventTypes, Return>;
type VectorTileRenderType = "hybrid" | "vector";
/**
 * *
 */
type ExtractedFeatureType$2<T> = T extends VectorTile<infer U extends FeatureLike> ? U : never;
type Options$w<VectorTileSourceType extends VectorTile<FeatureType> = VectorTile<any>, FeatureType extends FeatureLike = ExtractedFeatureType$2<VectorTileSourceType>> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Render order. Function to be used when sorting
     * features before rendering. By default features are drawn in the order that they are created. Use
     * `null` to avoid the sort, but get an undefined draw order.
     */
    renderOrder?: OrderFunction | undefined;
    /**
     * The buffer in pixels around the tile extent used by the
     * renderer when getting features from the vector tile for the rendering or hit-detection.
     * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
     * the largest possible buffer of the used tiles. It should be at least the size of the largest
     * point symbol or line width.
     */
    renderBuffer?: number | undefined;
    /**
     * Render mode for vector tiles:
     * * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
     * animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
     * rotated views, but get lifted above all polygon and line elements.
     * * `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use
     * this mode for improved performance and visual epxerience on vector tile layers with not too many
     * rendered features (e.g. for highlighting a subset of features of another layer with the same
     * source).
     */
    renderMode?: VectorTileRenderType | undefined;
    /**
     * Source.
     */
    source?: VectorTileSourceType | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use [map.addLayer()]{@link import ("../Map.js").default#addLayer}.
     */
    map?: Map | undefined;
    /**
     * Declutter images and text. Any truthy value will enable
     * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
     * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
     * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
     * layers or groups of layers separately, use different truthy values for `declutter`.
     */
    declutter?: string | number | boolean | undefined;
    /**
     * Layer style. When set to `null`, only
     * features that have their own style will be rendered. See {@link module :ol/style/Style~Style} for the default style
     * which will be used if this is not set.
     */
    style?: StyleLike | null | undefined;
    /**
     * Background color for the layer. If not specified, no
     * background will be rendered.
     */
    background?: BackgroundColor | undefined;
    /**
     * When set to `true`, feature batches will be
     * recreated during animations. This means that no vectors will be shown clipped, but the setting
     * will have a performance impact for large amounts of vector data. When set to `false`, batches
     * will be recreated when no animation is active.
     */
    updateWhileAnimating?: boolean | undefined;
    /**
     * When set to `true`, feature batches will be
     * recreated during interactions. See also `updateWhileAnimating`.
     */
    updateWhileInteracting?: boolean | undefined;
    /**
     * Preload. Load low-resolution tiles up to `preload` levels. `0`
     * means no preloading.
     */
    preload?: number | undefined;
    /**
     * Deprecated.  Use interim tiles on error.
     */
    useInterimTilesOnError?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
    /**
     * The internal tile cache size.  If too small, this will auto-grow to hold
     * two zoom levels worth of tiles.
     */
    cacheSize?: number | undefined;
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature
 */
/**
 * @typedef {'hybrid' | 'vector'} VectorTileRenderType
 */
/***
 * @template T
 * @typedef {T extends import("../source/VectorTile.js").default<infer U extends import("../Feature.js").FeatureLike> ? U : never} ExtractedFeatureType
 */
/**
 * @template {import("../source/VectorTile.js").default<FeatureType>} [VectorTileSourceType=import("../source/VectorTile.js").default<*>]
 * @template {import("../Feature").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views, but get lifted above all polygon and line elements.
 *  * `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use
 *    this mode for improved performance and visual epxerience on vector tile layers with not too many
 *    rendered features (e.g. for highlighting a subset of features of another layer with the same
 *    source).
 * @property {VectorTileSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable
 * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
 * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
 * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
 * layers or groups of layers separately, use different truthy values for `declutter`.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no
 * background will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 * @property {number} [cacheSize=0] The internal tile cache size.  If too small, this will auto-grow to hold
 * two zoom levels worth of tiles.
 */
/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/VectorTile.js").default<FeatureType>} [VectorTileSourceType=import("../source/VectorTile.js").default<*>]
 * @template {import("../Feature.js").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]
 * @extends {BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer>}
 * @api
 */
declare class VectorTileLayer<VectorTileSourceType extends VectorTile<FeatureType> = VectorTile<any>, FeatureType extends FeatureLike = ExtractedFeatureType$2<VectorTileSourceType>> extends BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer> {
    /**
     * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.
     */
    constructor(options?: Options$w<VectorTileSourceType, FeatureType>);
    /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */
    on: VectorTileLayerOnSignature<EventsKey>;
    /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */
    once: VectorTileLayerOnSignature<EventsKey>;
    /***
     * @type {VectorTileLayerOnSignature<void>}
     */
    un: VectorTileLayerOnSignature<void>;
    /**
     * @type {number|undefined}
     * @private
     */
    private cacheSize_;
    /**
     * @private
     * @type {VectorTileRenderType}
     */
    private renderMode_;
    /**
     * Get features whose bounding box intersects the provided extent. Only features for cached
     * tiles for the last rendered zoom level are available in the source. So this method is only
     * suitable for requesting tiles for extents that are currently rendered.
     *
     * Features are returned in random tile order and as they are included in the tiles. This means
     * they can be clipped, duplicated across tiles, and simplified to the render resolution.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesInExtent(extent: Extent$1): Array<FeatureType>;
    /**
     * @return {VectorTileRenderType} The render mode.
     */
    getRenderMode(): VectorTileRenderType;
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    getPreload(): number;
    /**
     * Deprecated.  Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    getUseInterimTilesOnError(): boolean;
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    setPreload(preload: number): void;
    /**
     * Deprecated.  Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    setUseInterimTilesOnError(useInterimTilesOnError: boolean): void;
}

/**
 * *
 */
type BaseTileLayerOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<BaseLayerObjectEventTypes | LayerEventType | "change:preload" | "change:useInterimTilesOnError", ObjectEvent, Return> & OnSignature<LayerRenderEventTypes, RenderEvent, Return> & CombinedOnSignature<EventTypes | BaseLayerObjectEventTypes | LayerEventType | "change:preload" | "change:useInterimTilesOnError" | LayerRenderEventTypes, Return>;
type Options$v<TileSourceType extends TileSource> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Preload. Load low-resolution tiles up to `preload` levels. `0`
     * means no preloading.
     */
    preload?: number | undefined;
    /**
     * Source for this layer.
     */
    source?: TileSourceType | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link import ("../Map.js").default#addLayer map.addLayer()}.
     */
    map?: Map | undefined;
    /**
     * Background color for the layer. If not specified, no background
     * will be rendered.
     */
    background?: BackgroundColor | undefined;
    /**
     * Deprecated.  Use interim tiles on error.
     */
    useInterimTilesOnError?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
    /**
     * The internal tile cache size.  This needs to be large enough to render
     * two zoom levels worth of tiles.
     */
    cacheSize?: number | undefined;
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */
/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render
 * two zoom levels worth of tiles.
 */
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */
declare class BaseTileLayer<TileSourceType extends TileSource, RendererType extends LayerRenderer<any>> extends Layer<TileSourceType, RendererType> {
    /**
     * @param {Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(options?: Options$v<TileSourceType>);
    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    on: BaseTileLayerOnSignature<EventsKey>;
    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    once: BaseTileLayerOnSignature<EventsKey>;
    /***
     * @type {BaseTileLayerOnSignature<void>}
     */
    un: BaseTileLayerOnSignature<void>;
    /**
     * @type {number|undefined}
     * @private
     */
    private cacheSize_;
    /**
     * @return {number|undefined} The suggested cache size
     * @protected
     */
    protected getCacheSize(): number | undefined;
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    getPreload(): number;
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    setPreload(preload: number): void;
    /**
     * Deprecated.  Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    getUseInterimTilesOnError(): boolean;
    /**
     * Deprecated.  Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    setUseInterimTilesOnError(useInterimTilesOnError: boolean): void;
}

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} [TileSourceType=import("../source/Tile.js").default]
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */
declare class TileLayer<TileSourceType extends TileSource = TileSource<Tile$1>> extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer<TileLayer<TileSource<Tile$1>> | VectorTileLayer<VectorTile<any>, any>>> {
    /**
     * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(options?: Options$v<TileSourceType>);
    /**
     * @override
     */
    override createRenderer(): CanvasTileLayerRenderer<this>;
}
//# sourceMappingURL=Tile.d.ts.map

type TileLookup = {
    [x: number]: Set<Tile$1>;
};
type Options$u = {
    /**
     * The cache size.
     */
    cacheSize?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=512] The cache size.
 */
/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */
declare class CanvasTileLayerRenderer<LayerType extends TileLayer | VectorTileLayer = TileLayer<TileSource<Tile$1>> | VectorTileLayer<VectorTile<any>, any>> extends CanvasLayerRenderer<LayerType> {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} [options] Options.
     */
    constructor(tileLayer: LayerType, options?: Options$u);
    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */
    extentChanged: boolean;
    /**
     * The last call to `renderFrame` was completed with all tiles loaded
     * @type {boolean}
     */
    renderComplete: boolean;
    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */
    private renderedExtent_;
    /**
     * @protected
     * @type {number}
     */
    protected renderedPixelRatio: number;
    /**
     * @protected
     * @type {import("../../proj/Projection.js").default|null}
     */
    protected renderedProjection: Projection | null;
    /**
     * @protected
     * @type {number}
     */
    protected renderedRevision: number;
    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    protected renderedTiles: Array<Tile$1>;
    /**
     * @private
     * @type {string}
     */
    private renderedSourceKey_;
    /**
     * @private
     * @type {number}
     */
    private renderedSourceRevision_;
    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    protected tempExtent: Extent$1;
    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    private tempTileRange_;
    /**
     * @type {import("../../tilecoord.js").TileCoord}
     * @private
     */
    private tempTileCoord_;
    /**
     * @type {import("../../structs/LRUCache.js").default<import("../../Tile.js").default>}
     * @private
     */
    private tileCache_;
    /**
     * @return {LRUCache} Tile cache.
     */
    getTileCache(): LRUCache<any>;
    /**
     * Get a tile from the cache or create one if needed.
     *
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    protected getOrCreateTile(z: number, x: number, y: number, frameState: FrameState): Tile$1 | null;
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    protected getTile(z: number, x: number, y: number, frameState: FrameState): Tile$1 | null;
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     * @override
     */
    override getData(pixel: Pixel): Uint8ClampedArray;
    renderedRevision_: any;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @param {number} preload Number of additional levels to load.
     */
    enqueueTiles(frameState: FrameState, extent: Extent$1, initialZ: number, tilesByZ: TileLookup, preload: number): void;
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    private findStaleTile_;
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    private findAltTiles_;
    /**
     * Render the layer.
     *
     * The frame rendering logic has three parts:
     *
     *  1. Enqueue tiles
     *  2. Find alt tiles for those that are not yet loaded
     *  3. Render loaded tiles
     *
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    override renderFrame(frameState: FrameState, target: HTMLElement): HTMLElement;
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     */
    updateCacheSize(tileCount: number): void;
    /**
     * @param {import("../../Tile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     * @protected
     */
    protected drawTile(tile: Tile$1, frameState: FrameState, x: number, y: number, w: number, h: number, gutter: number, transition: boolean): void;
    /**
     * @return {HTMLCanvasElement} Image
     */
    getImage(): HTMLCanvasElement;
    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */
    protected getTileImage(tile: ImageTile): HTMLCanvasElement | HTMLImageElement | HTMLVideoElement;
    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */
    protected updateUsedTiles(usedTiles: {
        [x: string]: {
            [x: string]: boolean;
        };
    }, tileSource: TileSource, tile: Tile$1): void;
}

/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 * @extends {CanvasTileLayerRenderer<import("../../layer/VectorTile.js").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}
 */
declare class CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer<VectorTileLayer<VectorTile<FeatureLike>, FeatureLike>> {
    /**
     * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
     * @param {import("./TileLayer.js").Options} options Options.
     */
    constructor(layer: VectorTileLayer, options: Options$u);
    /** @private */
    private boundHandleStyleImageChange_;
    /**
     * @private
     * @type {number}
     */
    private renderedLayerRevision_;
    /**
     * @private
     * @type {import("../../transform").Transform}
     */
    private renderedPixelToCoordinateTransform_;
    /**
     * @private
     * @type {number}
     */
    private renderedRotation_;
    /**
     * @private
     * @type {number}
     */
    private renderedOpacity_;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    private tmpTransform_;
    /**
     * @private
     * @type {Array<ZIndexContext>}
     */
    private tileClipContexts_;
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     * @override
     */
    override drawTile(tile: VectorRenderTile, frameState: FrameState, x: number, y: number, w: number, h: number, gutter: number, transition: boolean): void;
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../proj/Projection.js").default} projection Projection.
     * @private
     */
    private updateExecutorGroup_;
    /**
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {Array<import('../../Feature.js').FeatureLike>} Features.
     */
    getFeaturesInExtent(extent: Extent$1): Array<FeatureLike>;
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    private handleStyleImageChange_;
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../layer/Layer.js").State} layerState Layer state.
     */
    renderDeclutter(frameState: FrameState, layerState: State$1): void;
    /**
     * @param {import("../../VectorRenderTile.js").default} tile The tile
     * @param {import('../../Map.js').FrameState} frameState Current frame state
     * @return {import('../../transform.js').Transform} Transform to use to render this tile
     */
    getTileRenderTransform(tile: VectorRenderTile, frameState: FrameState): Transform;
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {boolean} [declutter] Enable decluttering.
     * @param {number} [index] Render order index.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(feature: FeatureLike, squaredTolerance: number, styles: Style$2 | Array<Style$2>, builderGroup: BuilderGroup, declutter?: boolean, index?: number): boolean;
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @return {boolean} A new tile image was rendered.
     * @private
     */
    private tileImageNeedsRender_;
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {import("../../Map").FrameState} frameState Frame state.
     * @private
     */
    private renderTileImage_;
}
//# sourceMappingURL=VectorTileLayer.d.ts.map

/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
declare class CanvasVectorLayerRenderer extends CanvasLayerRenderer<any> {
    /**
     * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
     */
    constructor(vectorLayer: BaseVectorLayer<any, any, any>);
    /** @private */
    private boundHandleStyleImageChange_;
    /**
     * @private
     * @type {boolean}
     */
    private animatingOrInteracting_;
    /**
     * @private
     * @type {ImageData|null}
     */
    private hitDetectionImageData_;
    /**
     * @private
     * @type {boolean}
     */
    private clipped_;
    /**
     * @private
     * @type {Array<import("../../Feature.js").default>}
     */
    private renderedFeatures_;
    /**
     * @private
     * @type {number}
     */
    private renderedRevision_;
    /**
     * @private
     * @type {number}
     */
    private renderedResolution_;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    private renderedExtent_;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    private wrappedRenderedExtent_;
    /**
     * @private
     * @type {number}
     */
    private renderedRotation_;
    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */
    private renderedCenter_;
    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */
    private renderedProjection_;
    /**
     * @private
     * @type {number}
     */
    private renderedPixelRatio_;
    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */
    private renderedRenderOrder_;
    /**
     * @private
     * @type {boolean}
     */
    private renderedFrameDeclutter_;
    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    private replayGroup_;
    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    replayGroupChanged: boolean;
    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */
    clipping: boolean;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    private targetContext_;
    /**
     * @private
     * @type {number}
     */
    private opacity_;
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} [declutterable] `true` to only render declutterable items,
     *     `false` to only render non-declutterable items, `undefined` to render all.
     */
    renderWorlds(executorGroup: ExecutorGroup, frameState: FrameState, declutterable?: boolean): void;
    /**
     * @private
     */
    private setDrawContext_;
    /**
     * @private
     */
    private resetDrawContext_;
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(frameState: FrameState): void;
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise
     * that resolves with an array of features.
     * @override
     */
    override getFeatures(pixel: Pixel): Promise<Array<Feature$2>>;
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    private handleStyleImageChange_;
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {boolean} [declutter] Enable decluttering.
     * @param {number} [index] Render order index.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(feature: Feature$2, squaredTolerance: number, styles: Style$2 | Array<Style$2>, builderGroup: BuilderGroup, transform?: TransformFunction, declutter?: boolean, index?: number): boolean;
}
//# sourceMappingURL=VectorLayer.d.ts.map

/**
 * *
 */
type ExtractedFeatureType$1<T> = T extends VectorSource<infer U extends FeatureLike> ? U : never;
type Options$t<FeatureType extends FeatureLike, VectorSourceType extends VectorSource<FeatureType> | VectorTile<FeatureType>> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Render order. Function to be used when sorting
     * features before rendering. By default features are drawn in the order that they are created. Use
     * `null` to avoid the sort, but get an undefined draw order.
     */
    renderOrder?: OrderFunction | undefined;
    /**
     * The buffer in pixels around the viewport extent used by the
     * renderer when getting features from the vector source for the rendering or hit-detection.
     * Recommended value: the size of the largest symbol, line width or label.
     */
    renderBuffer?: number | undefined;
    /**
     * Source.
     */
    source?: VectorSourceType | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use [map.addLayer()]{@link import ("../Map.js").default#addLayer}.
     */
    map?: Map | undefined;
    /**
     * Declutter images and text. Any truthy value will enable
     * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
     * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
     * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
     * layers or groups of layers separately, use different truthy values for `declutter`.
     */
    declutter?: string | number | boolean | undefined;
    /**
     * Layer style. When set to `null`, only
     * features that have their own style will be rendered. See {@link module :ol/style/Style~Style} for the default style
     * which will be used if this is not set.
     */
    style?: StyleLike | FlatStyleLike | null | undefined;
    /**
     * Background color for the layer. If not specified, no background
     * will be rendered.
     */
    background?: BackgroundColor | undefined;
    /**
     * When set to `true`, feature batches will
     * be recreated during animations. This means that no vectors will be shown clipped, but the
     * setting will have a performance impact for large amounts of vector data. When set to `false`,
     * batches will be recreated when no animation is active.
     */
    updateWhileAnimating?: boolean | undefined;
    /**
     * When set to `true`, feature batches will
     * be recreated during interactions. See also `updateWhileAnimating`.
     */
    updateWhileInteracting?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import('../Feature').FeatureLike} FeatureType
 * @template {import("../source/Vector.js").default<FeatureType>|import("../source/VectorTile.js").default<FeatureType>} VectorSourceType<FeatureType>
 * @extends {Layer<VectorSourceType, RendererType>}
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @api
 */
declare class BaseVectorLayer<FeatureType extends FeatureLike, VectorSourceType extends VectorSource<FeatureType> | VectorTile<FeatureType>, RendererType extends CanvasVectorLayerRenderer | CanvasVectorTileLayerRenderer | CanvasVectorImageLayerRenderer | WebGLPointsLayerRenderer> extends Layer<VectorSourceType, RendererType> {
    /**
     * @param {Options<FeatureType, VectorSourceType>} [options] Options.
     */
    constructor(options?: Options$t<FeatureType, VectorSourceType>);
    /**
     * @private
     * @type {string}
     */
    private declutter_;
    /**
     * @type {number}
     * @private
     */
    private renderBuffer_;
    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike}
     * @private
     */
    private style_;
    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */
    private styleFunction_;
    /**
     * @type {boolean}
     * @private
     */
    private updateWhileAnimating_;
    /**
     * @type {boolean}
     * @private
     */
    private updateWhileInteracting_;
    /**
     * @return {number|undefined} Render buffer.
     */
    getRenderBuffer(): number | undefined;
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */
    getRenderOrder(): (arg0: Feature$2, arg1: Feature$2) => number | null | undefined;
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
     * @api
     */
    getStyle(): StyleLike | FlatStyleLike | null | undefined;
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
    getStyleFunction(): StyleFunction | undefined;
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
    getUpdateWhileAnimating(): boolean;
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
    getUpdateWhileInteracting(): boolean;
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
    setRenderOrder(renderOrder: OrderFunction | null | undefined): void;
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
     * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
     * ```js
     * vectorLayer.setStyle({
     *   "fill-color": "yellow",
     *   "stroke-color": "black",
     *   "stroke-width": 4
     * })
     * ```
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */
    setStyle(style?: StyleLike | FlatStyleLike | null): void;
    /**
     * @param {boolean|string|number} declutter Declutter images and text.
     * @api
     */
    setDeclutter(declutter: boolean | string | number): void;
}

type Options$s<VectorSourceType extends VectorSource<FeatureType> = VectorSource<any>, FeatureType extends FeatureLike = ExtractedFeatureType$1<VectorSourceType>> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Render order. Function to be used when sorting
     * features before rendering. By default features are drawn in the order that they are created. Use
     * `null` to avoid the sort, but get an undefined draw order.
     */
    renderOrder?: OrderFunction | undefined;
    /**
     * The buffer in pixels around the viewport extent used by the
     * renderer when getting features from the vector source for the rendering or hit-detection.
     * Recommended value: the size of the largest symbol, line width or label.
     */
    renderBuffer?: number | undefined;
    /**
     * Source.
     */
    source?: VectorSourceType | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use [map.addLayer()]{@link import ("../Map.js").default#addLayer}.
     */
    map?: Map | undefined;
    /**
     * Declutter images and text. Any truthy value will enable
     * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
     * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
     * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
     * layers or groups of layers separately, use different truthy values for `declutter`.
     */
    declutter?: string | number | boolean | undefined;
    /**
     * Layer style. When set to `null`, only
     * features that have their own style will be rendered. See {@link module :ol/style/Style~Style} for the default style
     * which will be used if this is not set.
     */
    style?: StyleLike | FlatStyleLike | null | undefined;
    /**
     * Background color for the layer. If not specified, no background
     * will be rendered.
     */
    background?: BackgroundColor | undefined;
    /**
     * When set to `true`, feature batches will
     * be recreated during animations. This means that no vectors will be shown clipped, but the
     * setting will have a performance impact for large amounts of vector data. When set to `false`,
     * batches will be recreated when no animation is active.
     */
    updateWhileAnimating?: boolean | undefined;
    /**
     * When set to `true`, feature batches will
     * be recreated during interactions. See also `updateWhileAnimating`.
     */
    updateWhileInteracting?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("./BaseVector.js").ExtractedFeatureType<VectorSourceType>]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable
 * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
 * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
 * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
 * layers or groups of layers separately, use different truthy values for `declutter`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=import("./BaseVector.js").ExtractedFeatureType<VectorSourceType>]
 * @extends {BaseVectorLayer<FeatureType, VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */
declare class VectorLayer<VectorSourceType extends VectorSource<FeatureType> = VectorSource<any>, FeatureType extends FeatureLike = ExtractedFeatureType$1<VectorSourceType>> extends BaseVectorLayer<FeatureType, VectorSourceType, CanvasVectorLayerRenderer> {
    /**
     * @param {Options<VectorSourceType, FeatureType>} [options] Options.
     */
    constructor(options?: Options$s<VectorSourceType, FeatureType>);
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
declare class DrawEvent extends BaseEvent {
    /**
     * @param {DrawEventType} type Type.
     * @param {Feature} feature The feature drawn.
     */
    constructor(type: DrawEventType, feature: Feature$2);
    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */
    feature: Feature$2;
}

type Options$r = {
    /**
     * Geometry type of
     * the geometries being drawn with this instance.
     */
    type: Type$5;
    /**
     * The maximum distance in pixels between
     * "down" and "up" for a "up" event to be considered a "click" event and
     * actually add a point/vertex to the geometry being drawn.  The default of `6`
     * was chosen for the draw interaction to behave correctly on mouse as well as
     * on touch devices.
     */
    clickTolerance?: number | undefined;
    /**
     * Destination collection for the drawn features.
     */
    features?: Collection<Feature$2<Geometry$1>> | undefined;
    /**
     * Destination source for
     * the drawn features.
     */
    source?: VectorSource<Feature$2<Geometry$1>> | undefined;
    /**
     * Delay in milliseconds after pointerdown
     * before the current vertex can be dragged to its exact position.
     */
    dragVertexDelay?: number | undefined;
    /**
     * Pixel distance for snapping to the
     * drawing finish. Must be greater than `0`.
     */
    snapTolerance?: number | undefined;
    /**
     * Stop click, singleclick, and
     * doubleclick events from firing during drawing.
     */
    stopClick?: boolean | undefined;
    /**
     * The number of points that can be drawn before
     * a polygon ring or line string is finished. By default there is no
     * restriction.
     */
    maxPoints?: number | undefined;
    /**
     * The number of points that must be drawn
     * before a polygon ring or line string can be finished. Default is `3` for
     * polygon rings and `2` for line strings.
     */
    minPoints?: number | undefined;
    /**
     * A function
     * that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether the drawing can be finished. Not used when drawing
     * POINT or MULTI_POINT geometries.
     */
    finishCondition?: Condition | undefined;
    /**
     * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.
     * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.
     * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with
     * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.
     * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`
     * geometry that corresponds to the polygon between the already drawn points and the current cursor position
     * (note that this polygon has only two points if only one point is drawn).
     * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose
     * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.
     */
    style?: StyleLike | FlatStyleLike | undefined;
    /**
     * Function that is called when a geometry's coordinates are updated.
     */
    geometryFunction?: GeometryFunction | undefined;
    /**
     * Geometry name to use for features created
     * by the draw interaction.
     */
    geometryName?: string | undefined;
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * By default {@link module :ol/events/condition.noModifierKeys}, i.e. a click,
     * adds a vertex or deactivates freehand drawing.
     */
    condition?: Condition | undefined;
    /**
     * Operate in freehand mode for lines,
     * polygons, and circles.  This makes the interaction always operate in freehand
     * mode and takes precedence over any `freehandCondition` option.
     */
    freehand?: boolean | undefined;
    /**
     * Condition that activates freehand drawing for lines and polygons. This
     * function takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and
     * returns a boolean to indicate whether that event should be handled. The
     * default is {@link module :ol/events/condition.shiftKeyOnly}, meaning that the
     * Shift key activates freehand drawing.
     */
    freehandCondition?: Condition | undefined;
    /**
     * Trace a portion of another geometry.
     * Ignored when in freehand mode.
     */
    trace?: boolean | Condition | undefined;
    /**
     * Source for features to trace.  If tracing is active and a `traceSource` is
     * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
     * either a `traceSource` or a `source`.
     */
    traceSource?: VectorSource<Feature$2<Geometry$1>> | undefined;
    /**
     * Wrap the world horizontally on the sketch
     * overlay.
     */
    wrapX?: boolean | undefined;
    /**
     * Layout of the
     * feature geometries created by the draw interaction.
     */
    geometryLayout?: GeometryLayout | undefined;
};
/**
 * Coordinate type when drawing points.
 */
type PointCoordType = Coordinate;
/**
 * Coordinate type when drawing lines.
 */
type LineCoordType = Array<Coordinate>;
/**
 * Coordinate type when drawing polygons.
 */
type PolyCoordType = Array<Array<Coordinate>>;
/**
 * Types used for drawing coordinates.
 */
type SketchCoordType = PointCoordType | LineCoordType | PolyCoordType;
/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 */
type GeometryFunction = (arg0: SketchCoordType, arg1: SimpleGeometry, arg2: Projection) => SimpleGeometry;
/**
 * *
 */
type DrawOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"drawabort" | "drawend" | "drawstart", DrawEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "drawabort" | "drawend" | "drawstart", Return>;

type DrawEventType = string;
declare namespace DrawEventType {
    let DRAWSTART: string;
    let DRAWEND: string;
    let DRAWABORT: string;
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */
/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
declare class Draw extends PointerInteraction {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options$r);
    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    on: DrawOnSignature<EventsKey>;
    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    once: DrawOnSignature<EventsKey>;
    /***
     * @type {DrawOnSignature<void>}
     */
    un: DrawOnSignature<void>;
    /**
     * @type {boolean}
     * @private
     */
    private shouldHandle_;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    private downPx_;
    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    private downTimeout_;
    /**
     * @type {number|undefined}
     * @private
     */
    private lastDragTime_;
    /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */
    private pointerType_;
    /**
     * @type {boolean}
     * @private
     */
    private freehand_;
    /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */
    private source_;
    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */
    private features_;
    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    private snapTolerance_;
    /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */
    private type_;
    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */
    private mode_;
    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    private stopClick_;
    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    private minPoints_;
    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    private maxPoints_;
    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private finishCondition_;
    /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */
    private geometryLayout_;
    /**
     * @type {GeometryFunction}
     * @private
     */
    private geometryFunction_;
    /**
     * @type {number}
     * @private
     */
    private dragVertexDelay_;
    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private finishCoordinate_;
    /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */
    private sketchFeature_;
    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */
    private sketchPoint_;
    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */
    private sketchCoords_;
    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */
    private sketchLine_;
    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */
    private sketchLineCoords_;
    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    private squaredClickTolerance_;
    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    private overlay_;
    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    private geometryName_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private freehandCondition_;
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    private traceCondition_;
    /**
     * @type {TraceState}
     * @private
     */
    private traceState_;
    /**
     * @type {VectorSource|null}
     * @private
     */
    private traceSource_;
    /**
     * Toggle tracing mode or set a tracing condition.
     *
     * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
     *     condition that will be checked when a feature is clicked to determine if tracing should be active.
     */
    setTrace(trace: boolean | Condition): void;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    override setMap(map: Map): void;
    /**
     * Get the overlay layer that this interaction renders sketch features to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
    getOverlay(): VectorLayer;
    /**
     * @private
     */
    private deactivateTrace_;
    /**
     * Activate or deactivate trace state based on a browser event.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @private
     */
    private toggleTraceState_;
    /**
     * @param {TraceTarget} target The trace target.
     * @param {number} endIndex The new end index of the trace.
     * @private
     */
    private addOrRemoveTracedCoordinates_;
    /**
     * @param {number} fromIndex The start index.
     * @param {number} toIndex The end index.
     * @private
     */
    private removeTracedCoordinates_;
    /**
     * @param {TraceTarget} target The trace target.
     * @param {number} fromIndex The start index.
     * @param {number} toIndex The end index.
     * @private
     */
    private addTracedCoordinates_;
    /**
     * Update the trace.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @private
     */
    private updateTrace_;
    /**
     * Handle move events.
     * @param {import("../MapBrowserEvent.js").default} event A move event.
     * @private
     */
    private handlePointerMove_;
    /**
     * Determine if an event is within the snapping tolerance of the start coord.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
     * @return {boolean} The event is within the snapping tolerance of the start.
     * @private
     */
    private atFinish_;
    /**
     * @param {import("../coordinate").Coordinate} coordinates Coordinate.
     * @private
     */
    private createOrUpdateSketchPoint_;
    /**
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @private
     */
    private createOrUpdateCustomSketchLine_;
    /**
     * Start the drawing.
     * @param {import("../coordinate.js").Coordinate} start Start coordinate.
     * @private
     */
    private startDrawing_;
    /**
     * Modify the drawing.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @private
     */
    private modifyDrawing_;
    /**
     * Add a new coordinate to the drawing.
     * @param {!PointCoordType} coordinate Coordinate
     * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
     * @private
     */
    private addToDrawing_;
    /**
     * @param {number} n The number of points to remove.
     */
    removeLastPoints_(n: number): void;
    /**
     * Remove last point of the feature currently being drawn. Does not do anything when
     * drawing POINT or MULTI_POINT geometries.
     * @api
     */
    removeLastPoint(): void;
    /**
     * Stop drawing and add the sketch feature to the target layer.
     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
     * dispatched before inserting the feature.
     * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
     * @api
     */
    finishDrawing(): Feature$2<SimpleGeometry> | null;
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
     * @private
     */
    private abortDrawing_;
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @api
     */
    abortDrawing(): void;
    /**
     * Append coordinates to the end of the geometry that is currently being drawn.
     * This can be used when drawing LineStrings or Polygons. Coordinates will
     * either be appended to the current LineString or the outer ring of the current
     * Polygon. If no geometry is being drawn, a new one will be created.
     * @param {!LineCoordType} coordinates Linear coordinates to be appended to
     * the coordinate array.
     * @api
     */
    appendCoordinates(coordinates: LineCoordType): void;
    /**
     * Initiate draw mode by starting from an existing geometry which will
     * receive new additional points. This only works on features with
     * `LineString` geometries, where the interaction will extend lines by adding
     * points to the end of the coordinates array.
     * This will change the original feature, instead of drawing a copy.
     *
     * The function will dispatch a `drawstart` event.
     *
     * @param {!Feature<LineString>} feature Feature to be extended.
     * @api
     */
    extend(feature: Feature$2<LineString$1>): void;
    /**
     * Redraw the sketch features.
     * @private
     */
    private updateSketchFeatures_;
    /**
     * @private
     */
    private updateState_;
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
 * instances of this type.
 */
declare class ExtentEvent extends BaseEvent {
    /**
     * @param {import("../extent.js").Extent} extent the new extent
     */
    constructor(extent: Extent$1);
    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    extent: Extent$1;
}

type Options$q = {
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module :ol/events/condition.always}.
     */
    condition?: Condition | undefined;
    /**
     * Initial extent. Defaults to no
     * initial extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * Style for the drawn extent box. Defaults to the `Polygon` editing style
     * documented in {@link module :ol/style/Style~Style}
     */
    boxStyle?: StyleLike | undefined;
    /**
     * Pixel tolerance for considering the
     * pointer close enough to a segment or vertex for editing.
     */
    pixelTolerance?: number | undefined;
    /**
     * Style for the cursor used to draw the extent. Defaults to the `Point` editing style
     * documented in {@link module :ol/style/Style~Style}
     */
    pointerStyle?: StyleLike | undefined;
    /**
     * Wrap the drawn extent across multiple maps
     * in the X direction? Only affects visuals, not functionality.
     */
    wrapX?: boolean | undefined;
};
/**
 * *
 */
type ExtentOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"extentchanged", ExtentEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "extentchanged", Return>;

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'extentchanged', ExtentEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'extentchanged', Return>} ExtentOnSignature
 */
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires ExtentEvent
 * @api
 */
declare class Extent extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$q);
    /***
     * @type {ExtentOnSignature<import("../events").EventsKey>}
     */
    on: ExtentOnSignature<EventsKey>;
    /***
     * @type {ExtentOnSignature<import("../events").EventsKey>}
     */
    once: ExtentOnSignature<EventsKey>;
    /***
     * @type {ExtentOnSignature<void>}
     */
    un: ExtentOnSignature<void>;
    /**
     * Condition
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    private condition_;
    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */
    private extent_;
    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */
    private pointerHandler_;
    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */
    private pixelTolerance_;
    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */
    private snappedToVertex_;
    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */
    private extentFeature_;
    /**
     * Feature for displaying the visible pointer
     * @type {Feature<Point>}
     * @private
     */
    private vertexFeature_;
    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */
    private extentOverlay_;
    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */
    private vertexOverlay_;
    /**
     * @param {import("../pixel.js").Pixel} pixel cursor location
     * @param {import("../Map.js").default} map map
     * @return {import("../coordinate.js").Coordinate|null} snapped vertex on extent
     * @private
     */
    private snapToVertex_;
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
     * @private
     */
    private handlePointerMove_;
    /**
     * @param {import("../extent.js").Extent} extent extent
     * @return {Feature} extent as featrue
     * @private
     */
    private createOrUpdateExtentFeature_;
    /**
     * @param {import("../coordinate.js").Coordinate} vertex location of feature
     * @return {Feature} vertex as feature
     * @private
     */
    private createOrUpdatePointerFeature_;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    override setMap(map: Map): void;
    /**
     * Returns the current drawn extent in the view projection (or user projection if set)
     *
     * @return {import("../extent.js").Extent} Drawn extent in the view projection.
     * @api
     */
    getExtent(): Extent$1;
    /**
     * Returns the current drawn extent in the view projection
     *
     * @return {import("../extent.js").Extent} Drawn extent in the view projection.
     * @api
     */
    getExtentInternal(): Extent$1;
    /**
     * Manually sets the drawn extent, using the view projection.
     *
     * @param {import("../extent.js").Extent} extent Extent
     * @api
     */
    setExtent(extent: Extent$1): void;
}

type Options$p = {
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module :ol/events/condition.noModifierKeys} and
     * {@link module :ol/events/condition.targetNotEditable}.
     */
    condition?: Condition | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * The amount of pixels to pan on each key
     * press.
     */
    pixelDelta?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */
/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
declare class KeyboardPan extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$p);
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    private defaultCondition_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
    /**
     * @private
     * @type {number}
     */
    private pixelDelta_;
}

type Options$o = {
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. The default condition is
     * that {@link module :ol/events/condition.targetNotEditable} is fulfilled and that
     * the platform modifier key isn't pressed
     * (!{@link module :ol/events/condition.platformModifierKey}).
     */
    condition?: Condition | undefined;
    /**
     * The zoom level delta on each key press.
     */
    delta?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. The default condition is
 * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that
 * the platform modifier key isn't pressed
 * (!{@link module:ol/events/condition.platformModifierKey}).
 * @property {number} [delta=1] The zoom level delta on each key press.
 */
/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
declare class KeyboardZoom extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$o);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {number}
     */
    private delta_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
}

type Params = "x" | "y" | "z" | "r" | "l";
type Callback = (arg0: string) => void;
type Options$n = {
    /**
     * Animate view transitions.
     */
    animate?: boolean | AnimationOptions | undefined;
    /**
     * Properties to track. Default is to track
     * `x` (center x), `y` (center y), `z` (zoom), `r` (rotation) and `l` (layers).
     */
    params?: Params[] | undefined;
    /**
     * Replace the current URL without creating the new entry in browser history.
     * By default, changes in the map state result in a new entry being added to the browser history.
     */
    replace?: boolean | undefined;
    /**
     * By default, the URL will be updated with search parameters x, y, z, and r.  To
     * avoid collisions with existing search parameters that your application uses, you can supply a custom prefix for
     * the ones used by this interaction (e.g. 'ol:').
     */
    prefix?: string | undefined;
};
/** @typedef {'x'|'y'|'z'|'r'|'l'} Params */
/**
 * @typedef {function(string):void} Callback
 */
/**
 * @typedef {Object} Options
 * @property {boolean|import('../View.js').AnimationOptions} [animate=true] Animate view transitions.
 * @property {Array<Params>} [params=['x', 'y', 'z', 'r', 'l']] Properties to track. Default is to track
 * `x` (center x), `y` (center y), `z` (zoom), `r` (rotation) and `l` (layers).
 * @property {boolean} [replace=false] Replace the current URL without creating the new entry in browser history.
 * By default, changes in the map state result in a new entry being added to the browser history.
 * @property {string} [prefix=''] By default, the URL will be updated with search parameters x, y, z, and r.  To
 * avoid collisions with existing search parameters that your application uses, you can supply a custom prefix for
 * the ones used by this interaction (e.g. 'ol:').
 */
/**
 * @classdesc
 * An interaction that synchronizes the map state with the URL.
 *
 * @api
 */
declare class Link$1 extends Interaction {
    /**
     * @param {Options} [options] Link options.
     */
    constructor(options?: Options$n);
    /**
     * @type {import('../View.js').AnimationOptions|null}
     * @private
     */
    private animationOptions_;
    /**
     * @type {Object<Params, boolean>}
     * @private
     */
    private params_;
    /**
     * @private
     * @type {boolean}
     */
    private replace_;
    /**
     * @private
     * @type {string}
     */
    private prefix_;
    /**
     * @private
     * @type {!Array<import("../events.js").EventsKey>}
     */
    private listenerKeys_;
    /**
     * @private
     * @type {boolean}
     */
    private initial_;
    /**
     * @private
     */
    private updateState_;
    /**
     * The tracked parameter callbacks.
     * @private
     * @type {Object<string, Callback>}
     */
    private trackedCallbacks_;
    /**
     * The tracked parameter values.
     * @private
     * @type {Object<string, string|null>}
     */
    private trackedValues_;
    /**
     * @private
     * @param {string} name A parameter name.
     * @return {string} A name with the prefix applied.
     */
    private getParamName_;
    /**
     * @private
     * @param {URLSearchParams} params The search params.
     * @param {string} name The unprefixed parameter name.
     * @return {string|null} The parameter value.
     */
    private get_;
    /**
     * @private
     * @param {URLSearchParams} params The search params.
     * @param {string} name The unprefixed parameter name.
     * @param {string} value The param value.
     */
    private set_;
    /**
     * @private
     * @param {URLSearchParams} params The search params.
     * @param {string} name The unprefixed parameter name.
     */
    private delete_;
    /**
     * @param {import("../Map.js").default} map Map.
     * @private
     */
    private registerListeners_;
    /**
     * @param {import("../Map.js").default} map Map.
     * @private
     */
    private unregisterListeners_;
    /**
     * @private
     */
    private handleChangeLayerGroup_;
    /**
     * Register a listener for a URL search parameter.  The callback will be called with a new value
     * when the corresponding search parameter changes due to history events (e.g. browser navigation).
     *
     * @param {string} key The URL search parameter.
     * @param {Callback} callback The function to call when the search parameter changes.
     * @return {string|null} The initial value of the search parameter (or null if absent from the URL).
     * @api
     */
    track(key: string, callback: Callback): string | null;
    /**
     * Update the URL with a new search parameter value.  If the value is null, it will be
     * deleted from the search parameters.
     *
     * @param {string} key The URL search parameter.
     * @param {string|null} value The updated value (or null to remove it from the URL).
     * @api
     */
    update(key: string, value: string | null): void;
    /**
     * @private
     */
    private updateUrl_;
    /**
     * @private
     * @param {URL} url The URL.
     */
    private updateHistory_;
}

/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {Feature} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */
/**
 * @typedef {[SegmentData, number]} DragSegment
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have an `existing` property -
 * indicating whether there is an existing vertex underneath or not, a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
declare class ModifyEvent extends BaseEvent {
    /**
     * @param {ModifyEventType} type Type.
     * @param {Collection<Feature>} features
     * The features modified.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     */
    constructor(type: ModifyEventType, features: Collection<Feature$2>, mapBrowserEvent: MapBrowserEvent<any>);
    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */
    features: Collection<Feature$2>;
    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    mapBrowserEvent: MapBrowserEvent<any>;
}

type SegmentData = {
    /**
     * Depth.
     */
    depth?: number[] | undefined;
    /**
     * Feature.
     */
    feature: Feature$2;
    /**
     * Geometry.
     */
    geometry: SimpleGeometry;
    /**
     * Index.
     */
    index?: number | undefined;
    /**
     * Segment.
     */
    segment: Array<Array<number>>;
    /**
     * FeatureSegments.
     */
    featureSegments?: SegmentData[] | undefined;
};
type Options$m = {
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event will be considered to add or move a
     * vertex to the sketch. Default is
     * {@link module :ol/events/condition.primaryAction}.
     */
    condition?: Condition | undefined;
    /**
     * A function
     * that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. By default,
     * {@link module :ol/events/condition.singleClick} with
     * {@link module :ol/events/condition.altKeyOnly} results in a vertex deletion.
     */
    deleteCondition?: Condition | undefined;
    /**
     * A
     * function that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and
     * returns a boolean to indicate whether a new vertex should be added to the sketch
     * features. Default is {@link module :ol/events/condition.always}.
     */
    insertVertexCondition?: Condition | undefined;
    /**
     * Pixel tolerance for considering the
     * pointer close enough to a segment or vertex for editing.
     */
    pixelTolerance?: number | undefined;
    /**
     * Style used for the modification point or vertex. For linestrings and polygons, this will
     * be the affected vertex, for circles a point along the circle, and for points the actual
     * point. If not configured, the default edit style is used (see {@link module :ol/style/Style~Style}).
     * When using a style function, the point feature passed to the function will have an `existing` property -
     * indicating whether there is an existing vertex underneath or not, a `features`
     * property - an array whose entries are the features that are being modified, and a `geometries`
     * property - an array whose entries are the geometries that are being modified. Both arrays are
     * in the same order. The `geometries` are only useful when modifying geometry collections, where
     * the geometry will be the particular geometry from the collection that is being modified.
     */
    style?: StyleLike | FlatStyleLike | undefined;
    /**
     * The vector source with
     * features to modify.  If a vector source is not provided, a feature collection
     * must be provided with the `features` option.
     */
    source?: VectorSource<Feature$2<Geometry$1>> | undefined;
    /**
     * When configured, point
     * features will be considered for modification based on their visual appearance, instead of being within
     * the `pixelTolerance` from the pointer location. When a {@link module :ol/layer/BaseVector~BaseVectorLayer} is
     * provided, only the rendered representation of the features on that layer will be considered.
     */
    hitDetection?: boolean | BaseVectorLayer<any, any, any> | undefined;
    /**
     * The features the interaction works on.  If a feature collection is not
     * provided, a vector source must be provided with the `source` option.
     */
    features?: Collection<Feature$2<Geometry$1>> | undefined;
    /**
     * Wrap the world horizontally on the sketch
     * overlay.
     */
    wrapX?: boolean | undefined;
    /**
     * The vertex, point or segment being modified snaps to the
     * pointer coordinate when clicked within the `pixelTolerance`.
     */
    snapToPointer?: boolean | undefined;
};
/**
 * *
 */
type ModifyOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"modifyend" | "modifystart", ModifyEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "modifyend" | "modifystart", Return>;

type ModifyEventType = string;
declare namespace ModifyEventType {
    let MODIFYSTART: string;
    let MODIFYEND: string;
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */
/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
declare class Modify extends PointerInteraction {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options$m);
    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */
    on: ModifyOnSignature<EventsKey>;
    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */
    once: ModifyOnSignature<EventsKey>;
    /***
     * @type {ModifyOnSignature<void>}
     */
    un: ModifyOnSignature<void>;
    /** @private */
    private boundHandleFeatureChange_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    private defaultDeleteCondition_;
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    private deleteCondition_;
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    private insertVertexCondition_;
    /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */
    private vertexFeature_;
    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */
    private vertexSegments_;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    private lastPixel_;
    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */
    private ignoreNextSingleClick_;
    /**
     * @type {Collection<Feature>}
     * @private
     */
    private featuresBeingModified_;
    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */
    private rBush_;
    /**
     * @type {number}
     * @private
     */
    private pixelTolerance_;
    /**
     * @type {boolean}
     * @private
     */
    private snappedToVertex_;
    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */
    private changingFeature_;
    /**
     * @type {Array<DragSegment>}
     * @private
     */
    private dragSegments_;
    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    private overlay_;
    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */
    private SEGMENT_WRITERS_;
    /**
     * @type {VectorSource}
     * @private
     */
    private source_;
    /**
     * @type {boolean|import("../layer/BaseVector").default}
     * @private
     */
    private hitDetection_;
    /**
     * @type {Collection<Feature>}
     * @private
     */
    private features_;
    /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */
    private lastPointerEvent_;
    /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     * @private
     */
    private delta_;
    /**
     * @private
     */
    private snapToPointer_;
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    private addFeature_;
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
     * @param {Array<SegmentData>} segments The segments subject to modification.
     * @private
     */
    private willModifyFeatures_;
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    private removeFeature_;
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    private removeFeatureSegmentData_;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    override setMap(map: Map): void;
    /**
     * Get the overlay layer that this interaction renders the modification point or vertex to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
    getOverlay(): VectorLayer;
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceAdd_;
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceRemove_;
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    private handleFeatureAdd_;
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */
    private handleFeatureChange_;
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    private handleFeatureRemove_;
    /**
     * @param {Feature} feature Feature
     * @param {Point} geometry Geometry.
     * @private
     */
    private writePointGeometry_;
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */
    private writeMultiPointGeometry_;
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */
    private writeLineStringGeometry_;
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */
    private writeMultiLineStringGeometry_;
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */
    private writePolygonGeometry_;
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */
    private writeMultiPolygonGeometry_;
    /**
     * We convert a circle into two segments.  The segment at index
     * {@link CIRCLE_CENTER_INDEX} is the
     * circle's center (a point).  The segment at index
     * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
     * the circumference, and is not a line segment.
     *
     * @param {Feature} feature Feature.
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */
    private writeCircleGeometry_;
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */
    private writeGeometryCollectionGeometry_;
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {Array<Feature>} features The features being modified.
     * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
     * @param {boolean} existing The vertex represents an existing vertex.
     * @return {Feature} Vertex feature.
     * @private
     */
    private createOrUpdateVertexFeature_;
    findInsertVerticesAndUpdateDragSegments_(pixelCoordinate: any): SegmentData[] | undefined;
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @private
     */
    private handlePointerMove_;
    /**
     * @param {import("../coordinate.js").Coordinate} pixelCoordinate The pixel Coordinate.
     * @private
     */
    private handlePointerAtPixel_;
    /**
     * @param {SegmentData} segmentData Segment data.
     * @param {import("../coordinate.js").Coordinate} vertex Vertex.
     * @return {boolean} A vertex was inserted.
     * @private
     */
    private insertVertex_;
    updatePointer_(coordinate: any): Coordinate;
    /**
     * Get the current pointer position.
     * @return {import("../coordinate.js").Coordinate | null} The current pointer coordinate.
     */
    getPoint(): Coordinate | null;
    /**
     * Check if a point can be removed from the current linestring or polygon at the current
     * pointer position.
     * @return {boolean} A point can be deleted at the current pointer position.
     * @api
     */
    canRemovePoint(): boolean;
    /**
     * Removes the vertex currently being pointed from the current linestring or polygon.
     * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
     * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
     * @return {boolean} True when a vertex was removed.
     * @api
     */
    removePoint(coordinate?: Coordinate): boolean;
    /**
     * Removes a vertex from all matching features.
     * @return {boolean} True when a vertex was removed.
     * @private
     */
    private removeVertex_;
    /**
     * Check if a point can be inserted to the current linestring or polygon at the current
     * pointer position.
     * @return {boolean} A point can be inserted at the current pointer position.
     * @api
     */
    canInsertPoint(): boolean;
    /**
     * Inserts the vertex currently being pointed to the current linestring or polygon.
     * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
     * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
     * @return {boolean} A vertex was inserted.
     * @api
     */
    insertPoint(coordinate?: Coordinate): boolean;
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {Array} coordinates Coordinates.
     * @private
     */
    private setGeometryCoordinates_;
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} index Index.
     * @param {Array<number>|undefined} depth Depth.
     * @param {number} delta Delta (1 or -1).
     * @private
     */
    private updateSegmentIndices_;
}

type Options$l = {
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module :ol/events/condition.always}.
     */
    condition?: Condition | undefined;
    /**
     * When the map's target has a `tabindex` attribute set,
     * the interaction will only handle events when the map has the focus.
     */
    onFocusOnly?: boolean | undefined;
    /**
     * Maximum mouse wheel delta.
     */
    maxDelta?: number | undefined;
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
    /**
     * Mouse wheel timeout duration in milliseconds.
     */
    timeout?: number | undefined;
    /**
     * Enable zooming using the mouse's
     * location as the anchor. When set to `false`, zooming in and out will zoom to
     * the center of the screen instead of zooming on the mouse's location.
     */
    useAnchor?: boolean | undefined;
    /**
     * If true, the mouse wheel zoom
     * event will always animate to the closest zoom level after an interaction;
     * false means intermediary zoom levels are allowed.
     */
    constrainResolution?: boolean | undefined;
};
/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
declare class MouseWheelZoom extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$l);
    /**
     * @private
     * @type {number}
     */
    private totalDelta_;
    /**
     * @private
     * @type {number}
     */
    private lastDelta_;
    /**
     * @private
     * @type {number}
     */
    private maxDelta_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
    /**
     * @private
     * @type {number}
     */
    private timeout_;
    /**
     * @private
     * @type {boolean}
     */
    private useAnchor_;
    /**
     * @private
     * @type {boolean}
     */
    private constrainResolution_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {?import("../pixel.js").Pixel}
     */
    private lastAnchor_;
    /**
     * @private
     * @type {number|undefined}
     */
    private startTime_;
    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    private timeoutId_;
    /**
     * @private
     * @type {Mode|undefined}
     */
    private mode_;
    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @private
     * @type {number}
     */
    private trackpadEventGap_;
    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    private trackpadTimeoutId_;
    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    private deltaPerZoom_;
    /**
     * @private
     */
    private endInteraction_;
    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */
    private handleWheelZoom_;
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
    setMouseAnchor(useAnchor: boolean): void;
}

type Options$k = {
    /**
     * The duration of the animation in
     * milliseconds.
     */
    duration?: number | undefined;
    /**
     * Minimal angle in radians to start a rotation.
     */
    threshold?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */
/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
declare class PinchRotate extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$k);
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    private anchor_;
    /**
     * @private
     * @type {number|undefined}
     */
    private lastAngle_;
    /**
     * @private
     * @type {boolean}
     */
    private rotating_;
    /**
     * @private
     * @type {number}
     */
    private rotationDelta_;
    /**
     * @private
     * @type {number}
     */
    private threshold_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
}

type Options$j = {
    /**
     * Animation duration in milliseconds.
     */
    duration?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
declare class PinchZoom extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$j);
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    private anchor_;
    /**
     * @private
     * @type {number}
     */
    private duration_;
    /**
     * @private
     * @type {number|undefined}
     */
    private lastDistance_;
    /**
     * @private
     * @type {number}
     */
    private lastScaleDelta_;
}

/**
 * A function that takes a {@link module:ol/Feature~Feature} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").default, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike|null} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply
 * any style changes for selected features.
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {Collection<Feature>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes a {@link module:ol/Feature~Feature} and a
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */
declare class SelectEvent extends BaseEvent {
    /**
     * @param {SelectEventType} type The event type.
     * @param {Array<import("../Feature.js").default>} selected Selected features.
     * @param {Array<import("../Feature.js").default>} deselected Deselected features.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
     *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     */
    constructor(type: SelectEventType, selected: Array<Feature$2>, deselected: Array<Feature$2>, mapBrowserEvent: MapBrowserEvent<any>);
    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    selected: Array<Feature$2>;
    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    deselected: Array<Feature$2>;
    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    mapBrowserEvent: MapBrowserEvent<any>;
}

/**
 * A function that takes a {@link module :ol/Feature~Feature} and returns `true` if the feature may be
 * selected or `false` otherwise.
 */
type FilterFunction$1 = (arg0: Feature$2, arg1: Layer<Source>) => boolean;
type Options$i = {
    /**
     * A function
     * that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * By default, this is {@link module :ol/events/condition.never}. Use this if you
     * want to use different events for add and remove instead of `toggle`.
     */
    addCondition?: Condition | undefined;
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. This is the event
     * for the selected features as a whole. By default, this is
     * {@link module :ol/events/condition.singleClick}. Clicking on a feature selects that
     * feature and removes any that were in the selection. Clicking outside any
     * feature removes all from the selection.
     * See `toggle`, `add`, `remove` options for adding/removing extra features to/
     * from the selection.
     */
    condition?: Condition | undefined;
    /**
     * A list of layers from which features should be selected. Alternatively, a
     * filter function can be provided. The function will be called for each layer
     * in the map and should return `true` for layers that you want to be
     * selectable. If the option is absent, all visible layers will be considered
     * selectable.
     */
    layers?: Layer<Source, LayerRenderer<any>>[] | ((arg0: Layer<Source>) => boolean) | undefined;
    /**
     * Style for the selected features. By default the default edit style is used
     * (see {@link module :ol/style/Style~Style}). Set to `null` if this interaction should not apply
     * any style changes for selected features.
     * If set to a falsey value, the selected feature's style will not change.
     */
    style?: StyleLike | null | undefined;
    /**
     * A function
     * that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * By default, this is {@link module :ol/events/condition.never}. Use this if you
     * want to use different events for add and remove instead of `toggle`.
     */
    removeCondition?: Condition | undefined;
    /**
     * A function
     * that takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. This is in addition
     * to the `condition` event. By default,
     * {@link module :ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as
     * well as the `condition` event, adds that feature to the current selection if
     * it is not currently selected, and removes it if it is. See `add` and `remove`
     * if you want to use different events instead of a toggle.
     */
    toggleCondition?: Condition | undefined;
    /**
     * A boolean that determines if the default
     * behaviour should select only single features or all (overlapping) features at
     * the clicked map position. The default of `false` means single select.
     */
    multi?: boolean | undefined;
    /**
     * Collection where the interaction will place selected features. Optional. If
     * not set the interaction will create a collection. In any case the collection
     * used by the interaction is returned by
     * {@link module :ol/interaction/Select~Select#getFeatures}.
     */
    features?: Collection<Feature$2<Geometry$1>> | undefined;
    /**
     * A function
     * that takes a {@link module :ol/Feature~Feature} and a
     * {@link module :ol/layer/Layer~Layer} and returns `true` if the feature may be
     * selected or `false` otherwise.
     */
    filter?: FilterFunction$1 | undefined;
    /**
     * Hit-detection tolerance. Pixels inside
     * the radius around the given position will be checked for features.
     */
    hitTolerance?: number | undefined;
};
/**
 * *
 */
type SelectOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"select", SelectEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "select", Return>;

type SelectEventType = string;
declare namespace SelectEventType {
    let SELECT: string;
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'select', SelectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'select', Return>} SelectOnSignature
 */
/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * @fires SelectEvent
 * @api
 */
declare class Select extends Interaction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$i);
    /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */
    on: SelectOnSignature<EventsKey>;
    /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */
    once: SelectOnSignature<EventsKey>;
    /***
     * @type {SelectOnSignature<void>}
     */
    un: SelectOnSignature<void>;
    /**
     * @private
     */
    private boundAddFeature_;
    /**
     * @private
     */
    private boundRemoveFeature_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private addCondition_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private removeCondition_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private toggleCondition_;
    /**
     * @private
     * @type {boolean}
     */
    private multi_;
    /**
     * @private
     * @type {FilterFunction}
     */
    private filter_;
    /**
     * @private
     * @type {number}
     */
    private hitTolerance_;
    /**
     * @private
     * @type {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */
    private style_;
    /**
     * @private
     * @type {Collection<Feature>}
     */
    private features_;
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */
    private layerFilter_;
    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */
    private featureLayerAssociation_;
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @private
     */
    private addFeatureLayerAssociation_;
    /**
     * Get the selected features.
     * @return {Collection<Feature>} Features collection.
     * @api
     */
    getFeatures(): Collection<Feature$2>;
    /**
     * Returns the Hit-detection tolerance.
     * @return {number} Hit tolerance in pixels.
     * @api
     */
    getHitTolerance(): number;
    /**
     * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
     * a selected feature.
     * @param {import("../Feature.js").default} feature Feature
     * @return {import('../layer/Vector.js').default} Layer.
     * @api
     */
    getLayer(feature: Feature$2): VectorLayer;
    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @api
     */
    setHitTolerance(hitTolerance: number): void;
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    private addFeature_;
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    private removeFeature_;
    /**
     * @return {import("../style/Style.js").StyleLike|null} Select style.
     */
    getStyle(): StyleLike | null;
    /**
     * @param {Feature} feature Feature
     * @private
     */
    private applySelectedStyle_;
    /**
     * @param {Feature} feature Feature
     * @private
     */
    private restorePreviousStyle_;
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    private removeFeatureLayerAssociation_;
}

type Result = {
    /**
     * Vertex.
     */
    vertex: Coordinate | null;
    /**
     * VertexPixel.
     */
    vertexPixel: Pixel | null;
    /**
     * Feature.
     */
    feature: Feature$2 | null;
    /**
     * Segment, or `null` if snapped to a vertex.
     */
    segment: Array<Coordinate> | null;
};
type Options$h = {
    /**
     * Snap to these features. Either this option or source should be provided.
     */
    features?: Collection<Feature$2<Geometry$1>> | undefined;
    /**
     * Snap to edges.
     */
    edge?: boolean | undefined;
    /**
     * Snap to vertices.
     */
    vertex?: boolean | undefined;
    /**
     * Pixel tolerance for considering the pointer close enough to a segment or
     * vertex for snapping.
     */
    pixelTolerance?: number | undefined;
    /**
     * Snap to features from this source. Either this option or features should be provided
     */
    source?: VectorSource<Feature$2<Geometry$1>> | undefined;
};
/**
 * *
 */
type SnapOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"snap", SnapEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "snap", Return>;
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'snap', SnapEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'snap', Return>} SnapOnSignature
 */
/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that uses them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap.js';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @fires SnapEvent
 * @api
 */
declare class Snap extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$h);
    /***
     * @type {SnapOnSignature<import("../events").EventsKey>}
     */
    on: SnapOnSignature<EventsKey>;
    /***
     * @type {SnapOnSignature<import("../events").EventsKey>}
     */
    once: SnapOnSignature<EventsKey>;
    /***
     * @type {SnapOnSignature<void>}
     */
    un: SnapOnSignature<void>;
    /**
     * @type {import("../source/Vector.js").default|null}
     * @private
     */
    private source_;
    /**
     * @private
     * @type {boolean}
     */
    private vertex_;
    /**
     * @private
     * @type {boolean}
     */
    private edge_;
    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>|null}
     * @private
     */
    private features_;
    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */
    private featuresListenerKeys_;
    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */
    private featureChangeListenerKeys_;
    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */
    private indexedFeaturesExtents_;
    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */
    private pendingFeatures_;
    /**
     * @type {number}
     * @private
     */
    private pixelTolerance_;
    /**
     * Segment RTree for each layer
     * @type {import("../structs/RBush.js").default<SegmentData>}
     * @private
     */
    private rBush_;
    /**
     * @const
     * @private
     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import("../geom/Geometry.js").default): void>}
     */
    private GEOMETRY_SEGMENTERS_;
    /**
     * Add a feature to the collection of features that we may snap to.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {boolean} [register] Whether to listen to the feature change or not
     *     Defaults to `true`.
     * @api
     */
    addFeature(feature: Feature$2, register?: boolean): void;
    /**
     * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
     * @private
     */
    private getFeatures_;
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
     * @private
     */
    private handleFeatureAdd_;
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
     * @private
     */
    private handleFeatureRemove_;
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */
    private handleFeatureChange_;
    /**
     * Remove a feature from the collection of features that we may snap to.
     * @param {import("../Feature.js").default} feature Feature
     * @param {boolean} [unlisten] Whether to unlisten to the feature change
     *     or not. Defaults to `true`.
     * @api
     */
    removeFeature(feature: Feature$2, unlisten?: boolean): void;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    override setMap(map: Map): void;
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel
     * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
     * @param {import("../Map.js").default} map Map.
     * @return {Result|null} Snap result
     */
    snapTo(pixel: Pixel, pixelCoordinate: Coordinate, map: Map): Result | null;
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @private
     */
    private updateFeature_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */
    private segmentCircleGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */
    private segmentGeometryCollectionGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */
    private segmentLineStringGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */
    private segmentMultiLineStringGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */
    private segmentMultiPointGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */
    private segmentMultiPolygonGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/Point.js").default} geometry Geometry.
     * @private
     */
    private segmentPointGeometry_;
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */
    private segmentPolygonGeometry_;
}

/**
 * A function that takes a {@link module:ol/Feature~Feature} or
 * {@link module:ol/render/Feature~RenderFeature} and a
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @typedef {function(Feature, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.always}.
 * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * Not used if `features` is provided.
 * @property {FilterFunction} [filter] A function
 * that takes a {@link module:ol/Feature~Feature} and an
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise. Not used if `features` is provided.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features.
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */
declare class TranslateEvent extends BaseEvent {
    /**
     * @param {TranslateEventType} type Type.
     * @param {Collection<Feature>} features The features translated.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     */
    constructor(type: TranslateEventType, features: Collection<Feature$2>, coordinate: Coordinate, startCoordinate: Coordinate, mapBrowserEvent: MapBrowserEvent<any>);
    /**
     * The features being translated.
     * @type {Collection<Feature>}
     * @api
     */
    features: Collection<Feature$2>;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    coordinate: Coordinate;
    /**
     * The coordinate of the start position before translation started.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    startCoordinate: Coordinate;
    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    mapBrowserEvent: MapBrowserEvent<any>;
}

/**
 * A function that takes a {@link module :ol/Feature~Feature} or
 * {@link module :ol/render/Feature~RenderFeature} and a
 * {@link module :ol/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 */
type FilterFunction = (arg0: Feature$2, arg1: Layer<Source>) => boolean;
type Options$g = {
    /**
     * A function that
     * takes a {@link module :ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module :ol/events/condition.always}.
     */
    condition?: Condition | undefined;
    /**
     * Features contained in this collection will be able to be translated together.
     */
    features?: Collection<Feature$2<Geometry$1>> | undefined;
    /**
     * A list of layers from which features should be
     * translated. Alternatively, a filter function can be provided. The
     * function will be called for each layer in the map and should return
     * `true` for layers that you want to be translatable. If the option is
     * absent, all visible layers will be considered translatable.
     * Not used if `features` is provided.
     */
    layers?: Layer<Source, LayerRenderer<any>>[] | ((arg0: Layer<Source>) => boolean) | undefined;
    /**
     * A function
     * that takes a {@link module :ol/Feature~Feature} and an
     * {@link module :ol/layer/Layer~Layer} and returns `true` if the feature may be
     * translated or `false` otherwise. Not used if `features` is provided.
     */
    filter?: FilterFunction | undefined;
    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features.
     */
    hitTolerance?: number | undefined;
};
/**
 * *
 */
type TranslateOnSignature<Return> = OnSignature<EventTypes, BaseEvent, Return> & OnSignature<Types$2 | "change:active", ObjectEvent, Return> & OnSignature<"translateend" | "translatestart" | "translating", TranslateEvent, Return> & CombinedOnSignature<EventTypes | Types$2 | "change:active" | "translateend" | "translatestart" | "translating", Return>;

type TranslateEventType = string;
declare namespace TranslateEventType {
    let TRANSLATESTART: string;
    let TRANSLATING: string;
    let TRANSLATEEND: string;
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature
 */
/**
 * @classdesc
 * Interaction for translating (moving) features.
 * If you want to translate multiple features in a single action (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.
 *
 * @fires TranslateEvent
 * @api
 */
declare class Translate extends PointerInteraction {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$g);
    /***
     * @type {TranslateOnSignature<import("../events").EventsKey>}
     */
    on: TranslateOnSignature<EventsKey>;
    /***
     * @type {TranslateOnSignature<import("../events").EventsKey>}
     */
    once: TranslateOnSignature<EventsKey>;
    /***
     * @type {TranslateOnSignature<void>}
     */
    un: TranslateOnSignature<void>;
    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private lastCoordinate_;
    /**
     * The start position before translation started.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private startCoordinate_;
    /**
     * @type {Collection<Feature>|null}
     * @private
     */
    private features_;
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */
    private layerFilter_;
    /**
     * @private
     * @type {FilterFunction}
     */
    private filter_;
    /**
     * @private
     * @type {number}
     */
    private hitTolerance_;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    private condition_;
    /**
     * @type {Feature}
     * @private
     */
    private lastFeature_;
    /**
     * Tests to see if the given coordinates intersects any of our selected
     * features.
     * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
     * @param {import("../Map.js").default} map Map to test the intersection on.
     * @return {Feature} Returns the feature found at the specified pixel
     * coordinates.
     * @private
     */
    private featuresAtPixel_;
    /**
     * Returns the Hit-detection tolerance.
     * @return {number} Hit tolerance in pixels.
     * @api
     */
    getHitTolerance(): number;
    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @api
     */
    setHitTolerance(hitTolerance: number): void;
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    override setMap(map: Map): void;
    /**
     * @private
     */
    private handleActiveChanged_;
    /**
     * @param {import("../Map.js").default} oldMap Old map.
     * @private
     */
    private updateState_;
}

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */
/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
declare function defaults(options?: DefaultsOptions): Collection<Interaction>;
type DefaultsOptions = {
    /**
     * Whether Alt-Shift-drag rotate is
     * desired.
     */
    altShiftDragRotate?: boolean | undefined;
    /**
     * Interact only when the map has the
     * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
     * useful when page scroll is desired for maps that do not have the browser's
     * focus.
     */
    onFocusOnly?: boolean | undefined;
    /**
     * Whether double click zoom is
     * desired.
     */
    doubleClickZoom?: boolean | undefined;
    /**
     * Whether keyboard interaction is desired.
     */
    keyboard?: boolean | undefined;
    /**
     * Whether mousewheel zoom is desired.
     */
    mouseWheelZoom?: boolean | undefined;
    /**
     * Whether Shift-drag zoom is desired.
     */
    shiftDragZoom?: boolean | undefined;
    /**
     * Whether drag pan is desired.
     */
    dragPan?: boolean | undefined;
    /**
     * Whether pinch rotate is desired.
     */
    pinchRotate?: boolean | undefined;
    /**
     * Whether pinch zoom is desired.
     */
    pinchZoom?: boolean | undefined;
    /**
     * Zoom level delta when using keyboard or double click zoom.
     */
    zoomDelta?: number | undefined;
    /**
     * Duration of the zoom animation in
     * milliseconds.
     */
    zoomDuration?: number | undefined;
};

type SourceType$1 = DataTileSource<DataTile | ImageTile>;
/**
 * Translates tile data to rendered pixels.
 */
type Style$1 = {
    /**
     * Style variables.  Each variable must hold a number or string.  These
     * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`
     * {@link import ("../expr/expression.js").ExpressionValue expressions}, using the `['var', 'varName']` operator.
     * To update style variables, use the {@link import ("./WebGLTile.js").default#updateStyleVariables} method.
     */
    variables?: {
        [x: string]: string | number;
    } | undefined;
    /**
     * An expression applied to color values.
     */
    color?: ExpressionValue$1 | undefined;
    /**
     * Value used to decrease or increase
     * the layer brightness.  Values range from -1 to 1.
     */
    brightness?: ExpressionValue$1 | undefined;
    /**
     * Value used to decrease or increase
     * the layer contrast.  Values range from -1 to 1.
     */
    contrast?: ExpressionValue$1 | undefined;
    /**
     * Value used to decrease or increase
     * the layer exposure.  Values range from -1 to 1.
     */
    exposure?: ExpressionValue$1 | undefined;
    /**
     * Value used to decrease or increase
     * the layer saturation.  Values range from -1 to 1.
     */
    saturation?: ExpressionValue$1 | undefined;
    /**
     * Apply a gamma correction to the layer.
     * Values range from 0 to infinity.
     */
    gamma?: ExpressionValue$1 | undefined;
};
type Options$f = {
    /**
     * Style to apply to the layer.
     */
    style?: Style$1 | undefined;
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Preload. Load low-resolution tiles up to `preload` levels. `0`
     * means no preloading.
     */
    preload?: number | undefined;
    /**
     * Source for this layer.
     */
    source?: DataTileSource<DataTile | ImageTile> | undefined;
    /**
     * Array
     * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that
     * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See
     * {@link module :ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a
     * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.
     */
    sources?: DataTileSource<DataTile | ImageTile>[] | ((arg0: Extent$1, arg1: number) => Array<SourceType$1>) | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module :ol/Map~Map#addLayer}.
     */
    map?: Map | undefined;
    /**
     * Deprecated.  Use interim tiles on error.
     */
    useInterimTilesOnError?: boolean | undefined;
    /**
     * The internal texture cache size.  This needs to be large enough to render
     * two zoom levels worth of tiles.
     */
    cacheSize?: number | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @api
 */
declare class WebGLTileLayer extends BaseTileLayer<DataTileSource<DataTile | ImageTile>, WebGLTileLayerRenderer<any>> {
    /**
     * @param {Options} options Tile layer options.
     */
    constructor(options: Options$f);
    /**
     * @type {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>}
     * @private
     */
    private sources_;
    /**
     * @type {SourceType|null}
     * @private
     */
    private renderedSource_;
    /**
     * @type {number}
     * @private
     */
    private renderedResolution_;
    /**
     * @type {Style}
     * @private
     */
    private style_;
    /**
     * @type {Object<string, (string|number)>}
     * @private
     */
    private styleVariables_;
    /**
     * Gets the sources for this layer, for a given extent and resolution.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<SourceType>} Sources.
     */
    getSources(extent: Extent$1, resolution: number): Array<SourceType$1>;
    /**
     * @return {SourceType} The source being rendered.
     * @override
     */
    override getRenderSource(): SourceType$1;
    /**
     * @private
     */
    private handleSourceUpdate_;
    /**
     * @private
     * @return {number} The number of source bands.
     */
    private getSourceBandCount_;
    /**
     * @override
     */
    override createRenderer(): WebGLTileLayerRenderer<this>;
    /**
     * @param {import("../Map").FrameState} frameState Frame state.
     * @param {Array<SourceType>} sources Sources.
     * @return {HTMLElement} Canvas.
     */
    renderSources(frameState: FrameState, sources: Array<SourceType$1>): HTMLElement;
    /**
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    override render(frameState: FrameState | null, target: HTMLElement): HTMLElement;
    /**
     * Update the layer style.  The `updateStyleVariables` function is a more efficient
     * way to update layer rendering.  In cases where the whole style needs to be updated,
     * this method may be called instead.  Note that calling this method will also replace
     * any previously set variables, so the new style also needs to include new variables,
     * if needed.
     * @param {Style} style The new style.
     */
    setStyle(style: Style$1): void;
    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     * @api
     */
    updateStyleVariables(variables: {
        [x: string]: number;
    }): void;
}

type BaseTileType = Tile$1;
type TileRepresentationOptions<TileType extends BaseTileType> = {
    /**
     * The tile.
     */
    tile: TileType;
    /**
     * Tile grid.
     */
    grid: TileGrid;
    /**
     * WebGL helper.
     */
    helper: WebGLHelper;
    /**
     * The size in pixels of the gutter around image tiles to ignore.
     */
    gutter?: number | undefined;
};
/**
 * @typedef {import("../Tile.js").default} BaseTileType
 */
/**
 * @template {BaseTileType} TileType
 * @typedef {Object} TileRepresentationOptions
 * @property {TileType} tile The tile.
 * @property {import("../tilegrid/TileGrid.js").default} grid Tile grid.
 * @property {import("../webgl/Helper.js").default} helper WebGL helper.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 */
/**
 * @classdesc
 * Base class for representing a tile in a webgl context
 * @template {import("../Tile.js").default} TileType
 * @abstract
 */
declare class BaseTileRepresentation<TileType extends Tile$1> extends Target {
    /**
     * @param {TileRepresentationOptions<TileType>} options The tile representation options.
     */
    constructor(options: TileRepresentationOptions<TileType>);
    /**
     * @type {TileType}
     */
    tile: TileType;
    handleTileChange_(): void;
    /**
     * @type {number}
     * @protected
     */
    protected gutter: number;
    /**
     * @type {import("../webgl/Helper.js").default}
     * @protected
     */
    protected helper: WebGLHelper;
    loaded: boolean;
    ready: boolean;
    /**
     * @param {TileType} tile Tile.
     */
    setTile(tile: TileType): void;
    /**
     * @abstract
     * @protected
     */
    protected uploadTile(): void;
    setReady(): void;
    /**
     * @param {import("./Helper.js").default} helper The WebGL helper.
     */
    setHelper(helper: WebGLHelper): void;
}

type TileType$1 = DataTile | ImageTile | ReprojTile;
/**
 * @typedef {import("../DataTile.js").default|ImageTile|ReprojTile} TileType
 */
/**
 * @extends {BaseTileRepresentation<TileType>}
 */
declare class TileTexture extends BaseTileRepresentation<TileType$1> {
    /**
     * @param {import("./BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options The tile texture options.
     */
    constructor(options: TileRepresentationOptions<TileType$1>);
    /**
     * @type {Array<WebGLTexture>}
     */
    textures: Array<WebGLTexture>;
    /**
     * @type {import("../size.js").Size}
     * @private
     */
    private renderSize_;
    /**
     * @type {number}
     */
    bandCount: number;
    /**
     * @type {WebGLArrayBuffer}
     */
    coords: WebGLArrayBuffer;
    /**
     * @param {import("../DataTile.js").ImageLike} image The image.
     * @param {number} renderCol The column index (in rendered tile space).
     * @param {number} renderRow The row index (in rendered tile space).
     * @return {Uint8ClampedArray|null} The data.
     * @private
     */
    private getImagePixelData_;
    /**
     * @param {import("../DataTile.js").ArrayLike} data The data.
     * @param {import("../size.js").Size} sourceSize The size.
     * @param {number} renderCol The column index (in rendered tile space).
     * @param {number} renderRow The row index (in rendered tile space).
     * @return {import("../DataTile.js").ArrayLike|null} The data.
     * @private
     */
    private getArrayPixelData_;
    /**
     * Get data for a pixel.  If the tile is not loaded, null is returned.
     * @param {number} renderCol The column index (in rendered tile space).
     * @param {number} renderRow The row index (in rendered tile space).
     * @return {import("../DataTile.js").ArrayLike|null} The data.
     */
    getPixelData(renderCol: number, renderRow: number): ArrayLike | null;
}

type TileRepresentationLookup = {
    /**
     * The set of tile ids in the lookup.
     */
    tileIds: Set<string>;
    /**
     * Tile representations by zoom level.
     */
    representationsByZ: {
        [x: number]: Set<BaseTileRepresentation<Tile$1>>;
    };
};
type Options$e = {
    /**
     * Additional uniforms
     * made available to shaders.
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
    /**
     * The tile representation cache size.
     */
    cacheSize?: number | undefined;
    /**
     * Post-processes definitions.
     */
    postProcesses?: PostProcessesOptions[] | undefined;
};
type BaseLayerType = BaseTileLayer<any, any>;
/**
 * @typedef {Object} Options
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {number} [cacheSize=512] The tile representation cache size.
 * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.
 */
/**
 * @typedef {import("../../layer/BaseTile.js").default} BaseLayerType
 */
/**
 * @classdesc
 * Base WebGL renderer for tile layers.
 * @template {BaseLayerType} LayerType
 * @template {import("../../Tile.js").default} TileType
 * @template {import("../../webgl/BaseTileRepresentation.js").default<TileType>} TileRepresentation
 * @extends {WebGLLayerRenderer<LayerType>}
 */
declare class WebGLBaseTileLayerRenderer<LayerType extends BaseLayerType, TileType extends Tile$1, TileRepresentation extends BaseTileRepresentation<TileType>> extends WebGLLayerRenderer<LayerType> {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} options Options.
     */
    constructor(tileLayer: LayerType, options: Options$e);
    /**
     * The last call to `renderFrame` was completed with all tiles loaded
     * @type {boolean}
     */
    renderComplete: boolean;
    /**
     * This transform converts representation coordinates to screen coordinates.
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private tileTransform_;
    /**
     * @type {Array<number>}
     * @protected
     */
    protected tempMat4: Array<number>;
    /**
     * @type {import("../../TileRange.js").default}
     * @private
     */
    private tempTileRange_;
    /**
     * @type {import("../../tilecoord.js").TileCoord}
     * @private
     */
    private tempTileCoord_;
    /**
     * @type {import("../../size.js").Size}
     * @private
     */
    private tempSize_;
    /**
     * @type {import("../../structs/LRUCache.js").default<TileRepresentation>}
     * @protected
     */
    protected tileRepresentationCache: LRUCache<TileRepresentation>;
    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    protected frameState: FrameState | null;
    /**
     * @private
     * @type {import("../../proj/Projection.js").default}
     */
    private renderedProjection_;
    /**
     * @param {Options} options Options.
     * @override
     */
    override reset(options: Options$e): void;
    /**
     * @abstract
     * @param {import("../../webgl/BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options tile representation options
     * @return {TileRepresentation} A new tile representation
     * @protected
     */
    protected createTileRepresentation(options: TileRepresentationOptions<TileType>): TileRepresentation;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.
     * @param {number} preload Number of additional levels to load.
     */
    enqueueTiles(frameState: FrameState, extent: Extent$1, initialZ: number, tileRepresentationLookup: TileRepresentationLookup, preload: number): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha
     * @protected
     */
    protected beforeTilesRender(frameState: FrameState, tilesWithAlpha: boolean): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} If returns false, tile mask rendering will be skipped
     * @protected
     */
    protected beforeTilesMaskRender(frameState: FrameState): boolean;
    /**
     * @param {TileRepresentation} tileRepresentation Tile representation
     * @param {import("../../transform.js").Transform} tileTransform Tile transform
     * @param {import("../../Map.js").FrameState} frameState Frame state
     * @param {import("../../extent.js").Extent} renderExtent Render extent
     * @param {number} tileResolution Tile resolution
     * @param {import("../../size.js").Size} tileSize Tile size
     * @param {import("../../coordinate.js").Coordinate} tileOrigin Tile origin
     * @param {import("../../extent.js").Extent} tileExtent tile Extent
     * @param {number} depth Depth
     * @param {number} gutter Gutter
     * @param {number} alpha Alpha
     * @protected
     */
    protected renderTile(tileRepresentation: TileRepresentation, tileTransform: Transform, frameState: FrameState, renderExtent: Extent$1, tileResolution: number, tileSize: Size, tileOrigin: Coordinate, tileExtent: Extent$1, depth: number, gutter: number, alpha: number): void;
    /**
     * @param {TileRepresentation} tileRepresentation Tile representation
     * @param {number} tileZ Tile Z
     * @param {import("../../extent.js").Extent} extent Render extent
     * @param {number} depth Depth
     * @protected
     */
    protected renderTileMask(tileRepresentation: TileRepresentation, tileZ: number, extent: Extent$1, depth: number): void;
    drawTile_(frameState: any, tileRepresentation: any, tileZ: any, gutter: any, extent: any, alphaLookup: any, tileGrid: any): void;
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    override renderFrame(frameState: FrameState): HTMLElement;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    protected beforeFinalize(frameState: FrameState): void;
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile representation lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of
     * tile representations by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    private findAltTiles_;
}

type Options$d = {
    /**
     * Vertex shader source.
     */
    vertexShader: string;
    /**
     * Fragment shader source.
     */
    fragmentShader: string;
    /**
     * Additional uniforms
     * made available to shaders.
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
    /**
     * Palette textures.
     */
    paletteTextures?: PaletteTexture[] | undefined;
    /**
     * The texture cache size.
     */
    cacheSize?: number | undefined;
    /**
     * Post-processes definitions.
     */
    postProcesses?: PostProcessesOptions[] | undefined;
};
/**
 * @typedef {Object} Options
 * @property {string} vertexShader Vertex shader source.
 * @property {string} fragmentShader Fragment shader source.
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {Array<import("../../webgl/PaletteTexture.js").default>} [paletteTextures] Palette textures.
 * @property {number} [cacheSize=512] The texture cache size.
 * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.
 */
/**
 * @typedef {import("../../webgl/TileTexture.js").TileType} TileTextureType
 */
/**
 * @typedef {import("../../webgl/TileTexture.js").default} TileTextureRepresentation
 */
/**
 * @classdesc
 * WebGL renderer for tile layers.
 * @template {import("../../layer/WebGLTile.js").default|import("../../layer/Flow.js").default} LayerType
 * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}
 * @api
 */
declare class WebGLTileLayerRenderer<LayerType extends WebGLTileLayer | FlowLayer> extends WebGLBaseTileLayerRenderer<LayerType, TileType$1, TileTexture> {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} options Options.
     */
    constructor(tileLayer: LayerType, options: Options$d);
    /**
     * @type {WebGLProgram}
     * @private
     */
    private program_;
    /**
     * @private
     */
    private vertexShader_;
    /**
     * @private
     */
    private fragmentShader_;
    /**
     * Tiles are rendered as a quad with the following structure:
     *
     *  [P3]---------[P2]
     *   |`           |
     *   |  `     B   |
     *   |    `       |
     *   |      `     |
     *   |   A    `   |
     *   |          ` |
     *  [P0]---------[P1]
     *
     * Triangle A: P0, P1, P3
     * Triangle B: P1, P2, P3
     *
     * @private
     */
    private indices_;
    /**
     * @type {Array<import("../../webgl/PaletteTexture.js").default>}
     * @private
     */
    private paletteTextures_;
    /**
     * @param {Options} options Options.
     * @override
     */
    override reset(options: Options$d): void;
    /**
     * @override
     */
    override createTileRepresentation(options: any): TileTexture;
    /**
     * @override
     */
    override beforeTilesRender(frameState: any, tilesWithAlpha: any): void;
    /**
     * @override
     */
    override renderTile(tileTexture: any, tileTransform: any, frameState: any, renderExtent: any, tileResolution: any, tileSize: any, tileOrigin: any, tileExtent: any, depth: any, gutter: any, alpha: any): void;
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
     * @override
     */
    override getData(pixel: Pixel): Uint8ClampedArray | Uint8Array | Float32Array | DataView;
}

type LayerType$1 = FlowLayer;
type Options$c = {
    /**
     * The maximum particle speed in the input data.
     */
    maxSpeed: number;
    /**
     * A larger factor increases the rate at which particles cross the screen.
     */
    speedFactor?: number | undefined;
    /**
     * The number of particles to render.
     */
    particles?: number | undefined;
    /**
     * The texture cache size.
     */
    cacheSize?: number | undefined;
    /**
     * The flow tile vertex shader.
     */
    tileVertexShader: string;
    /**
     * The flow tile fragment shader.
     */
    tileFragmentShader: string;
    /**
     * Generic texture fragment shader.
     */
    textureVertexShader: string;
    /**
     * Generic texture fragment shader.
     */
    textureFragmentShader: string;
    /**
     * The particle position vertex shader.
     */
    particlePositionVertexShader: string;
    /**
     * The particle position fragment shader.
     */
    particlePositionFragmentShader: string;
    /**
     * The particle color vertex shader.
     */
    particleColorVertexShader: string;
    /**
     * The particle color fragment shader.
     */
    particleColorFragmentShader: string;
};
/**
 * @classdesc
 * Experimental WebGL renderer for vector fields.
 * @extends {WebGLTileLayerRenderer<LayerType>}
 */
declare class FlowLayerRenderer extends WebGLTileLayerRenderer<FlowLayer> {
    /**
     * @param {LayerType} layer The tiled field layer.
     * @param {Options} options The renderer options.
     */
    constructor(layer: LayerType$1, options: Options$c);
    /**
     * @type {string}
     * @private
     */
    private particleColorFragmentShader_;
    /**
     * @type {WebGLTexture|null}
     * @private
     */
    private velocityTexture_;
    /**
     * @type {number}
     * @private
     */
    private particleCountSqrt_;
    /**
     * @type {WebGLArrayBuffer}
     * @private
     */
    private particleIndexBuffer_;
    /**
     * @type {WebGLArrayBuffer}
     * @private
     */
    private quadBuffer_;
    /**
     * @type {WebGLProgram}
     * @private
     */
    private particlePositionProgram_;
    /**
     * @type {string}
     * @private
     */
    private particlePositionVertexShader_;
    /**
     * @type {string}
     * @private
     */
    private particlePositionFragmentShader_;
    /**
     * @type {WebGLTexture}
     * @private
     */
    private previousPositionTexture_;
    /**
     * @type {WebGLTexture}
     * @private
     */
    private nextPositionTexture_;
    /**
     * @type {WebGLProgram}
     * @private
     */
    private particleColorProgram_;
    /**
     * @type {string}
     * @private
     */
    private particleColorVertexShader_;
    /**
     * @type {WebGLProgram}
     * @private
     */
    private textureProgram_;
    /**
     * @type {string}
     * @private
     */
    private textureVertexShader_;
    /**
     * @type {string}
     * @private
     */
    private textureFragmentShader_;
    /**
     * @type {WebGLTexture}
     * @private
     */
    private previousTrailsTexture_;
    /**
     * @type {WebGLTexture}
     * @private
     */
    private nextTrailsTexture_;
    /**
     * @type {number}
     * @private
     */
    private fadeOpacity_;
    /**
     * @type {number}
     * @private
     */
    private maxSpeed_;
    /**
     * @type {number}
     * @private
     */
    private speedFactor_;
    /**
     * @type {number}
     * @private
     */
    private dropRate_;
    /**
     * @type {number}
     * @private
     */
    private dropRateBump_;
    /**
     * @type {Array<number>}
     * @private
     */
    private tempVec2_;
    /**
     * @type {number}
     * @private
     */
    private renderedWidth_;
    /**
     * @type {number}
     * @private
     */
    private renderedHeight_;
    framebuffer_: WebGLFramebuffer | undefined;
    createSizeDependentTextures_(): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    drawParticleTrails_(frameState: FrameState): void;
    /**
     * @param {WebGLTexture} texture The texture to draw.
     * @param {number} opacity The opacity.
     */
    drawTexture_(texture: WebGLTexture, opacity: number): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    drawParticleColor_(frameState: FrameState): void;
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    updateParticlePositions_(frameState: FrameState): void;
}

type SourceType = DataTileSource;
/**
 * Translates tile data to rendered pixels.
 */
type Style = {
    /**
     * Style variables.  Each variable must hold a number or string.  These
     * variables can be used in the `color` {@link import ("../expr/expression.js").ExpressionValue expression} using
     * the `['var', 'varName']` operator.  To update style variables, use the {@link import ("./WebGLTile.js").default#updateStyleVariables} method.
     */
    variables?: {
        [x: string]: string | number;
    } | undefined;
    /**
     * An expression applied to color values.
     */
    color?: ExpressionValue$1 | undefined;
};
type Options$b = {
    /**
     * The maximum particle speed.
     */
    maxSpeed: number;
    /**
     * A larger factor increases the rate at which particles cross the screen.
     */
    speedFactor?: number | undefined;
    /**
     * The number of particles to render.
     */
    particles?: number | undefined;
    /**
     * Style to apply to the layer.
     */
    style?: Style | undefined;
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Preload. Load low-resolution tiles up to `preload` levels. `0`
     * means no preloading.
     */
    preload?: number | undefined;
    /**
     * Source for this layer.
     */
    source?: DataTileSource<DataTile> | undefined;
    /**
     * Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module :ol/Map~Map#addLayer}.
     */
    map?: Map | undefined;
    /**
     * Use interim tiles on error.
     */
    useInterimTilesOnError?: boolean | undefined;
    /**
     * The internal texture cache size.  This needs to be large enough to render
     * two zoom levels worth of tiles.
     */
    cacheSize?: number | undefined;
};
/**
 * @classdesc
 * Experimental layer that renders particles moving through a vector field.
 *
 * @extends BaseTileLayer<SourceType, FlowLayerRenderer>
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 */
declare class FlowLayer extends BaseTileLayer<DataTileSource<DataTile>, FlowLayerRenderer> {
    /**
     * @param {Options} options Flow layer options.
     */
    constructor(options: Options$b);
    /**
     * @type {Style}
     * @private
     */
    private style_;
    /**
     * @type {number}
     * @private
     */
    private maxSpeed_;
    /**
     * @type {number}
     * @private
     */
    private speedFactor_;
    /**
     * @type {number}
     * @private
     */
    private particles_;
    /**
     * @type {Object<string, (string|number)>}
     * @private
     */
    private styleVariables_;
    /**
     * @private
     */
    private handleSourceUpdate_;
    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     */
    updateStyleVariables(variables: {
        [x: string]: number;
    }): void;
    /**
     * Gets the sources for this layer, for a given extent and resolution.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<SourceType>} Sources.
     */
    getSources(extent: Extent$1, resolution: number): Array<SourceType>;
}

type Options$a = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * The maximum number of meridians and
     * parallels from the center of the map. The default value of 100 means that at
     * most 200 meridians and 200 parallels will be displayed. The default value is
     * appropriate for conformal projections like Spherical Mercator. If you
     * increase the value, more lines will be drawn and the drawing performance will
     * decrease.
     */
    maxLines?: number | undefined;
    /**
     * The
     * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:
     * ```js
     * new Stroke({
     * color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black
     * });
     * ```
     */
    strokeStyle?: Stroke | undefined;
    /**
     * The target size of the graticule cells,
     * in pixels.
     */
    targetSize?: number | undefined;
    /**
     * Render a label with the respective
     * latitude/longitude for each graticule line.
     */
    showLabels?: boolean | undefined;
    /**
     * Label formatter for
     * longitudes. This function is called with the longitude as argument, and
     * should return a formatted string representing the longitude. By default,
     * labels are formatted as degrees, minutes, seconds and hemisphere.
     */
    lonLabelFormatter?: ((arg0: number) => string) | undefined;
    /**
     * Label formatter for
     * latitudes. This function is called with the latitude as argument, and
     * should return a formatted string representing the latitude. By default,
     * labels are formatted as degrees, minutes, seconds and hemisphere.
     */
    latLabelFormatter?: ((arg0: number) => string) | undefined;
    /**
     * Longitude label position in fractions
     * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the
     * top.
     */
    lonLabelPosition?: number | undefined;
    /**
     * Latitude label position in fractions
     * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the
     * right.
     */
    latLabelPosition?: number | undefined;
    /**
     * Longitude label text
     * style. If not provided, the following style will be used:
     * ```js
     * new Text({
     * font: '12px Calibri,sans-serif',
     * textBaseline: 'bottom',
     * fill: new Fill({
     * color: 'rgba(0,0,0,1)'
     * }),
     * stroke: new Stroke({
     * color: 'rgba(255,255,255,1)',
     * width: 3
     * })
     * });
     * ```
     * Note that the default's `textBaseline` configuration will not work well for
     * `lonLabelPosition` configurations that position labels close to the top of
     * the viewport.
     */
    lonLabelStyle?: Text$1 | undefined;
    /**
     * Latitude label text style.
     * If not provided, the following style will be used:
     * ```js
     * new Text({
     * font: '12px Calibri,sans-serif',
     * textAlign: 'end',
     * fill: new Fill({
     * color: 'rgba(0,0,0,1)'
     * }),
     * stroke: Stroke({
     * color: 'rgba(255,255,255,1)',
     * width: 3
     * })
     * });
     * ```
     * Note that the default's `textAlign` configuration will not work well for
     * `latLabelPosition` configurations that position labels close to the left of
     * the viewport.
     */
    latLabelStyle?: Text$1 | undefined;
    /**
     * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:
     * ```js
     * [30, 10]
     * ```
     */
    intervals?: number[] | undefined;
    /**
     * Whether to repeat the graticule horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @typedef {Object} GraticuleLabelDataType
 * @property {Point} geom Geometry.
 * @property {string} text Text.
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [maxLines=100] The maximum number of meridians and
 * parallels from the center of the map. The default value of 100 means that at
 * most 200 meridians and 200 parallels will be displayed. The default value is
 * appropriate for conformal projections like Spherical Mercator. If you
 * increase the value, more lines will be drawn and the drawing performance will
 * decrease.
 * @property {Stroke} [strokeStyle] The
 * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:
 * ```js
 * new Stroke({
 *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black
 * });
 * ```
 * @property {number} [targetSize=100] The target size of the graticule cells,
 * in pixels.
 * @property {boolean} [showLabels=false] Render a label with the respective
 * latitude/longitude for each graticule line.
 * @property {function(number):string} [lonLabelFormatter] Label formatter for
 * longitudes. This function is called with the longitude as argument, and
 * should return a formatted string representing the longitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {function(number):string} [latLabelFormatter] Label formatter for
 * latitudes. This function is called with the latitude as argument, and
 * should return a formatted string representing the latitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {number} [lonLabelPosition=0] Longitude label position in fractions
 * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the
 * top.
 * @property {number} [latLabelPosition=1] Latitude label position in fractions
 * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the
 * right.
 * @property {Text} [lonLabelStyle] Longitude label text
 * style. If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textBaseline: 'bottom',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: new Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textBaseline` configuration will not work well for
 * `lonLabelPosition` configurations that position labels close to the top of
 * the viewport.
 * @property {Text} [latLabelStyle] Latitude label text style.
 * If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textAlign: 'end',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textAlign` configuration will not work well for
 * `latLabelPosition` configurations that position labels close to the left of
 * the viewport.
 * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 30/60, 20/60, 10/60, 5/60, 2/60, 1/60, 30/3600, 20/3600, 10/3600, 5/3600, 2/3600, 1/3600]]
 * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:
 * ```js
 * [30, 10]
 * ```
 * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).
 * Note that the view projection must define both extent and worldExtent.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @extends {VectorLayer<VectorSource<Feature>>}
 * @api
 */
declare class Graticule extends VectorLayer<VectorSource<Feature$2<Geometry$1>>, Feature$2<Geometry$1>> {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$a);
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    private projection_;
    /**
     * @type {number}
     * @private
     */
    private maxLat_;
    /**
     * @type {number}
     * @private
     */
    private maxLon_;
    /**
     * @type {number}
     * @private
     */
    private minLat_;
    /**
     * @type {number}
     * @private
     */
    private minLon_;
    /**
     * @type {number}
     * @private
     */
    private maxX_;
    /**
     * @type {number}
     * @private
     */
    private maxY_;
    /**
     * @type {number}
     * @private
     */
    private minX_;
    /**
     * @type {number}
     * @private
     */
    private minY_;
    /**
     * @type {number}
     * @private
     */
    private targetSize_;
    /**
     * @type {number}
     * @private
     */
    private maxLines_;
    /**
     * @type {Array<LineString>}
     * @private
     */
    private meridians_;
    /**
     * @type {Array<LineString>}
     * @private
     */
    private parallels_;
    /**
     * @type {Stroke}
     * @private
     */
    private strokeStyle_;
    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */
    private fromLonLatTransform_;
    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */
    private toLonLatTransform_;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private projectionCenterLonLat_;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private bottomLeft_;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private bottomRight_;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private topLeft_;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    private topRight_;
    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */
    private meridiansLabels_;
    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */
    private parallelsLabels_;
    /**
     * @type {null|function(number):string}
     * @private
     */
    private lonLabelFormatter_;
    /**
     * @type {function(number):string}
     * @private
     */
    private latLabelFormatter_;
    /**
     * Longitude label position in fractions (0..1) of view extent. 0 means
     * bottom, 1 means top.
     * @type {number}
     * @private
     */
    private lonLabelPosition_;
    /**
     * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1
     * means right.
     * @type {number}
     * @private
     */
    private latLabelPosition_;
    /**
     * @type {Style}
     * @private
     */
    private lonLabelStyleBase_;
    /**
     * @private
     * @param {import("../Feature").default} feature Feature
     * @return {Style} style
     */
    private lonLabelStyle_;
    /**
     * @type {Style}
     * @private
     */
    private latLabelStyleBase_;
    /**
     * @private
     * @param {import("../Feature").default} feature Feature
     * @return {Style} style
     */
    private latLabelStyle_;
    /**
     * @type {Array<number>}
     * @private
     */
    private intervals_;
    /**
     * feature pool to use when updating graticule
     * @type {Array<Feature>}
     * @private
     */
    private featurePool_;
    /**
     * @type {Style}
     * @private
     */
    private lineStyle_;
    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */
    private loadedExtent_;
    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */
    private renderedExtent_;
    /**
     * @type {?number}
     * @private
     */
    private renderedResolution_;
    /**
     * Strategy function for loading features based on the view's extent and
     * resolution.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("../extent.js").Extent>} Extents.
     */
    strategyFunction(extent: Extent$1, resolution: number): Array<Extent$1>;
    /**
     * Update geometries in the source based on current view
     * @param {import("../extent").Extent} extent Extent
     * @param {number} resolution Resolution
     * @param {import("../proj/Projection.js").default} projection Projection
     */
    loaderFunction(extent: Extent$1, resolution: number, projection: Projection): void;
    /**
     * @param {number} lon Longitude.
     * @param {number} minLat Minimal latitude.
     * @param {number} maxLat Maximal latitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {number} Index.
     * @private
     */
    private addMeridian_;
    /**
     * @param {number} lat Latitude.
     * @param {number} minLon Minimal longitude.
     * @param {number} maxLon Maximal longitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {number} Index.
     * @private
     */
    private addParallel_;
    /**
     * @param {import("../render/Event.js").default} event Render event.
     * @private
     */
    private drawLabels_;
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} squaredTolerance Squared tolerance.
     * @private
     */
    private createGraticule_;
    /**
     * @param {number} resolution Resolution.
     * @return {number} The interval in degrees.
     * @private
     */
    private getInterval_;
    /**
     * @param {number} lon Longitude.
     * @param {number} minLat Minimal latitude.
     * @param {number} maxLat Maximal latitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} The meridian line string.
     * @param {number} index Index.
     * @private
     */
    private getMeridian_;
    /**
     * @param {LineString} lineString Meridian
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {Point} Meridian point.
     * @private
     */
    private getMeridianPoint_;
    /**
     * Get the list of meridians.  Meridians are lines of equal longitude.
     * @return {Array<LineString>} The meridians.
     * @api
     */
    getMeridians(): Array<LineString$1>;
    /**
     * @param {number} lat Latitude.
     * @param {number} minLon Minimal longitude.
     * @param {number} maxLon Maximal longitude.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} The parallel line string.
     * @param {number} index Index.
     * @private
     */
    private getParallel_;
    /**
     * @param {LineString} lineString Parallels.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} index Index.
     * @return {Point} Parallel point.
     * @private
     */
    private getParallelPoint_;
    /**
     * Get the list of parallels.  Parallels are lines of equal latitude.
     * @return {Array<LineString>} The parallels.
     * @api
     */
    getParallels(): Array<LineString$1>;
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @private
     */
    private updateProjectionInfo_;
}

type Options$9<FeatureType extends FeatureLike = Feature$2<Geometry$1>, VectorSourceType extends VectorSource<FeatureType> = VectorSource<FeatureType>> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * The color gradient
     * of the heatmap, specified as an array of CSS color strings.
     */
    gradient?: string[] | undefined;
    /**
     * Radius size in pixels.
     */
    radius?: number | undefined;
    /**
     * Blur size in pixels.
     */
    blur?: number | undefined;
    /**
     * The feature
     * attribute to use for the weight or a function that returns a weight from a feature. Weight values
     * should range from 0 to 1 (and values outside will be clamped to that range).
     */
    weight?: string | ((arg0: Feature$2) => number) | undefined;
    /**
     * Point source.
     */
    source?: VectorSourceType | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @template {import("../Feature.js").FeatureLike} [FeatureType=import("../Feature.js").default]
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<FeatureType>]
 * @extends {BaseVector<FeatureType, VectorSourceType, WebGLPointsLayerRenderer>}
 * @api
 */
declare class Heatmap<FeatureType extends FeatureLike = Feature$2<Geometry$1>, VectorSourceType extends VectorSource<FeatureType> = VectorSource<FeatureType>> extends BaseVectorLayer<FeatureType, VectorSourceType, WebGLPointsLayerRenderer> {
    /**
     * @param {Options<FeatureType, VectorSourceType>} [options] Options.
     */
    constructor(options?: Options$9<FeatureType, VectorSourceType>);
    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    private gradient_;
    /**
     * @private
     */
    private weightFunction_;
    /**
     * Return the blur size in pixels.
     * @return {number} Blur size in pixels.
     * @api
     * @observable
     */
    getBlur(): number;
    /**
     * Return the gradient colors as array of strings.
     * @return {Array<string>} Colors.
     * @api
     * @observable
     */
    getGradient(): Array<string>;
    /**
     * Return the size of the radius in pixels.
     * @return {number} Radius size in pixel.
     * @api
     * @observable
     */
    getRadius(): number;
    /**
     * @private
     */
    private handleGradientChanged_;
    /**
     * Set the blur size in pixels.
     * @param {number} blur Blur size in pixels.
     * @api
     * @observable
     */
    setBlur(blur: number): void;
    /**
     * Set the gradient colors as array of strings.
     * @param {Array<string>} colors Gradient.
     * @api
     * @observable
     */
    setGradient(colors: Array<string>): void;
    /**
     * Set the size of the radius in pixels.
     * @param {number} radius Radius size in pixel.
     * @api
     * @observable
     */
    setRadius(radius: number): void;
    /**
     * @override
     */
    override renderDeclutter(): void;
}

type ExpressionValue = ExpressionValue$1;
type ColorExpression = Color | string | Array<ExpressionValue>;
type BaseProps = {
    /**
     * Filter expression. If it resolves to a number strictly greater than 0, the
     * point will be displayed. If undefined, all points will show.
     */
    filter?: ExpressionValue$1 | undefined;
};
type FillProps = {
    /**
     * Fill color.
     */
    "fill-color"?: ColorExpression | undefined;
    /**
     * Fill pattern image source URI. If `fill-color` is defined as well, it will be used to tint this image.
     */
    "fill-pattern-src"?: string | undefined;
    /**
     * Offset, which, together with the size and the offset origin, define the
     * sub-rectangle to use from the original fill pattern image.
     */
    "fill-pattern-offset"?: number[] | ExpressionValue$1 | undefined;
    /**
     * Origin of the offset: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    "fill-pattern-offset-origin"?: IconOrigin | undefined;
    /**
     * Fill pattern image size in pixel. Can be used together with `fill-pattern-offset` to define the
     * sub-rectangle to use from the origin (sprite) fill pattern image.
     */
    "fill-pattern-size"?: Size | ExpressionValue$1 | undefined;
};
type StrokeProps = {
    /**
     * The stroke color.
     */
    "stroke-color"?: ColorExpression | undefined;
    /**
     * Stroke pixel width.
     */
    "stroke-width"?: ExpressionValue$1 | undefined;
    /**
     * Stroke offset in pixel. A positive value offsets the line to the right, relative to the direction of the line.
     */
    "stroke-offset"?: ExpressionValue$1 | undefined;
    /**
     * Line cap style: `butt`, `round`, or `square`.
     */
    "stroke-line-cap"?: string | number | boolean | any[] | Color | undefined;
    /**
     * Line join style: `bevel`, `round`, or `miter`.
     */
    "stroke-line-join"?: string | number | boolean | any[] | Color | undefined;
    /**
     * Line dash pattern.
     */
    "stroke-line-dash"?: number[] | ExpressionValue$1[] | undefined;
    /**
     * Line dash offset.
     */
    "stroke-line-dash-offset"?: ExpressionValue$1 | undefined;
    /**
     * Miter limit.
     */
    "stroke-miter-limit"?: ExpressionValue$1 | undefined;
    /**
     * Stroke pattern image source URI. If `stroke-color` is defined as well, it will be used to tint this image.
     */
    "stroke-pattern-src"?: string | undefined;
    /**
     * Offset, which, together with the size and the offset origin, define the
     * sub-rectangle to use from the original fill pattern image.
     */
    "stroke-pattern-offset"?: number[] | ExpressionValue$1 | undefined;
    /**
     * Origin of the offset: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    "stroke-pattern-offset-origin"?: IconOrigin | undefined;
    /**
     * Stroke pattern image size in pixel. Can be used together with `stroke-pattern-offset` to define the
     * sub-rectangle to use from the origin (sprite) fill pattern image.
     */
    "stroke-pattern-size"?: Size | ExpressionValue$1 | undefined;
    /**
     * Spacing between each pattern occurrence in pixels; 0 if undefined.
     */
    "stroke-pattern-spacing"?: ExpressionValue$1 | undefined;
};
type IconProps = {
    /**
     * Image source URI.
     */
    "icon-src"?: string | undefined;
    /**
     * Anchor. Default value is the icon center.
     */
    "icon-anchor"?: number[] | ExpressionValue$1 | undefined;
    /**
     * Origin of the anchor: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    "icon-anchor-origin"?: IconOrigin | undefined;
    /**
     * Units in which the anchor x value is
     * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
     * the x value in pixels.
     */
    "icon-anchor-x-units"?: IconAnchorUnits | undefined;
    /**
     * Units in which the anchor y value is
     * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
     * the y value in pixels.
     */
    "icon-anchor-y-units"?: IconAnchorUnits | undefined;
    /**
     * Color to tint the icon. If not specified,
     * the icon will be left as is.
     */
    "icon-color"?: ColorExpression | undefined;
    /**
     * Opacity of the icon.
     */
    "icon-opacity"?: ExpressionValue$1 | undefined;
    /**
     * The `crossOrigin` attribute for loaded images. Note that you must provide a
     * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     */
    "icon-cross-origin"?: string | null | undefined;
    /**
     * Displacement of the icon.
     */
    "icon-displacement"?: number[] | ExpressionValue$1 | undefined;
    /**
     * Scale.
     */
    "icon-scale"?: Size | ExpressionValue$1 | undefined;
    /**
     * Width of the icon. If not specified, the actual image width will be used. Cannot be combined
     * with `scale`.
     */
    "icon-width"?: ExpressionValue$1 | undefined;
    /**
     * Height of the icon. If not specified, the actual image height will be used. Cannot be combined
     * with `scale`.
     */
    "icon-height"?: ExpressionValue$1 | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    "icon-rotation"?: ExpressionValue$1 | undefined;
    /**
     * Whether to rotate the icon with the view.
     */
    "icon-rotate-with-view"?: boolean | undefined;
    /**
     * Offset, which, together with the size and the offset origin, define the
     * sub-rectangle to use from the original icon image.
     */
    "icon-offset"?: number[] | ExpressionValue$1 | undefined;
    /**
     * Origin of the offset: `bottom-left`, `bottom-right`,
     * `top-left` or `top-right`.
     */
    "icon-offset-origin"?: IconOrigin | undefined;
    /**
     * Icon size in pixel. Can be used together with `icon-offset` to define the
     * sub-rectangle to use from the origin (sprite) icon image.
     */
    "icon-size"?: Size | ExpressionValue$1 | undefined;
};
type ShapeProps = {
    /**
     * Number of points for stars and regular polygons. In case of a polygon, the number of points
     * is the number of sides.
     */
    "shape-points"?: ExpressionValue$1 | undefined;
    /**
     * The fill color.
     */
    "shape-fill-color"?: ColorExpression | undefined;
    /**
     * The stroke color.
     */
    "shape-stroke-color"?: ColorExpression | undefined;
    /**
     * Stroke pixel width.
     */
    "shape-stroke-width"?: ExpressionValue$1 | undefined;
    /**
     * Shape opacity.
     */
    "shape-opacity"?: ExpressionValue$1 | undefined;
    /**
     * Radius of a regular polygon.
     */
    "shape-radius"?: ExpressionValue$1 | undefined;
    /**
     * Second radius to make a star instead of a regular polygon.
     */
    "shape-radius2"?: ExpressionValue$1 | undefined;
    /**
     * Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
     */
    "shape-angle"?: ExpressionValue$1 | undefined;
    /**
     * Displacement of the shape
     */
    "shape-displacement"?: number[] | ExpressionValue$1[] | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    "shape-rotation"?: ExpressionValue$1 | undefined;
    /**
     * Whether to rotate the shape with the view.
     */
    "shape-rotate-with-view"?: boolean | undefined;
    /**
     * Scale. Unless two dimensional scaling is required a better
     * result may be obtained with appropriate settings for `shape-radius` and `shape-radius2`.
     */
    "shape-scale"?: Size | ExpressionValue$1 | ExpressionValue$1[] | undefined;
};
type CircleProps = {
    /**
     * Circle radius.
     */
    "circle-radius"?: ExpressionValue$1 | undefined;
    /**
     * The fill color.
     */
    "circle-fill-color"?: ColorExpression | undefined;
    /**
     * The stroke color.
     */
    "circle-stroke-color"?: ColorExpression | undefined;
    /**
     * Stroke pixel width.
     */
    "circle-stroke-width"?: ExpressionValue$1 | undefined;
    /**
     * Circle opacity.
     */
    "circle-opacity"?: ExpressionValue$1 | undefined;
    /**
     * displacement
     */
    "circle-displacement"?: number[] | ExpressionValue$1[] | undefined;
    /**
     * Scale. A two dimensional scale will produce an ellipse.
     * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
     */
    "circle-scale"?: Size | ExpressionValue$1 | ExpressionValue$1[] | undefined;
    /**
     * Rotation in radians
     * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
     */
    "circle-rotation"?: ExpressionValue$1 | undefined;
    /**
     * Whether to rotate the shape with the view
     * (meaningful only when used in conjunction with a two dimensional scale).
     */
    "circle-rotate-with-view"?: boolean | undefined;
};
type WebGLStyle = BaseProps & IconProps & StrokeProps & FillProps & CircleProps & ShapeProps;

type Options$8<VectorSourceType extends VectorSource<FeatureLike>> = {
    /**
     * Literal style to apply to the layer features.
     */
    style: WebGLStyle;
    /**
     * Style variables. Each variable must hold a literal value (not
     * an expression). These variables can be used as {@link import ("../expr/expression.js").ExpressionValue expressions} in the styles properties
     * using the `['var', 'varName']` operator.
     * To update style variables, use the {@link import ("./WebGLPoints.js").default#updateStyleVariables} method.
     */
    variables?: {
        [x: string]: string | number | boolean | number[];
    } | undefined;
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Point source.
     */
    source?: VectorSourceType | undefined;
    /**
     * Setting this to true will provide a slight performance boost, but will
     * prevent all hit detection on the layer.
     */
    disableHitDetection?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/**
 * @template {import("../source/Vector.js").default<import('../Feature').FeatureLike>} VectorSourceType
 * @typedef {Object} Options
 * @property {import('../style/webgl.js').WebGLStyle} style Literal style to apply to the layer features.
 * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not
 * an expression). These variables can be used as {@link import("../expr/expression.js").ExpressionValue expressions} in the styles properties
 * using the `['var', 'varName']` operator.
 * To update style variables, use the {@link import("./WebGLPoints.js").default#updateStyleVariables} method.
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {VectorSourceType} [source] Point source.
 * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will
 * prevent all hit detection on the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Layer optimized for rendering large point datasets. Takes a `style` property which
 * is a serializable JSON object describing how the layer should be rendered.
 *
 * Here are a few samples of literal style objects:
 * ```js
 * const style = {
 *   'circle-radius': 8,
 *   'circle-fill-color': '#33AAFF',
 *   'circle-opacity': 0.9
 * }
 * ```
 *
 * ```js
 * const style = {
 *   'icon-src': '../static/exclamation-mark.png',
 *   'icon-offset': [0, 12],
 *   'icon-width': 4,
 *   'icon-height': 8
 * }
 * ```
 *
 * **Important: a `WebGLPoints` layer must be manually disposed when removed, otherwise the underlying WebGL context
 * will not be garbage collected.**
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default<import('../Feature').FeatureLike>} VectorSourceType
 * @extends {Layer<VectorSourceType, WebGLPointsLayerRenderer>}
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 */
declare class WebGLPointsLayer<VectorSourceType extends VectorSource<FeatureLike>> extends Layer<VectorSourceType, WebGLPointsLayerRenderer> {
    /**
     * @param {Options<VectorSourceType>} options Options.
     */
    constructor(options: Options$8<VectorSourceType>);
    /**
     * @type {import('../style/flat.js').StyleVariables}
     * @private
     */
    private styleVariables_;
    /**
     * @private
     * @type {import('../webgl/styleparser.js').StyleParseResult}
     */
    private parseResult_;
    /**
     * @private
     * @type {boolean}
     */
    private hitDetectionDisabled_;
    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     */
    updateStyleVariables(variables: {
        [x: string]: number;
    }): void;
}

declare const COMMON_HEADER: "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform float u_rotation;\nuniform vec4 u_renderExtent;\nuniform vec2 u_patternOrigin;\nuniform float u_depth;\nuniform mediump int u_hitDetection;\n\nconst float PI = 3.141592653589793238;\nconst float TWO_PI = 2.0 * PI;\nfloat currentLineMetric = 0.; // an actual value will be used in the stroke shaders\n";
/**
 * @typedef {Object} VaryingDescription
 * @property {string} name Varying name, as will be declared in the header.
 * @property {string} type Varying type, either `float`, `vec2`, `vec4`...
 * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and
 * passed on to the fragment shader.
 */
/**
 * @classdesc
 * This class implements a classic builder pattern for generating many different types of shaders.
 * Methods can be chained, e. g.:
 *
 * ```js
 * const shader = new ShaderBuilder()
 *   .addVarying('v_width', 'float', 'a_width')
 *   .addUniform('u_time')
 *   .setColorExpression('...')
 *   .setSymbolSizeExpression('...')
 *   .getSymbolFragmentShader();
 * ```
 *
 * A note on [alpha premultiplication](https://en.wikipedia.org/wiki/Alpha_compositing#Straight_versus_premultiplied):
 * The ShaderBuilder class expects all colors to **not having been alpha-premultiplied!** This is because alpha
 * premultiplication is done at the end of each fragment shader.
 */
declare class ShaderBuilder {
    /**
     * Uniforms; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */
    private uniforms_;
    /**
     * Attributes; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */
    private attributes_;
    /**
     * Varyings with a name, a type and an expression.
     * @type {Array<VaryingDescription>}
     * @private
     */
    private varyings_;
    /**
     * @type {boolean}
     * @private
     */
    private hasSymbol_;
    /**
     * @type {string}
     * @private
     */
    private symbolSizeExpression_;
    /**
     * @type {string}
     * @private
     */
    private symbolRotationExpression_;
    /**
     * @type {string}
     * @private
     */
    private symbolOffsetExpression_;
    /**
     * @type {string}
     * @private
     */
    private symbolColorExpression_;
    /**
     * @type {string}
     * @private
     */
    private texCoordExpression_;
    /**
     * @type {string}
     * @private
     */
    private discardExpression_;
    /**
     * @type {boolean}
     * @private
     */
    private symbolRotateWithView_;
    /**
     * @type {boolean}
     * @private
     */
    private hasStroke_;
    /**
     * @type {string}
     * @private
     */
    private strokeWidthExpression_;
    /**
     * @type {string}
     * @private
     */
    private strokeColorExpression_;
    /**
     * @private
     */
    private strokeOffsetExpression_;
    /**
     * @private
     */
    private strokeCapExpression_;
    /**
     * @private
     */
    private strokeJoinExpression_;
    /**
     * @private
     */
    private strokeMiterLimitExpression_;
    /**
     * @private
     */
    private strokeDistanceFieldExpression_;
    /**
     * @type {boolean}
     * @private
     */
    private hasFill_;
    /**
     * @type {string}
     * @private
     */
    private fillColorExpression_;
    /**
     * @type {Array<string>}
     * @private
     */
    private vertexShaderFunctions_;
    /**
     * @type {Array<string>}
     * @private
     */
    private fragmentShaderFunctions_;
    /**
     * Adds a uniform accessible in both fragment and vertex shaders.
     * The given name should include a type, such as `sampler2D u_texture`.
     * @param {string} name Uniform name
     * @return {ShaderBuilder} the builder object
     */
    addUniform(name: string): ShaderBuilder;
    /**
     * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
     * The given name should include a type, such as `vec2 a_position`.
     * @param {string} name Attribute name
     * @return {ShaderBuilder} the builder object
     */
    addAttribute(name: string): ShaderBuilder;
    /**
     * Adds a varying defined in the vertex shader and accessible from the fragment shader.
     * The type and expression of the varying have to be specified separately.
     * @param {string} name Varying name
     * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
     * @param {string} expression Expression used to assign a value to the varying.
     * @return {ShaderBuilder} the builder object
     */
    addVarying(name: string, type: "float" | "vec2" | "vec3" | "vec4", expression: string): ShaderBuilder;
    /**
     * Sets an expression to compute the size of the shape.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec2` value.
     * @param {string} expression Size expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolSizeExpression(expression: string): ShaderBuilder;
    /**
     * @return {string} The current symbol size expression
     */
    getSymbolSizeExpression(): string;
    /**
     * Sets an expression to compute the rotation of the shape.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `float` value in radians.
     * @param {string} expression Size expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolRotationExpression(expression: string): ShaderBuilder;
    /**
     * Sets an expression to compute the offset of the symbol from the point center.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec2` value.
     * @param {string} expression Offset expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolOffsetExpression(expression: string): ShaderBuilder;
    /**
     * @return {string} The current symbol offset expression
     */
    getSymbolOffsetExpression(): string;
    /**
     * Sets an expression to compute the color of the shape.
     * This expression can use all the uniforms, varyings and attributes available
     * in the fragment shader, and should evaluate to a `vec4` value.
     * @param {string} expression Color expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolColorExpression(expression: string): ShaderBuilder;
    /**
     * @return {string} The current symbol color expression
     */
    getSymbolColorExpression(): string;
    /**
     * Sets an expression to compute the texture coordinates of the vertices.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec4` value.
     * @param {string} expression Texture coordinate expression
     * @return {ShaderBuilder} the builder object
     */
    setTextureCoordinateExpression(expression: string): ShaderBuilder;
    /**
     * Sets an expression to determine whether a fragment (pixel) should be discarded,
     * i.e. not drawn at all.
     * This expression can use all the uniforms, varyings and attributes available
     * in the fragment shader, and should evaluate to a `bool` value (it will be
     * used in an `if` statement)
     * @param {string} expression Fragment discard expression
     * @return {ShaderBuilder} the builder object
     */
    setFragmentDiscardExpression(expression: string): ShaderBuilder;
    /**
     * @return {string} The current fragment discard expression
     */
    getFragmentDiscardExpression(): string;
    /**
     * Sets whether the symbols should rotate with the view or stay aligned with the map.
     * Note: will only be used for point geometry shaders.
     * @param {boolean} rotateWithView Rotate with view
     * @return {ShaderBuilder} the builder object
     */
    setSymbolRotateWithView(rotateWithView: boolean): ShaderBuilder;
    /**
     * @param {string} expression Stroke width expression, returning value in pixels
     * @return {ShaderBuilder} the builder object
     */
    setStrokeWidthExpression(expression: string): ShaderBuilder;
    /**
     * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
     * @return {ShaderBuilder} the builder object
     */
    setStrokeColorExpression(expression: string): ShaderBuilder;
    /**
     * @return {string} The current stroke color expression
     */
    getStrokeColorExpression(): string;
    /**
     * @param {string} expression Stroke color expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeOffsetExpression(expression: string): ShaderBuilder;
    /**
     * @param {string} expression Stroke line cap expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeCapExpression(expression: string): ShaderBuilder;
    /**
     * @param {string} expression Stroke line join expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeJoinExpression(expression: string): ShaderBuilder;
    /**
     * @param {string} expression Stroke miter limit expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeMiterLimitExpression(expression: string): ShaderBuilder;
    /**
     * @param {string} expression Stroke distance field expression, evaluate to `float`
     * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
     * @return {ShaderBuilder} the builder object
     */
    setStrokeDistanceFieldExpression(expression: string): ShaderBuilder;
    /**
     * @param {string} expression Fill color expression, evaluate to `vec4`
     * @return {ShaderBuilder} the builder object
     */
    setFillColorExpression(expression: string): ShaderBuilder;
    /**
     * @return {string} The current fill color expression
     */
    getFillColorExpression(): string;
    addVertexShaderFunction(code: any): void;
    addFragmentShaderFunction(code: any): void;
    /**
     * Generates a symbol vertex shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getSymbolVertexShader(): string | null;
    /**
     * Generates a symbol fragment shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getSymbolFragmentShader(): string | null;
    /**
     * Generates a stroke vertex shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getStrokeVertexShader(): string | null;
    /**
     * Generates a stroke fragment shader from the builder parameters
     *
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getStrokeFragmentShader(): string | null;
    /**
     * Generates a fill vertex shader from the builder parameters
     *
     * @return {string|null} The full shader as a string; null if no color specified
     */
    getFillVertexShader(): string | null;
    /**
     * Generates a fill fragment shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no color specified
     */
    getFillFragmentShader(): string | null;
}

type Feature = Feature$2;
/**
 * Object that holds a reference to a feature as well as the raw coordinates of its various geometries
 */
type GeometryBatchItem = {
    /**
     * Feature
     */
    feature: Feature | RenderFeature;
    /**
     * Array of flat coordinates arrays, one for each geometry related to the feature
     */
    flatCoordss: Array<Array<number>>;
    /**
     * Only defined for linestring and polygon batches
     */
    verticesCount?: number | undefined;
    /**
     * Only defined for polygon batches
     */
    ringsCount?: number | undefined;
    /**
     * Array of vertices counts in each ring for each geometry; only defined for polygons batches
     */
    ringsVerticesCounts?: number[][] | undefined;
    /**
     * The reference in the global batch (used for hit detection)
     */
    ref?: number | undefined;
};
/**
 * A geometry batch specific to polygons
 */
type PolygonGeometryBatch = {
    /**
     * Dictionary of all entries in the batch with associated computed values.
     * One entry corresponds to one feature. Key is feature uid.
     */
    entries: {
        [x: string]: GeometryBatchItem;
    };
    /**
     * Amount of geometries in the batch.
     */
    geometriesCount: number;
    /**
     * Amount of vertices from geometries in the batch.
     */
    verticesCount: number;
    /**
     * How many outer and inner rings in this batch.
     */
    ringsCount: number;
};
/**
 * A geometry batch specific to lines
 */
type LineStringGeometryBatch = {
    /**
     * Dictionary of all entries in the batch with associated computed values.
     * One entry corresponds to one feature. Key is feature uid.
     */
    entries: {
        [x: string]: GeometryBatchItem;
    };
    /**
     * Amount of geometries in the batch.
     */
    geometriesCount: number;
    /**
     * Amount of vertices from geometries in the batch.
     */
    verticesCount: number;
};
/**
 * A geometry batch specific to points
 */
type PointGeometryBatch = {
    /**
     * Dictionary of all entries in the batch with associated computed values.
     * One entry corresponds to one feature. Key is feature uid.
     */
    entries: {
        [x: string]: GeometryBatchItem;
    };
    /**
     * Amount of geometries in the batch.
     */
    geometriesCount: number;
};
/**
 * @typedef {import("../../Feature.js").default} Feature
 */
/**
 * @typedef {import("../../geom/Geometry.js").Type} GeometryType
 */
/**
 * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries
 * @property {Feature|RenderFeature} feature Feature
 * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature
 * @property {number} [verticesCount] Only defined for linestring and polygon batches
 * @property {number} [ringsCount] Only defined for polygon batches
 * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches
 * @property {number} [ref] The reference in the global batch (used for hit detection)
 */
/**
 * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch
 */
/**
 * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons
 * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.
 * One entry corresponds to one feature. Key is feature uid.
 * @property {number} geometriesCount Amount of geometries in the batch.
 * @property {number} verticesCount Amount of vertices from geometries in the batch.
 * @property {number} ringsCount How many outer and inner rings in this batch.
 */
/**
 * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines
 * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.
 * One entry corresponds to one feature. Key is feature uid.
 * @property {number} geometriesCount Amount of geometries in the batch.
 * @property {number} verticesCount Amount of vertices from geometries in the batch.
 */
/**
 * @typedef {Object} PointGeometryBatch A geometry batch specific to points
 * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.
 * One entry corresponds to one feature. Key is feature uid.
 * @property {number} geometriesCount Amount of geometries in the batch.
 */
/**
 * @classdesc This class is used to group several geometries of various types together for faster rendering.
 * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed
 * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.
 *
 * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch
 * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries
 * and added to the corresponding batches in a recursive manner.
 *
 * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions
 * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,
 * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.
 * The resulting WebGL buffers are stored on the batches as well.
 *
 * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers
 * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.
 * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for
 * the WebGL buffers.
 */
declare class MixedGeometryBatch {
    /**
     * @private
     */
    private globalCounter_;
    /**
     * Refs are used as keys for hit detection.
     * @type {Map<number, Feature|RenderFeature>}
     * @private
     */
    private refToFeature_;
    /**
     * Features are split in "entries", which are individual geometries. We use the following map to share a single ref for all those entries.
     * @type {Map<string, number>}
     * @private
     */
    private uidToRef_;
    /**
     * The precision in WebGL shaders is limited.
     * To keep the refs as small as possible we maintain an array of returned references.
     * @type {Array<number>}
     * @private
     */
    private freeGlobalRef_;
    /**
     * @type {PolygonGeometryBatch}
     */
    polygonBatch: PolygonGeometryBatch;
    /**
     * @type {PointGeometryBatch}
     */
    pointBatch: PointGeometryBatch;
    /**
     * @type {LineStringGeometryBatch}
     */
    lineStringBatch: LineStringGeometryBatch;
    /**
     * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch
     * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
     */
    addFeatures(features: Array<Feature | RenderFeature>, projectionTransform?: TransformFunction): void;
    /**
     * @param {Feature|RenderFeature} feature Feature to add to the batch
     * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
     */
    addFeature(feature: Feature | RenderFeature, projectionTransform?: TransformFunction): void;
    /**
     * @param {Feature|RenderFeature} feature Feature
     * @return {GeometryBatchItem|void} the cleared entry
     * @private
     */
    private clearFeatureEntryInPointBatch_;
    /**
     * @param {Feature|RenderFeature} feature Feature
     * @return {GeometryBatchItem|void} the cleared entry
     * @private
     */
    private clearFeatureEntryInLineStringBatch_;
    /**
     * @param {Feature|RenderFeature} feature Feature
     * @return {GeometryBatchItem|void} the cleared entry
     * @private
     */
    private clearFeatureEntryInPolygonBatch_;
    /**
     * @param {import("../../geom.js").Geometry|RenderFeature} geometry Geometry
     * @param {Feature|RenderFeature} feature Feature
     * @private
     */
    private addGeometry_;
    /**
     * @param {GeometryType} type Geometry type
     * @param {Array<number>} flatCoords Flat coordinates
     * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends
     * @param {Feature|RenderFeature} feature Feature
     * @param {string} featureUid Feature uid
     * @param {number} stride Stride
     * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout
     * @private
     */
    private addCoordinates_;
    /**
     * @param {string} featureUid Feature uid
     * @param {GeometryBatchItem} entry The entry to add
     * @return {GeometryBatchItem} the added entry
     * @private
     */
    private addRefToEntry_;
    /**
     * Return a ref to the pool of available refs.
     * @param {number} ref the ref to return
     * @param {string} featureUid the feature uid
     * @private
     */
    private returnRef_;
    /**
     * @param {Feature|RenderFeature} feature Feature
     */
    changeFeature(feature: Feature | RenderFeature): void;
    /**
     * @param {Feature|RenderFeature} feature Feature
     */
    removeFeature(feature: Feature | RenderFeature): void;
    clear(): void;
    /**
     * Resolve the feature associated to a ref.
     * @param {number} ref Hit detected ref
     * @return {Feature|RenderFeature} feature
     */
    getFeatureFromRef(ref: number): Feature | RenderFeature;
}

/**
 * A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 */
type AttributeDefinition = {
    /**
     * Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value
     * of the callback should be an array; if unspecified, assumed to be a single float value
     */
    size?: number | undefined;
    /**
     * This callback computes the numerical value of the
     * attribute for a given feature.
     */
    callback: (this: GeometryBatchItem, arg1: FeatureLike) => number | Array<number>;
};
type AttributeDefinitions = {
    [x: string]: AttributeDefinition;
};
type UniformDefinitions = {
    [x: string]: UniformValue;
};
type WebGLBuffers = {
    /**
     * Array containing indices and vertices buffers for polygons
     */
    polygonBuffers: Array<WebGLArrayBuffer>;
    /**
     * Array containing indices and vertices buffers for line strings
     */
    lineStringBuffers: Array<WebGLArrayBuffer>;
    /**
     * Array containing indices and vertices buffers for points
     */
    pointBuffers: Array<WebGLArrayBuffer>;
    /**
     * Inverse of the transform applied when generating buffers
     */
    invertVerticesTransform: Transform;
};
type StyleShaders = {
    /**
     * Shader builder with the appropriate presets.
     */
    builder: ShaderBuilder;
    /**
     * Custom attributes made available in the vertex shaders.
     * Default shaders rely on the attributes in {@link Attributes}.
     */
    attributes?: {
        [x: string]: AttributeDefinition;
    } | undefined;
    /**
     * Additional uniforms usable in shaders.
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
};
type VectorStyle$2 = WebGLStyle | StyleShaders;
/**
 * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value
 * of the callback should be an array; if unspecified, assumed to be a single float value
 * @property {function(this:import("./MixedGeometryBatch.js").GeometryBatchItem, import("../../Feature").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the
 * attribute for a given feature.
 */
/**
 * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions
 * @typedef {Object<string, import("../../webgl/Helper").UniformValue>} UniformDefinitions
 */
/**
 * @typedef {Object} WebGLBuffers
 * @property {Array<WebGLArrayBuffer>} polygonBuffers Array containing indices and vertices buffers for polygons
 * @property {Array<WebGLArrayBuffer>} lineStringBuffers Array containing indices and vertices buffers for line strings
 * @property {Array<WebGLArrayBuffer>} pointBuffers Array containing indices and vertices buffers for points
 * @property {import("../../transform.js").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers
 */
/**
 * @typedef {Object} RenderInstructions
 * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render
 * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render
 * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render
 */
/**
 * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)
 * @property {string} vertex Vertex shader source
 * @property {string} fragment Fragment shader source
 */
/**
 * @typedef {Object} StyleShaders
 * @property {import("../../webgl/ShaderBuilder.js").ShaderBuilder} builder Shader builder with the appropriate presets.
 * @property {AttributeDefinitions} [attributes] Custom attributes made available in the vertex shaders.
 * Default shaders rely on the attributes in {@link Attributes}.
 * @property {UniformDefinitions} [uniforms] Additional uniforms usable in shaders.
 */
/**
 * @typedef {import('../../style/webgl.js').WebGLStyle|StyleShaders} VectorStyle
 */
/**
 * @classdesc This class is responsible for:
 * 1. generate WebGL buffers according to a provided style, using a MixedGeometryBatch as input
 * 2. rendering geometries contained in said buffers
 *
 * A layer renderer will typically maintain several of these in order to have several styles rendered separately.
 *
 * A VectorStyleRenderer instance can be created either from a literal style or from shaders using either
 * `VectorStyleRenderer.fromStyle` or `VectorStyleRenderer.fromShaders`. The shaders should not be provided explicitly
 * but instead as a preconfigured ShaderBuilder instance.
 *
 * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the
 * same renderer.
 */
declare class VectorStyleRenderer {
    /**
     * @param {VectorStyle} styleOrShaders Literal style or custom shaders
     * @param {import('../../style/flat.js').StyleVariables} variables Style variables
     * @param {import('../../webgl/Helper.js').default} helper Helper
     * @param {boolean} enableHitDetection Whether to enable the hit detection (needs compatible shader)
     */
    constructor(styleOrShaders: VectorStyle$2, variables: StyleVariables, helper: WebGLHelper, enableHitDetection: boolean);
    /**
     * @private
     * @type {import('../../webgl/Helper.js').default}
     */
    private helper_;
    /**
     * @private
     */
    private hitDetectionEnabled_;
    /**
     * @private
     * @type {WebGLProgram}
     */
    private fillProgram_;
    /**
     * @private
     * @type {WebGLProgram}
     */
    private strokeProgram_;
    /**
     * @private
     * @type {WebGLProgram}
     */
    private symbolProgram_;
    /**
     * @type {boolean}
     * @private
     */
    private hasFill_;
    /**
     * @private
     */
    private fillVertexShader_;
    /**
     * @private
     */
    private fillFragmentShader_;
    /**
     * @type {boolean}
     * @private
     */
    private hasStroke_;
    /**
     * @private
     */
    private strokeVertexShader_;
    /**
     * @private
     */
    private strokeFragmentShader_;
    /**
     * @type {boolean}
     * @private
     */
    private hasSymbol_;
    /**
     * @private
     */
    private symbolVertexShader_;
    /**
     * @private
     */
    private symbolFragmentShader_;
    /**
     * @private
     */
    private customAttributes_;
    /**
     * @private
     */
    private uniforms_;
    /**
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     * @private
     */
    private polygonAttributesDesc_;
    /**
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     * @private
     */
    private lineStringAttributesDesc_;
    /**
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     * @private
     */
    private pointAttributesDesc_;
    /**
     * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
     * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
     * @return {Promise<WebGLBuffers>} A promise resolving to WebGL buffers
     */
    generateBuffers(geometryBatch: MixedGeometryBatch, transform: Transform): Promise<WebGLBuffers>;
    /**
     * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
     * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
     * @return {RenderInstructions} Render instructions
     * @private
     */
    private generateRenderInstructions_;
    /**
     * @param {Float32Array|null} renderInstructions Render instructions
     * @param {import("../../geom/Geometry.js").Type} geometryType Geometry type
     * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
     * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render
     * @private
     */
    private generateBuffersForType_;
    /**
     * Render the geometries in the given buffers.
     * @param {WebGLBuffers} buffers WebGL Buffers to draw
     * @param {import("../../Map.js").FrameState} frameState Frame state
     * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
     */
    render(buffers: WebGLBuffers, frameState: FrameState, preRenderCallback: () => void): void;
    /**
     * @param {WebGLArrayBuffer} indicesBuffer Indices buffer
     * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer
     * @param {WebGLProgram} program Program
     * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
     * @private
     */
    private renderInternal_;
    /**
     * @param {import('../../webgl/Helper.js').default} helper Helper
     * @param {WebGLBuffers} buffers WebGL Buffers to reload if any
     */
    setHelper(helper: WebGLHelper, buffers?: WebGLBuffers): void;
}

type VectorStyle$1 = VectorStyle$2;
type Options$7 = {
    /**
     * A CSS class name to set to the canvas element.
     */
    className?: string | undefined;
    /**
     * Vector style as literal style or shaders; can also accept an array of styles
     */
    style: VectorStyle$1 | Array<VectorStyle$1>;
    /**
     * Style variables
     */
    variables: {
        [x: string]: string | number | boolean | number[];
    };
    /**
     * Setting this to true will provide a slight performance boost, but will
     * prevent all hit detection on the layer.
     */
    disableHitDetection?: boolean | undefined;
    /**
     * Post-processes definitions
     */
    postProcesses?: PostProcessesOptions[] | undefined;
};
/**
 * @typedef {import('../../render/webgl/VectorStyleRenderer.js').VectorStyle} VectorStyle
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.
 * @property {VectorStyle|Array<VectorStyle>} style Vector style as literal style or shaders; can also accept an array of styles
 * @property {Object<string, number|Array<number>|string|boolean>} variables Style variables
 * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will
 * prevent all hit detection on the layer.
 * @property {Array<import("./Layer").PostProcessesOptions>} [postProcesses] Post-processes definitions
 */
/**
 * @classdesc
 * Experimental WebGL vector renderer. Supports polygons, lines and points:
 *  * Polygons are broken down into triangles
 *  * Lines are rendered as strips of quads
 *  * Points are rendered as quads
 *
 * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders
 * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.
 * The vertex shaders can access the following attributes depending on the geometry type:
 *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}
 *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}
 *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}
 *
 * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.
 *
 * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.
 */
declare class WebGLVectorLayerRenderer extends WebGLLayerRenderer<any> {
    /**
     * @param {import("../../layer/Layer.js").default} layer Layer.
     * @param {Options} options Options.
     */
    constructor(layer: Layer, options: Options$7);
    /**
     * @type {boolean}
     * @private
     */
    private hitDetectionEnabled_;
    /**
     * @type {WebGLRenderTarget}
     * @private
     */
    private hitRenderTarget_;
    /**
     * @private
     */
    private sourceRevision_;
    /**
     * @private
     */
    private previousExtent_;
    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private currentTransform_;
    /**
     * @private
     */
    private tmpCoords_;
    /**
     * @private
     */
    private tmpTransform_;
    /**
     * @private
     */
    private tmpMat4_;
    /**
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private currentFrameStateTransform_;
    /**
     * @type {import('../../style/flat.js').StyleVariables}
     * @private
     */
    private styleVariables_;
    /**
     * @type {Array<VectorStyle>}
     * @private
     */
    private styles_;
    /**
     * @type {Array<VectorStyleRenderer>}
     * @private
     */
    private styleRenderers_;
    /**
     * @type {Array<import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers>}
     * @private
     */
    private buffers_;
    /**
     * @private
     */
    private batch_;
    /**
     * @private
     * @type {boolean}
     */
    private initialFeaturesAdded_;
    /**
     * @private
     * @type {Array<import("../../events.js").EventsKey|null>}
     */
    private sourceListenKeys_;
    /**
     * @private
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    private addInitialFeatures_;
    /**
     * @param {Options} options Options.
     * @private
     */
    private applyOptions_;
    /**
     * @private
     */
    private createRenderers_;
    /**
     * @override
     */
    override reset(options: any): void;
    /**
     * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceFeatureAdded_;
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceFeatureChanged_;
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    private handleSourceFeatureDelete_;
    /**
     * @private
     */
    private handleSourceFeatureClear_;
    /**
     * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed
     * @private
     */
    private applyUniforms_;
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    override renderFrame(frameState: FrameState): HTMLElement;
    /**
     * Render the world, either to the main framebuffer or to the hit framebuffer
     * @param {import("../../Map.js").FrameState} frameState current frame state
     * @param {boolean} forHitDetection whether the rendering is for hit detection
     * @param {number} startWorld the world to render in the first iteration
     * @param {number} endWorld the last world to render
     * @param {number} worldWidth the width of the worlds being rendered
     */
    renderWorlds(frameState: FrameState, forHitDetection: boolean, startWorld: number, endWorld: number, worldWidth: number): void;
    /**
     * Will release a set of Webgl buffers
     * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers
     */
    disposeBuffers(buffers: WebGLBuffers): void;
}

/**
 * *
 */
type ExtractedFeatureType<T> = T extends VectorSource<infer U extends FeatureLike> ? U : never;
type Options$6<VectorSourceType extends VectorSource<FeatureType> = VectorSource<any>, FeatureType extends FeatureLike = ExtractedFeatureType<VectorSourceType>> = {
    /**
     * A CSS class name to set to the layer element.
     */
    className?: string | undefined;
    /**
     * Opacity (0, 1).
     */
    opacity?: number | undefined;
    /**
     * Visibility.
     */
    visible?: boolean | undefined;
    /**
     * The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * FIXME: not supported yet
     */
    extent?: Extent$1 | undefined;
    /**
     * The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
     * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
     * method was used.
     */
    zIndex?: number | undefined;
    /**
     * The minimum resolution (inclusive) at which this layer will be
     * visible.
     */
    minResolution?: number | undefined;
    /**
     * The maximum resolution (exclusive) below which this layer will
     * be visible.
     */
    maxResolution?: number | undefined;
    /**
     * The minimum view zoom level (exclusive) above which this layer will be
     * visible.
     */
    minZoom?: number | undefined;
    /**
     * The maximum view zoom level (inclusive) at which this layer will
     * be visible.
     */
    maxZoom?: number | undefined;
    /**
     * Source.
     */
    source?: VectorSourceType | undefined;
    /**
     * Layer style.
     */
    style: WebGLStyle;
    /**
     * Style variables. Each variable must hold a literal value (not
     * an expression). These variables can be used as {@link import ("../expr/expression.js").ExpressionValue expressions} in the styles properties
     * using the `['var', 'varName']` operator.
     * To update style variables, use the {@link import ("./WebGLVector.js").default#updateStyleVariables} method.
     */
    variables?: {
        [x: string]: string | number | boolean | number[];
    } | undefined;
    /**
     * Background color for the layer. If not specified, no background
     * will be rendered.
     * FIXME: not supported yet
     */
    background?: BackgroundColor | undefined;
    /**
     * Setting this to true will provide a slight performance boost, but will
     * prevent all hit detection on the layer.
     */
    disableHitDetection?: boolean | undefined;
    /**
     * Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
     */
    properties?: {
        [x: string]: any;
    } | undefined;
};
/***
 * @template T
 * @typedef {T extends import("../source/Vector.js").default<infer U extends import("../Feature.js").FeatureLike> ? U : never} ExtractedFeatureType
 */
/**
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=ExtractedFeatureType<VectorSourceType>]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * FIXME: not supported yet
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {VectorSourceType} [source] Source.
 * @property {import('../style/webgl.js').WebGLStyle} style Layer style.
 * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not
 * an expression). These variables can be used as {@link import("../expr/expression.js").ExpressionValue expressions} in the styles properties
 * using the `['var', 'varName']` operator.
 * To update style variables, use the {@link import("./WebGLVector.js").default#updateStyleVariables} method.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * FIXME: not supported yet
 * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will
 * prevent all hit detection on the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Layer optimized for rendering large vector datasets.
 *
 * **Important: a `WebGLVector` layer must be manually disposed when removed, otherwise the underlying WebGL context
 * will not be garbage collected.**
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default<FeatureType>} [VectorSourceType=import("../source/Vector.js").default<*>]
 * @template {import('../Feature.js').FeatureLike} [FeatureType=ExtractedFeatureType<VectorSourceType>]
 * @extends {Layer<VectorSourceType, WebGLVectorLayerRenderer>}
 */
declare class WebGLVectorLayer<VectorSourceType extends VectorSource<FeatureType> = VectorSource<any>, FeatureType extends FeatureLike = ExtractedFeatureType<VectorSourceType>> extends Layer<VectorSourceType, WebGLVectorLayerRenderer> {
    /**
     * @param {Options<VectorSourceType, FeatureType>} [options] Options.
     */
    constructor(options?: Options$6<VectorSourceType, FeatureType>);
    /**
     * @type {import('../style/flat.js').StyleVariables}
     * @private
     */
    private styleVariables_;
    /**
     * @private
     */
    private style_;
    /**
     * @private
     */
    private hitDetectionDisabled_;
    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {import('../style/flat.js').StyleVariables} variables Variables to update.
     */
    updateStyleVariables(variables: StyleVariables): void;
    /**
     * Set the layer style.
     * @param {import('../style/webgl.js').WebGLStyle} style Layer style.
     */
    setStyle(style: WebGLStyle): void;
    style: WebGLStyle | undefined;
}

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
declare function all(extent: Extent$1, resolution: number): Array<Extent$1>;
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
declare function bbox(extent: Extent$1, resolution: number): Array<Extent$1>;
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
declare function tile(tileGrid: TileGrid): (arg0: Extent$1, arg1: number, arg2: Projection) => Array<Extent$1>;

/**
 * @module ol/math
 */
/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
declare function clamp(value: number, min: number, max: number): number;
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
declare function squaredSegmentDistance(x: number, y: number, x1: number, y1: number, x2: number, y2: number): number;
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
declare function squaredDistance(x1: number, y1: number, x2: number, y2: number): number;
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>|null} The resulting vector.
 */
declare function solveLinearSystem(mat: Array<Array<number>>): Array<number> | null;
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
declare function toDegrees(angleInRadians: number): number;
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
declare function toRadians(angleInDegrees: number): number;
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
declare function modulo(a: number, b: number): number;
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
declare function lerp(a: number, b: number, x: number): number;
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */
declare function toFixed(n: number, decimals: number): number;
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */
declare function round(n: number, decimals: number): number;
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */
declare function floor(n: number, decimals: number): number;
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */
declare function ceil(n: number, decimals: number): number;
/**
 * Wraps a number between some minimum and maximum values.
 * @param {number} n The number to wrap.
 * @param {number} min The minimum of the range (inclusive).
 * @param {number} max The maximum of the range (exclusive).
 * @return {number} The wrapped number.
 */
declare function wrap(n: number, min: number, max: number): number;

/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {Function} [errback] Callback on error.
 * @param {string} [callbackParam] Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */
declare function jsonp(url: string, callback: Function, errback?: Function, callbackParam?: string): void;
/**
 * @param {string} url The URL.
 * @return {Promise<Object>} A promise that resolves to the JSON response.
 */
declare function getJSON(url: string): Promise<any>;
/**
 * @param {string} base The base URL.
 * @param {string} url The potentially relative URL.
 * @return {string} The full URL.
 */
declare function resolveUrl(base: string, url: string): string;
declare function overrideXHR(xhr: any): void;
declare function restoreXHR(): void;
declare class ResponseError extends Error {
    /**
     * @param {XMLHttpRequest} response The XHR object.
     */
    constructor(response: XMLHttpRequest);
    /**
     * @type {XMLHttpRequest}
     */
    response: XMLHttpRequest;
}
declare class ClientError extends Error {
    /**
     * @param {XMLHttpRequest} client The XHR object.
     */
    constructor(client: XMLHttpRequest);
    /**
     * @type {XMLHttpRequest}
     */
    client: XMLHttpRequest;
}

/**
 * @module ol/obj
 */
/**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */
declare function clear$2(object: {
    [x: string]: unknown;
}): void;
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
declare function isEmpty(object: any): boolean;

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @param {number} [stride] Stride (default is `dimension`).
 * @return {Array<number>} Output array of coordinate values.
 */
declare function fromEPSG4326(input: Array<number>, output?: Array<number>, dimension?: number, stride?: number): Array<number>;
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @param {number} [stride] Stride (default is `dimension`).
 * @return {Array<number>} Output array of coordinate values.
 */
declare function toEPSG4326(input: Array<number>, output?: Array<number>, dimension?: number, stride?: number): Array<number>;
/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
declare const RADIUS$1: number;
/**
 * @const
 * @type {number}
 */
declare const HALF_SIZE: number;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */
declare const EXTENT$1: Extent$1;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */
declare const WORLD_EXTENT: Extent$1;
/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
declare const MAX_SAFE_Y: number;
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
declare const PROJECTIONS$1: Array<Projection>;

/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
declare const RADIUS: number;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
declare const EXTENT: Extent$1;
/**
 * @const
 * @type {number}
 */
declare const METERS_PER_UNIT: number;
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
declare const PROJECTIONS: Array<Projection>;

/**
 * @return {boolean} Proj4 has been registered.
 */
declare function isRegistered(): boolean;
/**
 * Unsets the shared proj4 previously set with register.
 */
declare function unregister(): void;
/**
 * Make projections defined in proj4 (with `proj4.defs()`) available in
 * OpenLayers. Requires proj4 >= 2.8.0.
 *
 * This function should be called whenever changes are made to the proj4
 * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be
 * modified by this function.
 *
 * @param {import("proj4")} proj4 Proj4.
 * @api
 */
declare function register(proj4: typeof proj4): void;
/**
 * Set the lookup function for getting proj4 definitions given an EPSG code.
 * By default, the {@link module:ol/proj/proj4.fromEPSGCode} function uses the
 * epsg.io website for proj4 definitions.  This can be changed by providing a
 * different lookup function.
 *
 * @param {function(number):Promise<string>} func The lookup function.
 * @api
 */
declare function setEPSGLookup(func: (arg0: number) => Promise<string>): void;
/**
 * Get the current EPSG lookup function.
 *
 * @return {function(number):Promise<string>} The EPSG lookup function.
 */
declare function getEPSGLookup(): (arg0: number) => Promise<string>;
/**
 * Get a projection from an EPSG code.  This function fetches the projection
 * definition from the epsg.io website, registers this definition for use with
 * proj4, and returns a configured projection.  You must call import proj4 and
 * call {@link module:ol/proj/proj4.register} before using this function.
 *
 * If the projection definition is already registered with proj4, it will not
 * be fetched again (so it is ok to call this function multiple times with the
 * same code).
 *
 * @param {number|string} code The EPSG code (e.g. 4326 or 'EPSG:4326').
 * @return {Promise<Projection>} The projection.
 * @api
 */
declare function fromEPSGCode(code: number | string): Promise<Projection>;
/**
 * Generate an EPSG lookup function which uses the MapTiler Coordinates API to find projection
 * definitions which do not require proj4 to be configured to handle `+nadgrids` parameters.
 * Call {@link module:ol/proj/proj4.setEPSGLookup} use the function for lookups
 * `setEPSGLookup(epsgLookupMapTiler('{YOUR_MAPTILER_API_KEY_HERE}'))`.
 *
 * @param {string} key MapTiler API key.  Get your own API key at https://www.maptiler.com/cloud/.
 * @return {function(number):Promise<string>} The EPSG lookup function.
 * @api
 */
declare function epsgLookupMapTiler(key: string): (arg0: number) => Promise<string>;

/**
 * Clear the projections cache.
 */
declare function clear$1(): void;
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default|null} The projection (if cached).
 */
declare function get$1(code: string): Projection | null;
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
declare function add$1(code: string, projection: Projection): void;

/**
 * Clear the transform cache.
 */
declare function clear(): void;
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
declare function add(source: Projection, destination: Projection, transformFn: TransformFunction): void;
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
declare function remove(source: Projection, destination: Projection): TransformFunction;
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|null} The transform function (if found).
 */
declare function get(sourceCode: string, destinationCode: string): TransformFunction | null;

/**
 * @param {string} code The projection code.
 * @return {UTMZone|null} The UTM zone info (or null if not UTM).
 */
declare function zoneFromCode(code: string): UTMZone | null;
/**
 * @param {string} code The projection code.
 * @return {import('./Projection.js').default|null} A projection or null if unable to create one.
 */
declare function makeProjection(code: string): Projection | null;
/**
 * @param {import('./Projection.js').default} projection The projection.
 * @return {import('../proj.js').Transforms|null} The transforms lookup or null if unable to handle projection.
 */
declare function makeTransforms(projection: Projection): Transforms | null;
type UTMZone = {
    /**
     * The zone number (1 - 60).
     */
    number: number;
    /**
     * The northern hemisphere.
     */
    north: boolean;
};

declare class RenderBox extends Disposable {
    /**
     * @param {string} className CSS class name.
     */
    constructor(className: string);
    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */
    private geometry_;
    /**
     * @type {HTMLDivElement}
     * @private
     */
    private element_;
    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    private map_;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    private startPixel_;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    private endPixel_;
    /**
     * @private
     */
    private render_;
    /**
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(map: Map | null): void;
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
    setPixels(startPixel: Pixel, endPixel: Pixel): void;
    /**
     * Creates or updates the cached geometry.
     */
    createOrUpdateGeometry(): void;
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
    getGeometry(): Polygon$1;
}
//# sourceMappingURL=Box.d.ts.map

declare class CanvasBuilder extends VectorContext {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance: number, maxExtent: Extent$1, resolution: number, pixelRatio: number);
    /**
     * @protected
     * @type {number}
     */
    protected tolerance: number;
    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */
    protected maxExtent: Extent$1;
    /**
     * @protected
     * @type {number}
     */
    protected pixelRatio: number;
    /**
     * @protected
     * @type {number}
     */
    protected maxLineWidth: number;
    /**
     * @protected
     * @const
     * @type {number}
     */
    protected resolution: number;
    /**
     * @private
     * @type {Array<*>}
     */
    private beginGeometryInstruction1_;
    /**
     * @private
     * @type {Array<*>}
     */
    private beginGeometryInstruction2_;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    private bufferedMaxExtent_;
    /**
     * @protected
     * @type {Array<*>}
     */
    protected instructions: Array<any>;
    /**
     * @protected
     * @type {Array<number>}
     */
    protected coordinates: Array<number>;
    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */
    private tmpCoordinate_;
    /**
     * @protected
     * @type {Array<*>}
     */
    protected hitDetectionInstructions: Array<any>;
    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */
    protected state: FillStrokeState;
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */
    protected applyPixelRatio(dashArray: Array<number>): Array<number>;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
    protected appendFlatPointCoordinates(flatCoordinates: Array<number>, stride: number): number;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
    protected appendFlatLineCoordinates(flatCoordinates: Array<number>, offset: number, end: number, stride: number, closed: boolean, skipFirst: boolean): number;
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
    drawCustomCoordinates_(flatCoordinates: Array<number>, offset: number, ends: Array<number>, stride: number, builderEnds: Array<number>): number;
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} index Render order index
     */
    protected beginGeometry(geometry: Geometry$1 | RenderFeature, feature: FeatureLike, index: number): void;
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish(): SerializableInstructions;
    /**
     * Reverse the hit detection instructions.
     */
    reverseHitDetectionInstructions(): void;
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
    createFill(state: FillStrokeState): Array<any>;
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    applyStroke(state: FillStrokeState): void;
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
    createStroke(state: FillStrokeState): Array<any>;
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
    updateFillStyle(state: FillStrokeState, createFill: (this: CanvasBuilder, arg1: FillStrokeState) => Array<any>): void;
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
    updateStrokeStyle(state: FillStrokeState, applyStroke: (this: CanvasBuilder, arg1: FillStrokeState) => void): void;
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    endGeometry(feature: FeatureLike): void;
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
    protected getBufferedMaxExtent(): Extent$1;
}
//# sourceMappingURL=Builder.d.ts.map

declare class CanvasImageBuilder extends CanvasBuilder {
    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    private hitDetectionImage_;
    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    private image_;
    /**
     * @private
     * @type {number|undefined}
     */
    private imagePixelRatio_;
    /**
     * @private
     * @type {number|undefined}
     */
    private anchorX_;
    /**
     * @private
     * @type {number|undefined}
     */
    private anchorY_;
    /**
     * @private
     * @type {number|undefined}
     */
    private height_;
    /**
     * @private
     * @type {number|undefined}
     */
    private opacity_;
    /**
     * @private
     * @type {number|undefined}
     */
    private originX_;
    /**
     * @private
     * @type {number|undefined}
     */
    private originY_;
    /**
     * @private
     * @type {boolean|undefined}
     */
    private rotateWithView_;
    /**
     * @private
     * @type {number|undefined}
     */
    private rotation_;
    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */
    private scale_;
    /**
     * @private
     * @type {number|undefined}
     */
    private width_;
    /**
     * @private
     * @type {import('../../style/Style.js').DeclutterMode}
     */
    private declutterMode_;
    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    private declutterImageWithText_;
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    override setImageStyle(imageStyle: ImageStyle, sharedData?: any): void;
}
//# sourceMappingURL=ImageBuilder.d.ts.map

/**
 * @type {Array<Instruction>}
 */
declare const fillInstruction: Array<Instruction>;
/**
 * @type {Array<Instruction>}
 */
declare const strokeInstruction: Array<Instruction>;
/**
 * @type {Array<Instruction>}
 */
declare const beginPathInstruction: Array<Instruction>;
/**
 * @type {Array<Instruction>}
 */
declare const closePathInstruction: Array<Instruction>;

type Instruction = number;
declare namespace Instruction {
    let BEGIN_GEOMETRY: number;
    let BEGIN_PATH: number;
    let CIRCLE: number;
    let CLOSE_PATH: number;
    let CUSTOM: number;
    let DRAW_CHARS: number;
    let DRAW_IMAGE: number;
    let END_GEOMETRY: number;
    let FILL: number;
    let MOVE_TO_LINE_TO: number;
    let SET_FILL_STYLE: number;
    let SET_STROKE_STYLE: number;
    let STROKE: number;
}

declare class CanvasLineStringBuilder extends CanvasBuilder {
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */
    private drawFlatCoordinates_;
}
//# sourceMappingURL=LineStringBuilder.d.ts.map

declare class CanvasPolygonBuilder extends CanvasBuilder {
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    private drawFlatCoordinatess_;
    /**
     * @private
     */
    private setFillStrokeStyles_;
}
//# sourceMappingURL=PolygonBuilder.d.ts.map

declare class CanvasTextBuilder extends CanvasBuilder {
    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */
    private labels_;
    /**
     * @private
     * @type {string|Array<string>}
     */
    private text_;
    /**
     * @private
     * @type {number}
     */
    private textOffsetX_;
    /**
     * @private
     * @type {number}
     */
    private textOffsetY_;
    /**
     * @private
     * @type {boolean|undefined}
     */
    private textRotateWithView_;
    /**
     * @private
     * @type {boolean|undefined}
     */
    private textKeepUpright_;
    /**
     * @private
     * @type {number}
     */
    private textRotation_;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    private textFillState_;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    fillStates: {
        [x: string]: FillState;
    };
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    private textStrokeState_;
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    strokeStates: {
        [x: string]: StrokeState;
    };
    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */
    private textState_;
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    textStates: {
        [x: string]: TextState;
    };
    /**
     * @private
     * @type {string}
     */
    private textKey_;
    /**
     * @private
     * @type {string}
     */
    private fillKey_;
    /**
     * @private
     * @type {string}
     */
    private strokeKey_;
    /**
     * @private
     * @type {import('../../style/Style.js').DeclutterMode}
     */
    private declutterMode_;
    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    private declutterImageWithText_;
    /**
     * @private
     */
    private saveTextStates_;
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
    private drawChars_;
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    override setTextStyle(textStyle: Text$1, sharedData?: any): void;
}

/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent in render projection.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} [squaredTolerance] Squared tolerance.
 * @param {import("../../proj/Projection.js").default} [projection] Render projection.
 * @return {ImageData} Hit detection image data.
 */
declare function createHitDetectionImageData(size: Size, transforms: Array<Transform>, features: Array<FeatureLike>, styleFunction: StyleFunction | undefined, extent: Extent$1, resolution: number, rotation: number, squaredTolerance?: number, projection?: Projection): ImageData;
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<F>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<F>} Features.
 * @template {import("../../Feature.js").FeatureLike} F
 */
declare function hitDetect<F extends FeatureLike>(pixel: Pixel, features: Array<F>, imageData: ImageData): Array<F>;
declare const HIT_DETECT_RESOLUTION: 0.5;

/**
 * This function adapts a rule evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
declare function rulesToStyleFunction(rules: Array<Rule>): StyleFunction;
/**
 * This function adapts a style evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
declare function flatStylesToStyleFunction(flatStyles: Array<FlatStyle$1>): StyleFunction;
/**
 * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator
 */
/**
 * @typedef {Object} CompiledRule
 * @property {ExpressionEvaluator} filter The compiled filter evaluator.
 * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.
 */
/**
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @param {ParsingContext} context The parsing context.
 * @return {RuleSetEvaluator} The evaluator function.
 */
declare function buildRuleSet(rules: Array<Rule>, context: ParsingContext): RuleSetEvaluator;
/**
 * @typedef {function(EvaluationContext):Style|null} StyleEvaluator
 */
/**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @param {ParsingContext} context The parsing context.
 * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by
 * this function will be reused between invocations.
 */
declare function buildStyle(flatStyle: FlatStyle, context: ParsingContext): StyleEvaluator;
type FlatStyle = FlatStyle$1;
type ParsingContext = ParsingContext$1;
type EvaluationContext = EvaluationContext$1;
type RuleSetEvaluator = (arg0: EvaluationContext) => Array<Style$2>;
type StyleEvaluator = (arg0: EvaluationContext) => Style$2 | null;

/**
 * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes
 * @return {number} Cumulated size of all attributes
 */
declare function getCustomAttributesSize(customAttributes: AttributeDefinitions): number;
/**
 * Render instructions for lines are structured like so:
 * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]
 * @param {import("./MixedGeometryBatch.js").PointGeometryBatch} batch Point geometry batch
 * @param {Float32Array} renderInstructions Render instructions
 * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes
 * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
 * @return {Float32Array} Generated render instructions
 */
declare function generatePointRenderInstructions(batch: PointGeometryBatch, renderInstructions: Float32Array, customAttributes: AttributeDefinitions, transform: Transform): Float32Array;
/**
 * Render instructions for lines are structured like so:
 * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]
 * @param {import("./MixedGeometryBatch.js").LineStringGeometryBatch} batch Line String geometry batch
 * @param {Float32Array} renderInstructions Render instructions
 * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes
 * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
 * @return {Float32Array} Generated render instructions
 */
declare function generateLineStringRenderInstructions(batch: LineStringGeometryBatch, renderInstructions: Float32Array, customAttributes: AttributeDefinitions, transform: Transform): Float32Array;
/**
 * Render instructions for polygons are structured like so:
 * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]
 * @param {import("./MixedGeometryBatch.js").PolygonGeometryBatch} batch Polygon geometry batch
 * @param {Float32Array} renderInstructions Render instructions
 * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes
 * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
 * @return {Float32Array} Generated render instructions
 */
declare function generatePolygonRenderInstructions(batch: PolygonGeometryBatch, renderInstructions: Float32Array, customAttributes: AttributeDefinitions, transform: Transform): Float32Array;

/**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */
declare function writePointFeatureToBuffers(instructions: Float32Array, elementIndex: number, vertexBuffer: Float32Array, indexBuffer: Uint32Array, customAttributesSize: number, bufferPositions?: BufferPositions): BufferPositions;
/**
 * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next
 * segment, in order to be able to offset the vertices correctly in the shader.
 * Join angles are between 0 and 2PI.
 * This also computes the length of the current segment and the sum of the join angle tangents in order
 * to store this information on each subsequent segment along the line. This is necessary to correctly render dashes
 * and symbols along the line.
 *
 *   pB (before)                          pA (after)
 *    X             negative             X
 *     \             offset             /
 *      \                              /
 *       \   join              join   /
 *        \ angle 0          angle 1 /
 *         \←---                ←---/      positive
 *          \   ←--          ←--   /        offset
 *           \     ↑       ↓      /
 *            X────┴───────┴─────X
 *            p0                  p1
 *
 * @param {Float32Array} instructions Array of render instructions for lines.s
 * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.
 * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.
 * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)
 * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {Array<number>} customAttributes Array of custom attributes value
 * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions
 * @param {number} currentLength Cumulated length of segments processed so far
 * @param {number} currentAngleTangentSum Cumulated tangents of the join angles processed so far
 * @return {{length: number, angle: number}} Cumulated length with the newly processed segment (in world units), new sum of the join angle tangents
 * @private
 */
declare function writeLineSegmentToBuffers(instructions: Float32Array, segmentStartIndex: number, segmentEndIndex: number, beforeSegmentIndex: number | null, afterSegmentIndex: number | null, vertexArray: Array<number>, indexArray: Array<number>, customAttributes: Array<number>, toWorldTransform: Transform, currentLength: number, currentAngleTangentSum: number): {
    length: number;
    angle: number;
};
/**
 * Pushes several triangles to form a polygon, including holes
 * @param {Float32Array} instructions Array of render instructions for lines.
 * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @return {number} Next polygon instructions index
 * @private
 */
declare function writePolygonTrianglesToBuffers(instructions: Float32Array, polygonStartIndex: number, vertexArray: Array<number>, indexArray: Array<number>, customAttributesSize: number): number;
/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */
declare function getBlankImageData(): ImageData;
/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */
declare function colorEncodeId(id: number, array?: Array<number>): Array<number>;
/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */
declare function colorDecodeId(color: Array<number>): number;
declare const LINESTRING_ANGLE_COSINE_CUTOFF: 0.985;
/**
 * An object holding positions both in an index and a vertex buffer.
 */
type BufferPositions = {
    /**
     * Position in the vertex buffer
     */
    vertexPosition: number;
    /**
     * Position in the index buffer
     */
    indexPosition: number;
};

/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
declare class CompositeMapRenderer extends MapRenderer {
    /**
     * @private
     * @type {import("../events.js").EventsKey}
     */
    private fontChangeListenerKey_;
    /**
     * @private
     * @type {HTMLDivElement}
     */
    private element_;
    /**
     * @private
     * @type {Array<HTMLElement>}
     */
    private children_;
    /**
     * @private
     * @type {boolean}
     */
    private renderedVisible_;
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
     */
    declutter(frameState: FrameState, layerStates: Array<State$1>): void;
}
//# sourceMappingURL=Composite.d.ts.map

type TileType = VectorRenderTile;
/**
 * @typedef {import("../VectorRenderTile").default} TileType
 */
/**
 * @extends {BaseTileRepresentation<TileType>}
 */
declare class TileGeometry extends BaseTileRepresentation<VectorRenderTile> {
    /**
     * @param {import("./BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options The tile texture options.
     * @param {Array<import("../render/webgl/VectorStyleRenderer.js").default>} styleRenderers Array of vector style renderers
     */
    constructor(options: TileRepresentationOptions<TileType>, styleRenderers: Array<VectorStyleRenderer>);
    /**
     * @private
     */
    private batch_;
    /**
     * @private
     */
    private styleRenderers_;
    /**
     * @type {Array<import("../render/webgl/VectorStyleRenderer.js").WebGLBuffers>}
     */
    buffers: Array<WebGLBuffers>;
    /**
     * Each geometry tile also has a mask which consisted of a quad (two triangles); this mask is intended to
     * be rendered to an offscreen buffer, and be used to correctly mask tiles according to their zoom level
     * during rendering
     */
    maskVertices: WebGLArrayBuffer;
    /**
     * @private
     */
    private generateMaskBuffer_;
}

type VectorStyle = VectorStyle$2;
type Options$5 = {
    /**
     * Vector style as literal style or shaders; can also accept an array of styles
     */
    style: VectorStyle | Array<VectorStyle>;
    /**
     * Style variables. Each variable must hold a literal value (not
     * an expression). These variables can be used as {@link import ("../../expr/expression.js").ExpressionValue expressions} in the styles properties
     * using the `['var', 'varName']` operator.
     */
    variables?: {
        [x: string]: string | number | boolean | number[];
    } | undefined;
    /**
     * Setting this to true will provide a slight performance boost, but will
     * prevent all hit detection on the layer.
     */
    disableHitDetection?: boolean | undefined;
    /**
     * The vector tile cache size.
     */
    cacheSize?: number | undefined;
};
type LayerType = BaseTileLayer<any, any>;
/**
 * @typedef {import('../../render/webgl/VectorStyleRenderer.js').VectorStyle} VectorStyle
 */
/**
 * @typedef {Object} Options
 * @property {VectorStyle|Array<VectorStyle>} style Vector style as literal style or shaders; can also accept an array of styles
 * @property {import('../../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not
 * an expression). These variables can be used as {@link import("../../expr/expression.js").ExpressionValue expressions} in the styles properties
 * using the `['var', 'varName']` operator.
 * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will
 * prevent all hit detection on the layer.
 * @property {number} [cacheSize=512] The vector tile cache size.
 */
/**
 * @typedef {import("../../layer/BaseTile.js").default} LayerType
 */
/**
 * @classdesc
 * WebGL renderer for vector tile layers. Experimental.
 * @extends {WebGLBaseTileLayerRenderer<LayerType>}
 */
declare class WebGLVectorTileLayerRenderer extends WebGLBaseTileLayerRenderer<BaseTileLayer<any, any>, any, any> {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} options Options.
     */
    constructor(tileLayer: LayerType, options: Options$5);
    /**
     * @type {boolean}
     * @private
     */
    private hitDetectionEnabled_;
    /**
     * @type {Array<VectorStyle>}
     * @private
     */
    private styles_;
    /**
     * @type {import('../../style/flat.js').StyleVariables}
     * @private
     */
    private styleVariables_;
    /**
     * @type {Array<VectorStyleRenderer>}
     * @private
     */
    private styleRenderers_;
    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */
    private currentFrameStateTransform_;
    /**
     * @private
     */
    private tmpTransform_;
    /**
     * @private
     */
    private tmpMat4_;
    /**
     * @type {WebGLRenderTarget}
     * @private
     */
    private tileMaskTarget_;
    /**
     * @private
     */
    private tileMaskIndices_;
    /**
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     * @private
     */
    private tileMaskAttributes_;
    /**
     * @type {WebGLProgram}
     * @private
     */
    private tileMaskProgram_;
    /**
     * @param {Options} options Options.
     * @override
     */
    override reset(options: Options$5): void;
    /**
     * @param {Options} options Options.
     * @private
     */
    private applyOptions_;
    /**
     * @private
     */
    private createRenderers_;
    /**
     * @private
     */
    private initTileMask_;
    /**
     * @override
     */
    override createTileRepresentation(options: any): TileGeometry;
    /**
     * @override
     */
    override beforeTilesRender(frameState: any, tilesWithAlpha: any): void;
    /**
     * @override
     */
    override beforeTilesMaskRender(frameState: any): boolean;
    /**
     * @override
     */
    override renderTileMask(tileRepresentation: any, tileZ: any, extent: any, depth: any): void;
    /**
     * @param {number} alpha Alpha value of the tile
     * @param {import("../../extent.js").Extent} renderExtent Which extent to restrict drawing to
     * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which tile geometries are expressed
     * @param {number} tileZ Tile zoom level
     * @param {number} depth Depth of the tile
     * @private
     */
    private applyUniforms_;
    /**
     * @override
     */
    override renderTile(tileRepresentation: any, tileTransform: any, frameState: any, renderExtent: any, tileResolution: any, tileSize: any, tileOrigin: any, tileExtent: any, depth: any, gutter: any, alpha: any): void;
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(frameState: FrameState): void;
}

type TileGetter = (arg0: number, arg1: number, arg2: number, arg3: number) => DataTile;
type Options$4 = {
    /**
     * Source projection.
     */
    sourceProj: Projection;
    /**
     * Source tile grid.
     */
    sourceTileGrid: TileGrid;
    /**
     * Target projection.
     */
    targetProj: Projection;
    /**
     * Target tile grid.
     */
    targetTileGrid: TileGrid;
    /**
     * Coordinate of the tile.
     */
    tileCoord: TileCoord;
    /**
     * Coordinate of the tile wrapped in X.
     */
    wrappedTileCoord?: TileCoord | undefined;
    /**
     * Pixel ratio.
     */
    pixelRatio: number;
    /**
     * Gutter of the source tiles.
     */
    gutter: number;
    /**
     * Function returning source tiles (z, x, y, pixelRatio).
     */
    getTileFunction: TileGetter;
    /**
     * Use interpolated values when resampling.  By default,
     * the nearest neighbor is used when resampling.
     */
    interpolate?: boolean | undefined;
    /**
     * Acceptable reprojection error (in px).
     */
    errorThreshold?: number | undefined;
    /**
     * A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     */
    transition?: number | undefined;
    /**
     * Source transform matrix.
     */
    transformMatrix?: number[] | undefined;
    /**
     * Render reprojection edges.
     */
    renderEdges?: boolean | undefined;
};
/**
 * @typedef {function(number, number, number, number) : import("../DataTile.js").default} TileGetter
 */
/**
 * @typedef {Object} TileOffset
 * @property {DataTile} tile Tile.
 * @property {number} offset Offset.
 */
/**
 * @typedef {Object} Options
 * @property {import("../proj/Projection.js").default} sourceProj Source projection.
 * @property {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
 * @property {import("../proj/Projection.js").default} targetProj Target projection.
 * @property {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
 * @property {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
 * @property {import("../tilecoord.js").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.
 * @property {number} pixelRatio Pixel ratio.
 * @property {number} gutter Gutter of the source tiles.
 * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {number} [errorThreshold] Acceptable reprojection error (in px).
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {import("../transform.js").Transform} [transformMatrix] Source transform matrix.
 * @property {boolean} [renderEdges] Render reprojection edges.
 */
/**
 * @classdesc
 * Class encapsulating single reprojected data tile.
 * See {@link module:ol/source/DataTile~DataTileSource}.
 *
 */
declare class ReprojDataTile extends DataTile {
    /**
     * @param {Options} options Tile options.
     */
    constructor(options: Options$4);
    /**
     * @private
     * @type {boolean | Array<number>}
     */
    private renderEdges_;
    /**
     * @private
     * @type {number}
     */
    private pixelRatio_;
    /**
     * @private
     * @type {number}
     */
    private gutter_;
    /**
     * @type {import("../DataTile.js").Data}
     * @private
     */
    private reprojData_;
    /**
     * @type {Error}
     * @private
     */
    private reprojError_;
    /**
     * @type {import('../size.js').Size}
     * @private
     */
    private reprojSize_;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    private sourceTileGrid_;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    private targetTileGrid_;
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    private wrappedTileCoord_;
    /**
     * @private
     * @type {!Array<TileOffset>}
     */
    private sourceTiles_;
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    private sourcesListenerKeys_;
    /**
     * @private
     * @type {number}
     */
    private sourceZ_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private clipExtent_;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    private triangulation_;
    /**
     * @private
     */
    private reproject_;
    /**
     * @private
     */
    private unlistenSources_;
}

type FunctionType = (arg0: Extent$1, arg1: number, arg2: number) => ImageWrapper;
/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../Image.js").default} FunctionType
 */
/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */
declare class ReprojImage extends ImageWrapper {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent.
     * @param {number} targetResolution Target resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {FunctionType} getImageFunction
     *     Function returning source images (extent, resolution, pixelRatio).
     * @param {boolean} interpolate Use linear interpolation when resampling.
     */
    constructor(sourceProj: Projection, targetProj: Projection, targetExtent: Extent$1, targetResolution: number, pixelRatio: number, getImageFunction: FunctionType, interpolate: boolean);
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    private targetProj_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private maxSourceExtent_;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    private triangulation_;
    /**
     * @private
     * @type {number}
     */
    private targetResolution_;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    private targetExtent_;
    /**
     * @private
     * @type {import("../Image.js").default}
     */
    private sourceImage_;
    /**
     * @private
     * @type {number}
     */
    private sourcePixelRatio_;
    /**
     * @private
     * @type {boolean}
     */
    private interpolate_;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    private canvas_;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    private sourceListenerKey_;
    /**
     * @return {HTMLCanvasElement} Image.
     * @override
     */
    override getImage(): HTMLCanvasElement;
    /**
     * @return {import("../proj/Projection.js").default} Projection.
     */
    getProjection(): Projection;
    /**
     * @private
     */
    private reproject_;
    /**
     * @private
     */
    private unlistenSource_;
}

/**
 * Single triangle; consists of 3 source points and 3 target points.
 */
type Triangle = {
    /**
     * Source.
     */
    source: Array<Coordinate>;
    /**
     * Target.
     */
    target: Array<Coordinate>;
};
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
declare class Triangulation {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
     * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
     * @param {number} errorThreshold Acceptable error (in source units).
     * @param {?number} destinationResolution The (optional) resolution of the destination.
     * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
     */
    constructor(sourceProj: Projection, targetProj: Projection, targetExtent: Extent$1, maxSourceExtent: Extent$1, errorThreshold: number, destinationResolution: number | null, sourceMatrix?: Transform);
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    private sourceProj_;
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    private targetProj_;
    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */
    private transformInv_;
    /**
     * @type {import("../extent.js").Extent}
     * @private
     */
    private maxSourceExtent_;
    /**
     * @type {number}
     * @private
     */
    private errorThresholdSquared_;
    /**
     * @type {Array<Triangle>}
     * @private
     */
    private triangles_;
    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */
    private wrapsXInSource_;
    /**
     * @type {boolean}
     * @private
     */
    private canWrapXInSource_;
    /**
     * @type {?number}
     * @private
     */
    private sourceWorldWidth_;
    /**
     * @type {?number}
     * @private
     */
    private targetWorldWidth_;
    /**
     * Adds triangle to the triangulation.
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @private
     */
    private addTriangle_;
    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
    private addQuad_;
    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */
    calculateSourceExtent(): Extent$1;
    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */
    getTriangles(): Array<Triangle>;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
declare function calculateSourceResolution(sourceProj: Projection, targetProj: Projection, targetCenter: Coordinate, targetResolution: number): number;
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
declare function calculateSourceExtentResolution(sourceProj: Projection, targetProj: Projection, targetExtent: Extent$1, targetResolution: number): number;
/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [clipExtent] Clip extent.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.
 * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
declare function render$1(width: number, height: number, pixelRatio: number, sourceResolution: number, sourceExtent: Extent$1, targetResolution: number, targetExtent: Extent$1, triangulation: Triangulation, sources: Array<ImageExtent$1>, gutter: number, renderEdges?: boolean, interpolate?: boolean, drawSingle?: boolean, clipExtent?: boolean): HTMLCanvasElement;
/**
 * @type {Array<HTMLCanvasElement>}
 */
declare const canvasPool: Array<HTMLCanvasElement>;
type ImageExtent$1 = {
    /**
     * Extent.
     */
    extent: Extent$1;
    /**
     * Clip extent.
     */
    clipExtent?: Extent$1 | undefined;
    /**
     * Image.
     */
    image: ImageLike;
};

/**
 * @module ol/reproj/common
 */
/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
declare const ERROR_THRESHOLD: number;

/**
 * Create an html canvas element and returns its webgl context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings
 * @return {WebGLRenderingContext} The context.
 */
declare function createCanvasContextWebGL(width?: number, height?: number, canvasPool?: Array<HTMLCanvasElement | OffscreenCanvas>, settings?: WebGLContextAttributes): WebGLRenderingContext;
/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {WebGLRenderingContext} gl Context.
 */
declare function releaseGLCanvas(gl: WebGLRenderingContext): void;
/**
 * @typedef {Object} ImageExtent
 * @property {import("../extent.js").Extent} extent Extent.
 * @property {import("../extent.js").Extent} [clipExtent] Clip extent.
 * @property {WebGLTexture} texture Texture.
 * @property {number} width Width of texture.
 * @property {number} height Height of texture.
 */
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {WebGLRenderingContext} gl the context to render in.
 * @param {number} width_ Width of the canvas.
 * @param {number} height_ Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {number} targetResolution Target resolution.
 * @param {import("../extent.js").Extent} targetExtent Target extent (tile).
 * @param {import("../reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE
 * TODO: Allow setting renderEdges value in the data as this is done in "data-space".
 * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.
 * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.
 */
declare function render(gl: WebGLRenderingContext, width_: number, height_: number, pixelRatio: number, sourceResolution: number, targetResolution: number, targetExtent: Extent$1, triangulation: Triangulation, sources: Array<ImageExtent>, gutter: number, dataType: number, renderEdges?: boolean | Array<number>, interpolate?: boolean, drawSingle?: boolean): {
    framebuffer: WebGLFramebuffer;
    width: number;
    height: number;
    texture: WebGLTexture;
};
/**
 * @type {Array<HTMLCanvasElement | OffscreenCanvas>}
 */
declare const canvasGLPool: Array<HTMLCanvasElement | OffscreenCanvas>;
type ImageExtent = {
    /**
     * Extent.
     */
    extent: Extent$1;
    /**
     * Clip extent.
     */
    clipExtent?: Extent$1 | undefined;
    /**
     * Texture.
     */
    texture: WebGLTexture;
    /**
     * Width of texture.
     */
    width: number;
    /**
     * Height of texture.
     */
    height: number;
};

type AuthConfig = {
    /**
     * The URL to get the authentication token.
     */
    tokenUrl?: string | undefined;
    /**
     * The client ID.
     */
    clientId: string;
    /**
     * The client secret.
     */
    clientSecret: string;
};
type Evalscript = {
    /**
     * The setup function.
     */
    setup: Setup;
    /**
     * The function to transform input samples into output values.
     */
    evaluatePixel: EvaluatePixel;
    /**
     * Optional function to adjust the output bands.
     */
    updateOutput?: UpdateOutput | undefined;
    /**
     * Optional function to update the output metadata.
     */
    updateOutputMetadata?: UpdateOutputMetadata | undefined;
    /**
     * Optional function called before processing.
     */
    preProcessScenes?: Collections | undefined;
    /**
     * The Evalscript version.
     */
    version?: string | undefined;
};
type Setup = () => SetupResult;
type EvaluatePixel = (arg0: Sample | Array<Sample>, arg1: Scenes, arg2: InputMetadata, arg3: CustomData, arg4: OutputMetadata) => OutputValues | Array<number> | void;
type UpdateOutput = (arg0: {
    [x: string]: UpdatedOutputDescription;
}) => void;
type UpdateOutputMetadata = (arg0: Scenes, arg1: InputMetadata, arg2: OutputMetadata) => void;
type SetupResult = {
    /**
     * Description of the input data.
     */
    input: Array<string> | Array<InputDescription>;
    /**
     * Description of the output data.
     */
    output: OutputDescription | Array<OutputDescription>;
    /**
     * Control how samples from input scenes are composed.
     */
    mosaicking?: "SIMPLE" | "ORBIT" | "TILE" | undefined;
};
type InputDescription = {
    /**
     * Input band identifiers.
     */
    bands: Array<string>;
    /**
     * Input band units.
     */
    units?: string | string[] | undefined;
    /**
     * Properties to include in the input metadata.
     */
    metadata?: string[] | undefined;
};
type OutputDescription = {
    /**
     * Output identifier.
     */
    id?: string | undefined;
    /**
     * Number of output bands.
     */
    bands: number;
    /**
     * Output sample type.
     */
    sampleType?: SampleType | undefined;
    /**
     * Output nodata value.
     */
    nodataValue?: number | undefined;
};
type UpdatedOutputDescription = {
    /**
     * Number of output bands.
     */
    bands: number;
};
type SampleType = "INT8" | "UINT8" | "INT16" | "UINT16" | "FLOAT32" | "AUTO";
type Sample = {
    [x: string]: number;
};
type Collections = {
    /**
     * For 'ORBIT' mosaicking, this will be the start of the search interval.
     */
    from?: string | undefined;
    /**
     * For 'ORBIT' mosaicking, this will be the end of the search interval.
     */
    to?: string | undefined;
    /**
     * The scenes in the collection.
     */
    scenes: Scenes;
};
type Scenes = {
    /**
     * Information about scenes included in the tile when 'mosaicking' is 'ORBIT'.
     */
    orbit?: Orbit[] | undefined;
    /**
     * Information about scenes included in the tile when 'mosaicking' is 'TILE'.
     */
    tiles?: Tile[] | undefined;
};
type Orbit = {
    /**
     * The earliest date for all scenes included in the tile.
     */
    dateFrom: string;
    /**
     * The latest date for scenes included in the tile.
     */
    dateTo: string;
    /**
     * Metadata for each tile.
     */
    tiles: any[];
};
type Tile = {
    /**
     * The date of scene used in the tile.
     */
    date: string;
    /**
     * The estimated percentage of pixels obscured by clouds in the scene.
     */
    cloudCoverage: number;
    /**
     * The path to the data in storage.
     */
    dataPath: string;
    /**
     * The internal identifier for the scene.
     */
    shId: number;
};
type InputMetadata = {
    /**
     * The version of the service used for processing.
     */
    serviceVersion: string;
    /**
     * The factor used to convert digital number (DN) values to reflectance.
     */
    normalizationFactor: number;
};
type CustomData = {
    [x: string]: unknown;
};
type OutputMetadata = {
    /**
     * Arbitrary user data.
     */
    userData: any;
};
type OutputValues = {
    [x: string]: number[];
};
type ProcessRequestInputDataItem = {
    /**
     * The type of the input data.
     */
    type?: string | undefined;
    /**
     * The identifier of the input data.
     */
    id?: string | undefined;
    /**
     * The filter to apply to the input data.
     */
    dataFilter?: DataFilter | undefined;
    /**
     * The processing to apply to the input data.
     */
    processing?: {
        [x: string]: unknown;
    } | undefined;
};
type DataFilter = {
    /**
     * The data time range.
     */
    timeRange?: TimeRange | undefined;
    /**
     * The maximum cloud coverage (0-100).
     */
    maxCloudCoverage?: number | undefined;
};
type TimeRange = {
    /**
     * The start time (inclusive).
     */
    from?: string | undefined;
    /**
     * The end time (inclusive).
     */
    to?: string | undefined;
};
type Options$3 = {
    /**
     * The authentication configuration with `clientId` and `clientSecret` or an access token.
     * See [Sentinel Hub authentication](https://docs.sentinel-hub.com/api/latest/api/overview/authentication/)
     * for details.  If not provided in the constructor, the source will not be rendered until {@link module :ol/source/SentinelHub~SentinelHub#setAuth}is called.
     */
    auth?: string | AuthConfig | undefined;
    /**
     * The input data configuration.  If not provided in the constructor,
     * the source will not be rendered until {@link module :ol/source/SentinelHub~SentinelHub#setData} is called.
     */
    data?: ProcessRequestInputDataItem[] | undefined;
    /**
     * The process applied to the input data.  If not provided in the constructor,
     * the source will not be rendered until {@link module :ol/source/SentinelHub~SentinelHub#setEvalscript} is called.  See the
     * `setEvalscript` documentation for details on the restrictions when passing process functions.
     */
    evalscript?: string | Evalscript | undefined;
    /**
     * The pixel width and height of the source tiles.
     */
    tileSize?: number | Size | undefined;
    /**
     * The Sentinel Hub Processing API URL.
     */
    url?: string | undefined;
    /**
     * Projection. Default is the view projection.
     */
    projection?: ProjectionLike;
    /**
     * Allow the attributions to be collapsed.
     */
    attributionsCollapsible?: boolean | undefined;
    /**
     * Use interpolated values when resampling.  By default,
     * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
     */
    interpolate?: boolean | undefined;
    /**
     * Wrap the world horizontally.
     */
    wrapX?: boolean | undefined;
    /**
     * Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */
    transition?: number | undefined;
};
/**
 * @typedef {Object} Options
 * @property {AuthConfig|string} [auth] The authentication configuration with `clientId` and `clientSecret` or an access token.
 * See [Sentinel Hub authentication](https://docs.sentinel-hub.com/api/latest/api/overview/authentication/)
 * for details.  If not provided in the constructor, the source will not be rendered until {@link module:ol/source/SentinelHub~SentinelHub#setAuth}
 * is called.
 * @property {Array<ProcessRequestInputDataItem>} [data] The input data configuration.  If not provided in the constructor,
 * the source will not be rendered until {@link module:ol/source/SentinelHub~SentinelHub#setData} is called.
 * @property {Evalscript|string} [evalscript] The process applied to the input data.  If not provided in the constructor,
 * the source will not be rendered until {@link module:ol/source/SentinelHub~SentinelHub#setEvalscript} is called.  See the
 * `setEvalscript` documentation for details on the restrictions when passing process functions.
 * @property {number|import("../size.js").Size} [tileSize=[512, 512]] The pixel width and height of the source tiles.
 * @property {string} [url='https://services.sentinel-hub.com/api/v1/process'] The Sentinel Hub Processing API URL.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {boolean} [attributionsCollapsible=true] Allow the attributions to be collapsed.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [wrapX=true] Wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */
/**
 * @classdesc
 * A tile source that generates tiles using the Sentinel Hub [Processing API](https://docs.sentinel-hub.com/api/latest/api/process/).
 * All of the constructor options are optional, however the source will not be ready for rendering until the `auth`, `data`,
 * and `evalscript` properties are provided.  These can be set after construction with the {@link module:ol/source/SentinelHub~SentinelHub#setAuth},
 * {@link module:ol/source/SentinelHub~SentinelHub#setData}, and {@link module:ol/source/SentinelHub~SentinelHub#setEvalscript}
 * methods.
 *
 * If there are errors while configuring the source or fetching an access token, the `change` event will be fired and the
 * source state will be set to `error`.  See the {@link module:ol/source/SentinelHub~SentinelHub#getError} method for
 * details on handling these errors.
 * @api
 */
declare class SentinelHub extends DataTileSource<DataTile> {
    /**
     * @param {Options} [options] Sentinel Hub options.
     */
    constructor(options?: Options$3);
    /**
     * @type {Error|null}
     */
    error_: Error | null;
    /**
     * @type {string}
     * @private
     */
    private evalscript_;
    /**
     * @type {Array<ProcessRequestInputDataItem>|null}
     * @private
     */
    private inputData_;
    /**
     * @type {string}
     * @private
     */
    private processUrl_;
    /**
     * @type {string}
     * @private
     */
    private token_;
    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    private tokenRenewalId_;
    /**
     * Set the authentication configuration for the source (if not provided in the constructor).
     * If an object with `clientId` and `clientSecret` is provided, an access token will be fetched
     * and used with processing requests.  Alternatively, an access token can be supplied directly.
     *
     * @param {AuthConfig|string} auth The auth config or access token.
     * @api
     */
    setAuth(auth: AuthConfig | string): Promise<void>;
    /**
     * Set or update the input data used.
     *
     * @param {Array<ProcessRequestInputDataItem>} data The input data configuration.
     * @api
     */
    setData(data: Array<ProcessRequestInputDataItem>): void;
    /**
     * Set or update the Evalscript used to process the data.  Either a process object or a string
     * Evalscript can be provided.  If a process object is provided, it will be serialized to produce the
     * Evalscript string.  Because these functions will be serialized and executed by the Processing API,
     * they cannot refer to other variables or functions that are not provided by the Processing API
     * context.
     *
     * @param {Evalscript|string} evalscript The process to apply to the input data.
     * @api
     */
    setEvalscript(evalscript: Evalscript | string): void;
    fireWhenReady_(): void;
    /**
     * @param {number} z The z tile index.
     * @param {number} x The x tile index.
     * @param {number} y The y tile index.
     * @param {number} attempt The attempt number (starting with 1).  Incremented with retries.
     * @return {Promise<import('../DataTile.js').Data>} The composed tile data.
     * @private
     */
    private loadTile_;
    /**
     * When the source state is `error`, use this function to get more information about the error.
     * To debug a faulty configuration, you may want to use a listener like this:
     * ```js
     * source.on('change', () => {
     *   if (source.getState() === 'error') {
     *     console.error(source.getError());
     *   }
     * });
     * ```
     *
     * @return {Error|null} A source loading error.
     * @api
     */
    getError(): Error | null;
}

/**
 * @module ol/source/common
 */
/**
 * Default WMS version.
 * @type {string}
 */
declare const DEFAULT_WMS_VERSION: string;
/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
declare const DECIMALS: number;

/**
 * @typedef {Object} TileSetInfo
 * @property {string} urlTemplate The tile URL template.
 * @property {import("../proj/Projection.js").default} projection The source projection.
 * @property {import("../tilegrid/TileGrid.js").default} grid The tile grid.
 * @property {import("../Tile.js").UrlFunction} urlFunction The tile URL function.
 */
/**
 * @typedef {Object} SourceInfo
 * @property {string} url The tile set URL.
 * @property {string} mediaType The preferred tile media type.
 * @property {Array<string>} [supportedMediaTypes] The supported media types.
 * @property {import("../proj/Projection.js").default} projection The source projection.
 * @property {Object} [context] Optional context for constructing the URL.
 * @property {Array<string>} [collections] Optional collections to append the URL with.
 */
/**
 * @param {string} tileUrlTemplate Tile URL template.
 * @param {Array<string>} collections List of collections to include as query parameter.
 * @return {string} The tile URL template with appended collections query parameter.
 */
declare function appendCollectionsQueryParam(tileUrlTemplate: string, collections: Array<string>): string;
/**
 * @param {Array<Link>} links Tileset links.
 * @param {string} [mediaType] The preferred media type.
 * @param {Array<string>} [collections] Optional collections to append the URL with.
 * @return {string} The tile URL template.
 */
declare function getMapTileUrlTemplate(links: Array<Link>, mediaType?: string, collections?: Array<string>): string;
/**
 * @param {Array<Link>} links Tileset links.
 * @param {string} [mediaType] The preferred media type.
 * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.
 * @param {Array<string>} [collections] Optional collections to append the URL with.
 * @return {string} The tile URL template.
 */
declare function getVectorTileUrlTemplate(links: Array<Link>, mediaType?: string, supportedMediaTypes?: Array<string>, collections?: Array<string>): string;
/**
 * @param {SourceInfo} sourceInfo Source info.
 * @return {Promise<TileSetInfo>} Tile set info.
 */
declare function getTileSetInfo(sourceInfo: SourceInfo): Promise<TileSetInfo>;
type TileSetInfo = {
    /**
     * The tile URL template.
     */
    urlTemplate: string;
    /**
     * The source projection.
     */
    projection: Projection;
    /**
     * The tile grid.
     */
    grid: TileGrid;
    /**
     * The tile URL function.
     */
    urlFunction: UrlFunction;
};
type SourceInfo = {
    /**
     * The tile set URL.
     */
    url: string;
    /**
     * The preferred tile media type.
     */
    mediaType: string;
    /**
     * The supported media types.
     */
    supportedMediaTypes?: string[] | undefined;
    /**
     * The source projection.
     */
    projection: Projection;
    /**
     * Optional context for constructing the URL.
     */
    context?: any;
    /**
     * Optional collections to append the URL with.
     */
    collections?: string[] | undefined;
};
type Link = {
    /**
     * The link rel attribute.
     */
    rel: string;
    /**
     * The link URL.
     */
    href: string;
    /**
     * The link type.
     */
    type: string;
};

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
declare function getDistance(c1: any[], c2: any[], radius?: number): number;
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
declare function getLength(geometry: Geometry$1, options?: SphereMetricOptions): number;
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
declare function getArea(geometry: Geometry$1, options?: SphereMetricOptions): number;
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
declare function offset(c1: Coordinate, distance: number, bearing: number, radius?: number): Coordinate;
/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */
/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
declare const DEFAULT_RADIUS: number;
/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 */
type SphereMetricOptions = {
    /**
     * Projection of the  geometry.  By default, the geometry is assumed to be in
     * Web Mercator.
     */
    projection?: ProjectionLike;
    /**
     * Sphere radius.  By default, the
     * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
     * for the WGS84 ellipsoid is used.
     */
    radius?: number | undefined;
};

/**
 * @module ol/string
 */
/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
declare function padNumber(number: number, width: number, precision?: number): string;
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
declare function compareVersions(v1: string | number, v2: string | number): number;

/**
 * Specify radius for regular polygons, or both radius and radius2 for stars.
 */
type Options$2 = {
    /**
     * Fill style.
     */
    fill?: Fill | undefined;
    /**
     * Number of points for stars and regular polygons. In case of a polygon, the number of points
     * is the number of sides.
     */
    points: number;
    /**
     * Radius of a regular polygon.
     */
    radius: number;
    /**
     * Second radius to make a star instead of a regular polygon.
     */
    radius2?: number | undefined;
    /**
     * Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
     */
    angle?: number | undefined;
    /**
     * Displacement of the shape in pixels.
     * Positive values will shift the shape right and up.
     */
    displacement?: number[] | undefined;
    /**
     * Stroke style.
     */
    stroke?: Stroke | undefined;
    /**
     * Rotation in radians (positive rotation clockwise).
     */
    rotation?: number | undefined;
    /**
     * Whether to rotate the shape with the view.
     */
    rotateWithView?: boolean | undefined;
    /**
     * Scale. Unless two dimensional scaling is required a better
     * result may be obtained with appropriate settings for `radius` and `radius2`.
     */
    scale?: number | Size | undefined;
    /**
     * Declutter mode.
     */
    declutterMode?: DeclutterMode | undefined;
};
type RenderOptions = {
    /**
     * StrokeStyle.
     */
    strokeStyle: ColorLike | undefined;
    /**
     * StrokeWidth.
     */
    strokeWidth: number;
    /**
     * Size.
     */
    size: number;
    /**
     * LineCap.
     */
    lineCap: CanvasLineCap;
    /**
     * LineDash.
     */
    lineDash: Array<number> | null;
    /**
     * LineDashOffset.
     */
    lineDashOffset: number;
    /**
     * LineJoin.
     */
    lineJoin: CanvasLineJoin;
    /**
     * MiterLimit.
     */
    miterLimit: number;
};
/**
 * Specify radius for regular polygons, or both radius and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} radius Radius of a regular polygon.
 * @property {number} [radius2] Second radius to make a star instead of a regular polygon.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius` and `radius2`.
 * @property {import('./Style.js').DeclutterMode} [declutterMode] Declutter mode.
 */
/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike|undefined} strokeStyle StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */
/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when both `radius` and
 * `radius2` are provided.
 * @api
 */
declare class RegularShape extends ImageStyle {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options$2);
    /**
     * @private
     * @type {HTMLCanvasElement|null}
     */
    private hitDetectionCanvas_;
    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    private fill_;
    /**
     * @private
     * @type {Array<number>}
     */
    private origin_;
    /**
     * @private
     * @type {number}
     */
    private points_;
    /**
     * @protected
     * @type {number}
     */
    protected radius: number;
    /**
     * @private
     * @type {number|undefined}
     */
    private radius2_;
    /**
     * @private
     * @type {number}
     */
    private angle_;
    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    private stroke_;
    /**
     * @private
     * @type {import("../size.js").Size}
     */
    private size_;
    /**
     * @private
     * @type {RenderOptions}
     */
    private renderOptions_;
    /**
     * @private
     */
    private imageState_;
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     * @override
     */
    override clone(): RegularShape;
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
    getAngle(): number;
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill(): Fill | null;
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(fill: Fill | null): void;
    /**
     * @return {HTMLCanvasElement} Image element.
     * @override
     */
    override getHitDetectionImage(): HTMLCanvasElement;
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     * @override
     */
    override getImage(pixelRatio: number): HTMLCanvasElement;
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
    getPoints(): number;
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
    getRadius(): number;
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
    getRadius2(): number | undefined;
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke(): Stroke | null;
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(stroke: Stroke | null): void;
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
    private calculateLineJoinSize_;
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
    protected createRenderOptions(): RenderOptions;
    /**
     * @protected
     */
    protected render(): void;
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
    private draw_;
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @return {HTMLCanvasElement} Canvas containing the icon
     */
    private createHitDetectionCanvas_;
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
    private createPath_;
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
    private drawHitDetectionCanvas_;
}

type Options$1 = {
    /**
     * Fill style.
     */
    fill?: Fill | undefined;
    /**
     * Circle radius.
     */
    radius: number;
    /**
     * Stroke style.
     */
    stroke?: Stroke | undefined;
    /**
     * displacement
     */
    displacement?: number[] | undefined;
    /**
     * Scale. A two dimensional scale will produce an ellipse.
     * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
     */
    scale?: number | Size | undefined;
    /**
     * Rotation in radians
     * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
     */
    rotation?: number | undefined;
    /**
     * Whether to rotate the shape with the view
     * (meaningful only when used in conjunction with a two dimensional scale).
     */
    rotateWithView?: boolean | undefined;
    /**
     * Declutter mode
     */
    declutterMode?: DeclutterMode | undefined;
};
/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {import('./Style.js').DeclutterMode} [declutterMode] Declutter mode
 */
/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
declare class CircleStyle extends RegularShape {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options?: Options$1);
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     * @override
     */
    override clone(): CircleStyle;
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
    setRadius(radius: number): void;
}

declare class IconImage extends Target {
    /**
     * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
     * @param {string|undefined} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default|undefined} imageState Image state.
     * @param {import("../color.js").Color|string|null} color Color.
     */
    constructor(image: HTMLImageElement | HTMLCanvasElement | ImageBitmap | null, src: string | undefined, crossOrigin: string | null, imageState: any | undefined, color: Color | string | null);
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */
    private hitDetectionImage_;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null}
     */
    private image_;
    /**
     * @private
     * @type {string|null}
     */
    private crossOrigin_;
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    private canvas_;
    /**
     * @private
     * @type {import("../color.js").Color|string|null}
     */
    private color_;
    /**
     * @private
     * @type {import("../ImageState.js").default}
     */
    private imageState_;
    /**
     * @private
     * @type {import("../size.js").Size|null}
     */
    private size_;
    /**
     * @private
     * @type {string|undefined}
     */
    private src_;
    /**
     * @private
     * @type {Promise<void>|null}
     */
    private ready_;
    /**
     * @private
     */
    private initializeImage_;
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
    private isTainted_;
    tainted_: boolean | undefined;
    /**
     * @private
     */
    private dispatchChangeEvent_;
    /**
     * @private
     */
    private handleImageError_;
    /**
     * @private
     */
    private handleImageLoad_;
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
     */
    getImage(pixelRatio: number): HTMLImageElement | HTMLCanvasElement | ImageBitmap;
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
    getPixelRatio(pixelRatio: number): number;
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState(): any;
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
    getHitDetectionImage(): HTMLImageElement | HTMLCanvasElement | ImageBitmap;
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
    getSize(): Size;
    /**
     * @return {string|undefined} Image src.
     */
    getSrc(): string | undefined;
    /**
     * Load not yet loaded URI.
     */
    load(): void;
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
    private replaceColor_;
    /**
     * @return {Promise<void>} Promise that resolves when the image is loaded.
     */
    ready(): Promise<void>;
}

/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */
declare class IconImageCache {
    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    private cache_;
    /**
     * @type {!Object<string, CanvasPattern>}
     * @private
     */
    private patternCache_;
    /**
     * @type {number}
     * @private
     */
    private cacheSize_;
    /**
     * @type {number}
     * @private
     */
    private maxCacheSize_;
    /**
     * FIXME empty description for jsdoc
     */
    clear(): void;
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache(): boolean;
    /**
     * FIXME empty description for jsdoc
     */
    expire(): void;
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
    get(src: string, crossOrigin: string | null, color: Color | string | null): IconImage;
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {CanvasPattern} Icon image.
     */
    getPattern(src: string, crossOrigin: string | null, color: Color | string | null): CanvasPattern;
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @param {import("./IconImage.js").default|null} iconImage Icon image.
     * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
     */
    set(src: string, crossOrigin: string | null, color: Color | string | null, iconImage: IconImage | null, pattern?: boolean): void;
    /**
     * Set the cache size of the icon cache. Default is `1024`. Change this value when
     * your map uses more than 1024 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
    setSize(maxCacheSize: number): void;
}

/**
 * @module ol/tilegrid/common
 */
/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
declare const DEFAULT_MAX_ZOOM: number;
/**
 * Default tile size.
 * @type {number}
 */
declare const DEFAULT_TILE_SIZE: number;

/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
declare function appendParams(uri: string, params: any): string;
/**
 * @param {string} template The URL template.  Should have `{x}`, `{y}`, and `{z}` placeholders.  If
 * the template has a `{-y}` placeholder, the `maxY` parameter must be supplied.
 * @param {number} z The tile z coordinate.
 * @param {number} x The tile x coordinate.
 * @param {number} y The tile y coordinate.
 * @param {number} [maxY] The maximum y coordinate at the given z level.
 * @return {string} The URL.
 */
declare function renderXYZTemplate(template: string, z: number, x: number, y: number, maxY?: number): string;
/**
 * @param {Array<string>} urls List of URLs.
 * @param {number} z The tile z coordinate.
 * @param {number} x The tile x coordinate.
 * @param {number} y The tile y coordinate.
 * @return {string} The chosen URL.
 */
declare function pickUrl(urls: Array<string>, z: number, x: number, y: number): string;
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
declare function expandUrl(url: string): Array<string>;

/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default|null} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
declare function createFromTemplate(template: string, tileGrid: TileGrid | null): UrlFunction;
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
declare function createFromTemplates(templates: Array<string>, tileGrid: TileGrid): UrlFunction;
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
declare function createFromTileUrlFunctions(tileUrlFunctions: Array<UrlFunction>): UrlFunction;
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
declare function nullTileUrlFunction(tileCoord: TileCoord, pixelRatio: number, projection: Projection): string | undefined;

/**
 * @module ol/util
 */
/**
 * @return {never} Any return.
 */
declare function abstract(): never;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
declare function getUid(obj: any): string;
/**
 * OpenLayers version.
 * @type {string}
 */
declare const VERSION: string;

/**
 * @module ol/vec/mat4
 */
/** @typedef {Array<number>} Mat4 */
/**
 * @return {Mat4} "4x4 matrix representing a 3D identity transform."
 */
declare function create(): Mat4;
/**
 * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Mat4} "2D transformation matrix as flattened 4x4 matrix."
 */
declare function fromTransform(mat4: Mat4, transform: Transform): Mat4;
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @param {Mat4} [out] mat4 frustum matrix will be written into
 * @return {Mat4} out
 */
declare function orthographic(left: number, right: number, bottom: number, top: number, near: number, far: number, out?: Mat4): Mat4;
/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {Mat4} m The matrix to scale.
 * @param {number} x How much to scale in the x direction.
 * @param {number} y How much to scale in the y direction.
 * @param {number} z How much to scale in the z direction.
 * @param {Mat4} [out] The matrix to write to.
 * @return {Mat4} out
 **/
declare function scale(m: Mat4, x: number, y: number, z: number, out?: Mat4): Mat4;
/**
 * Translate a matrix.
 *
 * @param {Mat4} m the matrix to translate
 * @param {number} x How much to translate in the x direction.
 * @param {number} y How much to translate in the y direction.
 * @param {number} z How much to translate in the z direction.
 * @param {Mat4} [out] the receiving matrix
 * @return {Mat4} out
 */
declare function translate(m: Mat4, x: number, y: number, z: number, out?: Mat4): Mat4;
/**
 * @param {number} x x translation.
 * @param {number} y y translation.
 * @param {number} z z translation.
 * @param {Mat4} [out] optional matrix to store result
 * @return {Mat4} out
 */
declare function translation(x: number, y: number, z: number, out?: Mat4): Mat4;
type Mat4 = Array<number>;

/**
 * @param {WebGLRenderingContext} gl Rendering Context.
 * @param {string} fragmentSource Fragment shader source.
 * @param {string} vertexSource Vertex shader source.
 * @return {WebGLProgram} [progam] The program.
 */
declare function createProgram(gl: WebGLRenderingContext, fragmentSource: string, vertexSource: string): WebGLProgram;
/** @typedef {import("../transform.js").Transform} Matrix */
/**
 * Canvas-like operations implemented in webgl.
 */
declare class Canvas {
    /**
     * @param {WebGLRenderingContext} gl Context to render in.
     */
    constructor(gl: WebGLRenderingContext);
    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    private gl_;
    /**
     * @private
     * @type {WebGLProgram}
     */
    private program_;
    positionLocation: number;
    texcoordLocation: number;
    matrixLocation: WebGLUniformLocation | null;
    textureMatrixLocation: WebGLUniformLocation | null;
    textureLocation: WebGLUniformLocation | null;
    positionBuffer: WebGLBuffer;
    positions: number[];
    texcoordBuffer: WebGLBuffer;
    texcoords: number[];
    /**
     * 2dContext drawImage call implemented in webgl.
     * Unlike images, textures do not have a width and height associated
     * with them so we'll pass in the width and height of the texture.
     *
     * @param {WebGLTexture} tex Image to draw.
     * @param {number} texWidth Image width.
     * @param {number} texHeight Image height.
     * @param {number} srcX Top-left x-point to read src image.
     * @param {number} srcY Top-left y-point to read src image.
     * @param {number} [srcWidth] Width of source to read.
     * @param {number} [srcHeight] Height of source to read.
     * @param {number} [dstX] Top-left x-point of destination.
     * @param {number} [dstY] Top-left y-point of destination.
     * @param {number} [dstWidth] Width of written image in destination.
     * @param {number} [dstHeight] Height of written image in destination.
     * @param {number} [width] Width of canvas.
     * @param {number} [height] Height of canvas.
     */
    drawImage(tex: WebGLTexture, texWidth: number, texHeight: number, srcX: number, srcY: number, srcWidth?: number, srcHeight?: number, dstX?: number, dstY?: number, dstWidth?: number, dstHeight?: number, width?: number, height?: number): void;
}

type Options = {
    /**
     * WebGL context; mandatory.
     */
    webGlContext: WebGLRenderingContext;
    /**
     * Scale ratio; if < 1, the post process will render to a texture smaller than
     * the main canvas that will then be sampled up (useful for saving resource on blur steps).
     */
    scaleRatio?: number | undefined;
    /**
     * Vertex shader source
     */
    vertexShader?: string | undefined;
    /**
     * Fragment shader source
     */
    fragmentShader?: string | undefined;
    /**
     * Uniform definitions for the post process step
     */
    uniforms?: {
        [x: string]: UniformValue;
    } | undefined;
};
/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */
/**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {WebGLUniformLocation} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */
/**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *   uniform float u_opacity;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
 *   }
 *   ```
 */
declare class WebGLPostProcessingPass {
    /**
     * @param {Options} options Options.
     */
    constructor(options: Options);
    /**
     * @private
     */
    private gl_;
    /**
     * @private
     */
    private scaleRatio_;
    /**
     * @type {WebGLTexture}
     * @private
     */
    private renderTargetTexture_;
    /**
     * @type {import('../size.js').Size|null}
     * @private
     */
    private renderTargetTextureSize_;
    /**
     * @private
     */
    private frameBuffer_;
    /**
     * @private
     */
    private depthBuffer_;
    /**
     * @private
     */
    private renderTargetProgram_;
    /**
     * @private
     */
    private renderTargetVerticesBuffer_;
    /**
     * @private
     */
    private renderTargetAttribLocation_;
    /**
     * @private
     */
    private renderTargetUniformLocation_;
    /**
     * @private
     */
    private renderTargetOpacityLocation_;
    /**
     * @private
     */
    private renderTargetTextureLocation_;
    /**
     * Holds info about custom uniforms used in the post processing pass
     * @type {Array<UniformInternalDescription>}
     * @private
     */
    private uniforms_;
    getRenderTargetTexture(): WebGLTexture;
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     */
    getGL(): WebGLRenderingContext;
    /**
     * Initialize the render target texture of the post process, make sure it is at the
     * right size and bind it as a render target for the next draw calls.
     * The last step to be initialized will be the one where the primitives are rendered.
     * @param {import("../Map.js").FrameState} frameState current frame state
     */
    init(frameState: FrameState): void;
    /**
     * Render to the next postprocessing pass (or to the canvas if final pass).
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
     */
    apply(frameState: FrameState, nextPass?: WebGLPostProcessingPass, preCompose?: (arg0: WebGLRenderingContext, arg1: FrameState) => void, postCompose?: (arg0: WebGLRenderingContext, arg1: FrameState) => void): void;
    /**
     * @return {WebGLFramebuffer} Frame buffer
     */
    getFrameBuffer(): WebGLFramebuffer;
    /**
     * @return {WebGLRenderbuffer} Depth buffer
     */
    getDepthBuffer(): WebGLRenderbuffer;
    /**
     * Sets the custom uniforms based on what was given in the constructor.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @private
     */
    private applyUniforms;
}

/**
 * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that
 * will be read and modified during the parsing operation.
 * @param {import("../expr/gpu.js").CompilationContext} compilationContext Compilation context
 * @param {import("../expr/expression.js").EncodedExpression} value Value
 * @param {number} [expectedType] Expected final type (can be several types combined)
 * @return {string} GLSL-compatible output
 */
declare function expressionToGlsl(compilationContext: CompilationContext, value: EncodedExpression, expectedType?: number): string;
/**
 * Packs all components of a color into a two-floats array
 * @param {import("../color.js").Color|string} color Color as array of numbers or string
 * @return {Array<number>} Vec2 array containing the color in compressed form
 */
declare function packColor(color: Color | string): Array<number>;
/**
 * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript
 * @param {Object|string} input The hash input, either an object or string
 * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)
 */
declare function computeHash(input: any | string): string;
/**
 * @typedef {Object} StyleParseResult
 * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style
 * @property {import("../render/webgl/VectorStyleRenderer.js").UniformDefinitions} uniforms Uniform definitions
 * @property {import("../render/webgl/VectorStyleRenderer.js").AttributeDefinitions} attributes Attribute definitions
 */
/**
 * Parses a {@link import("../style/webgl.js").WebGLStyle} object and returns a {@link ShaderBuilder}
 * object that has been configured according to the given style, as well as `attributes` and `uniforms`
 * arrays to be fed to the `WebGLPointsRenderer` class.
 *
 * Also returns `uniforms` and `attributes` properties as expected by the
 * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 * @param {import("../style/webgl.js").WebGLStyle} style Literal style.
 * @param {import('../style/flat.js').StyleVariables} variables Style variables.
 * @return {StyleParseResult} Result containing shader params, attributes and uniforms.
 */
declare function parseLiteralStyle(style: WebGLStyle, variables: StyleVariables): StyleParseResult;
type StyleParseResult = {
    /**
     * Shader builder pre-configured according to a given style
     */
    builder: ShaderBuilder;
    /**
     * Uniform definitions
     */
    uniforms: UniformDefinitions;
    /**
     * Attribute definitions
     */
    attributes: AttributeDefinitions;
};


    export { Collection };
    export { DataTile };
    export { Disposable };
    export { Feature$2 as Feature };
    export { Geolocation };
    export { ImageWrapper as Image };
    export { ImageCanvas };
    export { ImageTile };
    export { Kinetic };
    export { Map };
    export { MapBrowserEvent };
    export { MapBrowserEventHandler };
    export { MapEvent };
    export { BaseObject as Object };
    export { Observable };
    export { Overlay };
    export { Tile$1 as Tile };
    export { TileCache };
    export { TileQueue };
    export { TileRange };
    export { VectorRenderTile };
    export { VectorTile$1 as VectorTile };
    export { View };
    export namespace array {
        export { ascending };
        export { binarySearch };
        export { descending };
        export { equals$2 as equals };
        export { extend$1 as extend };
        export { isSorted };
        export { linearFindNearest };
        export { remove$1 as remove };
        export { reverseSubArray };
        export { stableSort };
    }
    export namespace asserts {
        export { assert };
    }
    export namespace centerconstraint {
        export { createExtent };
        export { none };
    }
    export namespace color {
        export { NO_COLOR };
        export { asArray };
        export { asString };
        export { fromString };
        export { isStringColor };
        export { lchaToRgba };
        export { normalize };
        export { rgbaToLcha };
        export { toString };
        export { withAlpha };
    }
    export namespace colorlike {
        export { asColorLike };
    }
    export namespace console {
        export { error };
        export { log };
        export { setLevel };
        export { warn };
    }
    export namespace control {
        export { Attribution };
        export { Control };
        export { FullScreen };
        export { MousePosition };
        export { OverviewMap };
        export { Rotate };
        export { ScaleLine };
        export { Zoom };
        export { ZoomSlider };
        export { ZoomToExtent };
        export namespace defaults {
            export { defaults$1 as defaults };
        }
    }
    export namespace coordinate {
        export { add$2 as add };
        export { closestOnCircle };
        export { closestOnSegment };
        export { createStringXY };
        export { degreesToStringHDMS };
        export { distance };
        export { equals };
        export { format };
        export { getWorldsAway };
        export { rotate$1 as rotate };
        export { scale$2 as scale };
        export { squaredDistance$1 as squaredDistance };
        export { squaredDistanceToSegment };
        export { toStringHDMS };
        export { toStringXY };
        export { wrapX$1 as wrapX };
    }
    export namespace css {
        export { CLASS_COLLAPSED };
        export { CLASS_CONTROL };
        export { CLASS_HIDDEN };
        export { CLASS_SELECTABLE };
        export { CLASS_UNSELECTABLE };
        export { CLASS_UNSUPPORTED };
        export { getFontParameters };
    }
    export namespace dom {
        export { createCanvasContext2D };
        export { getSharedCanvasContext2D };
        export { outerHeight };
        export { outerWidth };
        export { releaseCanvas };
        export { removeChildren };
        export { replaceChildren };
        export { replaceNode };
    }
    export namespace easing {
        export { easeIn };
        export { easeOut };
        export { inAndOut };
        export { linear };
        export { upAndDown };
    }
    export namespace events {
        export { BaseEvent as Event };
        export namespace SnapEvent {
            export { SnapEvent };
        }
        export { Target };
        export namespace condition {
            export { all$1 as all };
            export { altKeyOnly };
            export { altShiftKeysOnly };
            export { always };
            export { click };
            export { doubleClick };
            export { focus };
            export { focusWithTabindex };
            export { mouseActionButton };
            export { mouseOnly };
            export { never };
            export { noModifierKeys };
            export { penOnly };
            export { platformModifierKey };
            export { platformModifierKeyOnly };
            export { pointerMove };
            export { primaryAction };
            export { shiftKeyOnly };
            export { singleClick };
            export { targetNotEditable };
            export { touchOnly };
        }
        export { listen };
        export { listenOnce };
        export { unlistenByKey };
    }
    export namespace expr {
        namespace cpu {
            export { buildExpression$1 as buildExpression };
            export { newEvaluationContext };
        }
        namespace expression {
            export { AnyType };
            export { BooleanType };
            export { CallExpression };
            export { ColorType };
            export { LiteralExpression };
            export { NoneType };
            export { NumberArrayType };
            export { NumberType };
            export { Ops };
            export { SizeType };
            export { StringType };
            export { computeGeometryType };
            export { includesType };
            export { isType };
            export { newParsingContext };
            export { overlapsType };
            export { parse$1 as parse };
            export { typeName };
        }
        namespace gpu {
            export { FEATURE_ID_PROPERTY_NAME };
            export { GEOMETRY_TYPE_PROPERTY_NAME };
            export { PALETTE_TEXTURE_ARRAY };
            export { arrayToGlsl };
            export { buildExpression };
            export { colorToGlsl };
            export { getStringNumberEquivalent };
            export { newCompilationContext };
            export { numberToGlsl };
            export { sizeToGlsl };
            export { stringToGlsl };
            export { uniformNameForVariable };
        }
    }
    export namespace extent {
        export { applyTransform };
        export { approximatelyEquals };
        export { boundingExtent };
        export { buffer };
        export { clone };
        export { closestSquaredDistanceXY };
        export { containsCoordinate };
        export { containsExtent };
        export { containsXY };
        export { coordinateRelationship };
        export { createEmpty };
        export { createOrUpdate$1 as createOrUpdate };
        export { createOrUpdateEmpty };
        export { createOrUpdateFromCoordinate };
        export { createOrUpdateFromCoordinates };
        export { createOrUpdateFromFlatCoordinates };
        export { createOrUpdateFromRings };
        export { equals$1 as equals };
        export { extend };
        export { extendCoordinate };
        export { extendCoordinates };
        export { extendFlatCoordinates };
        export { extendRings };
        export { extendXY };
        export { forEachCorner };
        export { getArea$1 as getArea };
        export { getBottomLeft };
        export { getBottomRight };
        export { getCenter };
        export { getCorner };
        export { getEnlargedArea };
        export { getForViewAndSize };
        export { getHeight };
        export { getIntersection };
        export { getIntersectionArea };
        export { getMargin };
        export { getRotatedViewport };
        export { getSize };
        export { getTopLeft };
        export { getTopRight };
        export { getWidth };
        export { intersects$1 as intersects };
        export { intersectsSegment };
        export { isEmpty$1 as isEmpty };
        export { returnOrUpdate };
        export { scaleFromCenter };
        export { wrapAndSliceX };
        export { wrapX$2 as wrapX };
    }
    export namespace featureloader {
        export { loadFeaturesXhr };
        export { setWithCredentials };
        export { xhr };
    }
    export namespace format {
        export { EsriJSON };
        export { FeatureFormat as Feature };
        export { GML };
        export { GML2 };
        export { GML3 };
        export { GML32 };
        export { GMLBase };
        export { GPX };
        export { GeoJSON };
        export { IGC };
        export { IIIFInfo };
        export { JSONFeature };
        export { KML };
        export { MVT };
        export { OSMXML };
        export { OWS };
        export { Polyline };
        export { TextFeature };
        export { TopoJSON };
        export { WFS };
        export { WKB };
        export { WKT };
        export { WMSCapabilities };
        export { WMSGetFeatureInfo };
        export { WMTSCapabilities };
        export { XML };
        export { XMLFeature };
        export namespace filter {
            export { And };
            export { Bbox };
            export { Comparison };
            export { ComparisonBinary };
            export { Contains };
            export { DWithin };
            export { Disjoint };
            export { During };
            export { EqualTo };
            export { Filter };
            export { GreaterThan };
            export { GreaterThanOrEqualTo };
            export { Intersects };
            export { IsBetween };
            export { IsLike };
            export { IsNull };
            export { LessThan };
            export { LessThanOrEqualTo };
            export { LogicalNary };
            export { Not };
            export { NotEqualTo };
            export { Or };
            export { ResourceId };
            export { Spatial };
            export { Within };
            export { and };
            export { bbox$1 as bbox };
            export { between };
            export { contains };
            export { disjoint };
            export { during };
            export { dwithin };
            export { equalTo };
            export { greaterThan };
            export { greaterThanOrEqualTo };
            export { intersects };
            export { isNull };
            export { lessThan };
            export { lessThanOrEqualTo };
            export { like };
            export { not };
            export { notEqualTo };
            export { or };
            export { resourceId };
            export { within };
        }
        export namespace xlink {
            export { readHref };
        }
        export namespace xsd {
            export { readBoolean };
            export { readBooleanString };
            export { readDateTime };
            export { readDecimal };
            export { readDecimalString };
            export { readNonNegativeIntegerString };
            export { readPositiveInteger };
            export { readString };
            export { writeBooleanTextNode };
            export { writeCDATASection };
            export { writeDateTimeTextNode };
            export { writeDecimalTextNode };
            export { writeNonNegativeIntegerTextNode };
            export { writeStringTextNode };
        }
    }
    export namespace functions {
        export { FALSE };
        export { TRUE };
        export { VOID };
        export { memoizeOne };
        export { toPromise };
    }
    export namespace geom {
        export { Circle };
        export { Geometry$1 as Geometry };
        export { GeometryCollection$1 as GeometryCollection };
        export { LineString$1 as LineString };
        export { LinearRing };
        export { MultiLineString$1 as MultiLineString };
        export { MultiPoint$1 as MultiPoint };
        export { MultiPolygon$1 as MultiPolygon };
        export { Point$1 as Point };
        export { Polygon$1 as Polygon };
        export { SimpleGeometry };
        export namespace flat {
            namespace area {
                export { linearRing };
                export { linearRings };
                export { linearRingss$1 as linearRingss };
            }
            namespace center {
                export { linearRingss };
            }
            namespace closest {
                export { arrayMaxSquaredDelta };
                export { assignClosestArrayPoint };
                export { assignClosestMultiArrayPoint };
                export { assignClosestPoint };
                export { maxSquaredDelta };
                export { multiArrayMaxSquaredDelta };
            }
            namespace contains {
                export { linearRingContainsExtent };
                export { linearRingContainsXY };
                export { linearRingsContainsXY };
                export { linearRingssContainsXY };
            }
            namespace deflate {
                export { deflateCoordinate };
                export { deflateCoordinates };
                export { deflateCoordinatesArray };
                export { deflateMultiCoordinatesArray };
            }
            namespace flip {
                export { flipXY };
            }
            namespace geodesic {
                export { greatCircleArc };
                export { meridian };
                export { parallel };
            }
            namespace inflate {
                export { inflateCoordinates };
                export { inflateCoordinatesArray };
                export { inflateMultiCoordinatesArray };
            }
            namespace interiorpoint {
                export { getInteriorPointOfArray };
                export { getInteriorPointsOfMultiArray };
            }
            namespace interpolate {
                export { interpolatePoint };
                export { lineStringCoordinateAtM };
                export { lineStringsCoordinateAtM };
            }
            namespace intersectsextent {
                export { intersectsLineString };
                export { intersectsLineStringArray };
                export { intersectsLinearRing };
                export { intersectsLinearRingArray };
                export { intersectsLinearRingMultiArray };
            }
            namespace length {
                export { lineStringLength };
                export { linearRingLength };
            }
            namespace orient {
                export { inflateEnds };
                export { linearRingIsClockwise };
                export { linearRingsAreOriented };
                export { linearRingssAreOriented };
                export { orientLinearRings };
                export { orientLinearRingsArray };
            }
            namespace reverse {
                export { coordinates };
            }
            namespace segments {
                export { forEach };
            }
            namespace simplify {
                export { douglasPeucker };
                export { douglasPeuckerArray };
                export { douglasPeuckerMultiArray };
                export { quantize };
                export { quantizeArray };
                export { quantizeMultiArray };
                export { radialDistance };
                export { simplifyLineString };
                export { snap };
            }
            namespace straightchunk {
                export { matchingChunk };
            }
            namespace textpath {
                export { drawTextOnPath };
            }
            namespace topology {
                export { lineStringIsClosed };
            }
            namespace transform {
                export { rotate };
                export { scale$1 as scale };
                export { transform2D };
                export { translate$1 as translate };
            }
        }
    }
    export namespace has {
        export { CREATE_IMAGE_BITMAP };
        export { DEVICE_PIXEL_RATIO };
        export { FIREFOX };
        export { IMAGE_DECODE };
        export { MAC };
        export { PASSIVE_EVENT_LISTENERS };
        export { SAFARI };
        export { SAFARI_BUG_237906 };
        export { WEBKIT };
        export { WORKER_OFFSCREEN_CANVAS };
    }
    export namespace interaction {
        export { DblClickDragZoom };
        export { DoubleClickZoom };
        export { DragAndDrop };
        export { DragBox };
        export { DragPan };
        export { DragRotate };
        export { DragRotateAndZoom };
        export { DragZoom };
        export { Draw };
        export { Extent };
        export { Interaction };
        export { KeyboardPan };
        export { KeyboardZoom };
        export { Link$1 as Link };
        export { Modify };
        export { MouseWheelZoom };
        export { PinchRotate };
        export { PinchZoom };
        export { PointerInteraction as Pointer };
        export { Select };
        export { Snap };
        export { Translate };
        export namespace defaults {
            export { defaults };
        }
    }
    export namespace layer {
        export { BaseLayer as Base };
        export { BaseImageLayer as BaseImage };
        export { BaseTileLayer as BaseTile };
        export { BaseVectorLayer as BaseVector };
        export { FlowLayer as Flow };
        export { Graticule };
        export { LayerGroup as Group };
        export { Heatmap };
        export { ImageLayer as Image };
        export { Layer };
        export { TileLayer as Tile };
        export { VectorLayer as Vector };
        export { VectorImageLayer as VectorImage };
        export { VectorTileLayer as VectorTile };
        export { WebGLPointsLayer as WebGLPoints };
        export { WebGLTileLayer as WebGLTile };
        export { WebGLVectorLayer as WebGLVector };
    }
    export namespace loadingstrategy {
        export { all };
        export { bbox };
        export { tile };
    }
    export namespace math {
        export { ceil };
        export { clamp };
        export { floor };
        export { lerp };
        export { modulo };
        export { round };
        export { solveLinearSystem };
        export { squaredDistance };
        export { squaredSegmentDistance };
        export { toDegrees };
        export { toFixed };
        export { toRadians };
        export { wrap };
    }
    export namespace net {
        export { ClientError };
        export { ResponseError };
        export { getJSON };
        export { jsonp };
        export { overrideXHR };
        export { resolveUrl };
        export { restoreXHR };
    }
    export namespace obj {
        export { clear$2 as clear };
        export { isEmpty };
    }
    export namespace proj {
        export { Projection };
        export namespace Units {
            export { METERS_PER_UNIT$1 as METERS_PER_UNIT };
            export { fromCode };
        }
        export { addCommon };
        export { addCoordinateTransforms };
        export { addEquivalentProjections };
        export { addEquivalentTransforms };
        export { addProjection };
        export { addProjections };
        export { clearAllProjections };
        export { clearUserProjection };
        export { cloneTransform };
        export { createProjection };
        export { createSafeCoordinateTransform };
        export { createTransformFromCoordinateTransform };
        export { disableCoordinateWarning };
        export namespace epsg3857 {
            export { EXTENT$1 as EXTENT };
            export { HALF_SIZE };
            export { MAX_SAFE_Y };
            export { PROJECTIONS$1 as PROJECTIONS };
            export { RADIUS$1 as RADIUS };
            export { WORLD_EXTENT };
            export { fromEPSG4326 };
            export { toEPSG4326 };
        }
        export namespace epsg4326 {
            export { EXTENT };
            export { METERS_PER_UNIT };
            export { PROJECTIONS };
            export { RADIUS };
        }
        export { equivalent };
        export { fromLonLat };
        export { fromUserCoordinate };
        export { fromUserExtent };
        export { fromUserResolution };
        export { get$2 as get };
        export { getPointResolution };
        export { getTransform };
        export { getTransformFromProjections };
        export { getUserProjection };
        export { identityTransform };
        export namespace proj4 {
            export { epsgLookupMapTiler };
            export { fromEPSGCode };
            export { getEPSGLookup };
            export { isRegistered };
            export { register };
            export { setEPSGLookup };
            export { unregister };
        }
        export namespace projections {
            export { add$1 as add };
            export { clear$1 as clear };
            export { get$1 as get };
        }
        export { setUserProjection };
        export { toLonLat };
        export { toUserCoordinate };
        export { toUserExtent };
        export { toUserResolution };
        export { transform };
        export { transformExtent };
        export { transformWithProjections };
        export namespace transforms {
            export { add };
            export { clear };
            export { get };
            export { remove };
        }
        export { useGeographic };
        export namespace utm {
            export { makeProjection };
            export { makeTransforms };
            export { zoneFromCode };
        }
    }
    export namespace render {
        export { RenderBox as Box };
        export { RenderEvent as Event };
        export { RenderFeature as Feature };
        export { VectorContext };
        export namespace canvas {
            export { CanvasBuilder as Builder };
            export { BuilderGroup };
            export { Executor };
            export { ExecutorGroup };
            export { CanvasImageBuilder as ImageBuilder };
            export { CanvasImmediateRenderer as Immediate };
            export namespace Instruction {
                export { beginPathInstruction };
                export { closePathInstruction };
                export { fillInstruction };
                export { strokeInstruction };
            }
            export { CanvasLineStringBuilder as LineStringBuilder };
            export { CanvasPolygonBuilder as PolygonBuilder };
            export { CanvasTextBuilder as TextBuilder };
            export { ZIndexContext };
            export { checkedFonts };
            export { defaultFillStyle };
            export { defaultFont };
            export { defaultLineCap };
            export { defaultLineDash };
            export { defaultLineDashOffset };
            export { defaultLineJoin };
            export { defaultLineWidth };
            export { defaultMiterLimit };
            export { defaultPadding };
            export { defaultStrokeStyle };
            export { defaultTextAlign };
            export { defaultTextBaseline };
            export { drawImageOrLabel };
            export { getTextDimensions };
            export namespace hitdetect {
                export { HIT_DETECT_RESOLUTION };
                export { createHitDetectionImageData };
                export { hitDetect };
            }
            export { measureAndCacheTextWidth };
            export { measureTextHeight };
            export { measureTextWidth };
            export { registerFont };
            export { rotateAtOffset };
            export namespace style {
                export { buildRuleSet };
                export { buildStyle };
                export { flatStylesToStyleFunction };
                export { rulesToStyleFunction };
            }
            export { textHeights };
        }
        export { getRenderPixel };
        export { getVectorContext };
        export { toContext };
        export namespace webgl {
            export { MixedGeometryBatch };
            export { VectorStyleRenderer };
            export namespace renderinstructions {
                export { generateLineStringRenderInstructions };
                export { generatePointRenderInstructions };
                export { generatePolygonRenderInstructions };
                export { getCustomAttributesSize };
            }
            export namespace utils {
                export { LINESTRING_ANGLE_COSINE_CUTOFF };
                export { colorDecodeId };
                export { colorEncodeId };
                export { getBlankImageData };
                export { writeLineSegmentToBuffers };
                export { writePointFeatureToBuffers };
                export { writePolygonTrianglesToBuffers };
            }
        }
    }
    export namespace renderer {
        export { CompositeMapRenderer as Composite };
        export { LayerRenderer as Layer };
        export { MapRenderer as Map };
        export namespace canvas {
            export { CanvasImageLayerRenderer as ImageLayer };
            export { CanvasLayerRenderer as Layer };
            export { CanvasTileLayerRenderer as TileLayer };
            export { CanvasVectorImageLayerRenderer as VectorImageLayer };
            export { CanvasVectorLayerRenderer as VectorLayer };
            export { CanvasVectorTileLayerRenderer as VectorTileLayer };
        }
        export namespace vector {
            export { defaultOrder };
            export { getSquaredTolerance };
            export { getTolerance };
            export { renderFeature };
        }
        export namespace webgl {
            export { FlowLayerRenderer as FlowLayer };
            export { WebGLLayerRenderer as Layer };
            export { WebGLPointsLayerRenderer as PointsLayer };
            export { WebGLTileLayerRenderer as TileLayer };
            export { WebGLBaseTileLayerRenderer as TileLayerBase };
            export { WebGLVectorLayerRenderer as VectorLayer };
            export { WebGLVectorTileLayerRenderer as VectorTileLayer };
        }
    }
    export namespace reproj {
        export { ReprojDataTile as DataTile };
        export { ReprojImage as Image };
        export { ReprojTile as Tile };
        export { Triangulation };
        export { calculateSourceExtentResolution };
        export { calculateSourceResolution };
        export { canvasPool };
        export namespace common {
            export { ERROR_THRESHOLD };
        }
        export namespace glreproj {
            export { canvasGLPool };
            export { createCanvasContextWebGL };
            export { releaseGLCanvas };
            export { render };
        }
        export { render$1 as render };
    }
    export namespace resolution {
        export { fromResolutionLike };
    }
    export namespace resolutionconstraint {
        export { createMinMaxResolution };
        export { createSnapToPower };
        export { createSnapToResolutions };
    }
    export namespace rotationconstraint {
        export { createSnapToN };
        export { createSnapToZero };
        export { disable };
        export { none$1 as none };
    }
    export namespace size {
        export { buffer$1 as buffer };
        export { hasArea };
        export { scale$4 as scale };
        export { toSize };
    }
    export namespace source {
        export { BingMaps };
        export { CartoDB };
        export { Cluster };
        export { DataTileSource as DataTile };
        export { GeoTIFFSource as GeoTIFF };
        export { Google };
        export { IIIF };
        export { ImageSource as Image };
        export { ImageArcGISRest };
        export { ImageCanvasSource as ImageCanvas };
        export { ImageMapGuide };
        export { Static as ImageStatic };
        export { ImageTileSource as ImageTile };
        export { ImageWMS };
        export { OGCMapTile };
        export { OGCVectorTile };
        export { OSM };
        export { RasterSource as Raster };
        export { SentinelHub };
        export { Source };
        export { StadiaMaps };
        export { TileSource as Tile };
        export { TileArcGISRest };
        export { TileDebug };
        export { TileImage };
        export { TileJSON };
        export { TileWMS };
        export { UTFGrid };
        export { UrlTile };
        export { VectorSource as Vector };
        export { VectorTile };
        export { WMTS };
        export { XYZ };
        export { Zoomify };
        export namespace arcgisRest {
            export { createLoader$2 as createLoader };
            export { getRequestUrl };
        }
        export namespace common {
            export { DECIMALS };
            export { DEFAULT_WMS_VERSION };
        }
        export namespace mapguide {
            export { createLoader };
        }
        export namespace ogcTileUtil {
            export { appendCollectionsQueryParam };
            export { getMapTileUrlTemplate };
            export { getTileSetInfo };
            export { getVectorTileUrlTemplate };
        }
        export { sourcesFromTileGrid };
        namespace _static {
            export { createLoader$1 as createLoader };
        }
        export { _static as static };
        export namespace wms {
            export { DEFAULT_VERSION };
            export { createLoader$3 as createLoader };
            export { getFeatureInfoUrl };
            export { getImageSrc };
            export { getLegendUrl };
            export { getRequestParams };
            export { getRequestUrl$1 as getRequestUrl };
        }
    }
    export namespace sphere {
        export { DEFAULT_RADIUS };
        export { getArea };
        export { getDistance };
        export { getLength };
        export { offset };
    }
    export namespace string {
        export { compareVersions };
        export { padNumber };
    }
    export namespace structs {
        export { LRUCache };
        export { PriorityQueue };
        export { RBush };
    }
    export namespace style {
        export { CircleStyle as Circle };
        export { Fill };
        export { Icon };
        export { IconImage };
        export { IconImageCache };
        export { ImageStyle as Image };
        export { RegularShape };
        export { Stroke };
        export { Style$2 as Style };
        export { Text$1 as Text };
        export namespace flat {
            export { createDefaultStyle };
        }
    }
    export namespace tilecoord {
        export { createOrUpdate };
        export { fromKey };
        export { getCacheKeyForTileKey };
        export { getKey };
        export { getKeyZXY };
        export { hash };
        export { hashZXY };
        export { withinExtentAndZ };
    }
    export namespace tilegrid {
        export { TileGrid };
        export { WMTSTileGrid as WMTS };
        export namespace common {
            export { DEFAULT_MAX_ZOOM };
            export { DEFAULT_TILE_SIZE };
        }
        export { createForExtent };
        export { createForProjection };
        export { createXYZ };
        export { extentFromProjection };
        export { getForProjection };
        export { wrapX };
    }
    export namespace tileurlfunction {
        export { createFromTemplate };
        export { createFromTemplates };
        export { createFromTileUrlFunctions };
        export { nullTileUrlFunction };
    }
    export namespace transform {
        export { apply };
        export { compose };
        export { composeCssTransform };
        export { create$1 as create };
        export { determinant };
        export { invert };
        export { makeInverse };
        export { makeScale };
        export { multiply };
        export { reset };
        export { rotate$2 as rotate };
        export { scale$3 as scale };
        export { set };
        export { setFromArray };
        export { toString$1 as toString };
        export { translate$2 as translate };
    }
    export namespace uri {
        export { appendParams };
        export { expandUrl };
        export { pickUrl };
        export { renderXYZTemplate };
    }
    export namespace util {
        export { VERSION };
        export { abstract };
        export { getUid };
    }
    export namespace vec {
        namespace mat4 {
            export { create };
            export { fromTransform };
            export { orthographic };
            export { scale };
            export { translate };
            export { translation };
        }
    }
    export namespace webgl {
        export { ARRAY_BUFFER };
        export { BaseTileRepresentation };
        export { WebGLArrayBuffer as Buffer };
        export namespace Canvas {
            export { Canvas };
            export { createProgram };
        }
        export { DYNAMIC_DRAW };
        export { ELEMENT_ARRAY_BUFFER };
        export { FLOAT };
        export { WebGLHelper as Helper };
        export { PaletteTexture };
        export { WebGLPostProcessingPass as PostProcessingPass };
        export { WebGLRenderTarget as RenderTarget };
        export { STATIC_DRAW };
        export { STREAM_DRAW };
        export namespace ShaderBuilder {
            export { COMMON_HEADER };
            export { ShaderBuilder };
        }
        export { TileGeometry };
        export { TileTexture };
        export { UNSIGNED_BYTE };
        export { UNSIGNED_INT };
        export { UNSIGNED_SHORT };
        export { getContext };
        export { getSupportedExtensions };
        export namespace styleparser {
            export { computeHash };
            export { expressionToGlsl };
            export { packColor };
            export { parseLiteralStyle };
        }
    }
    export namespace xml {
        export { OBJECT_PROPERTY_NODE_FACTORY };
        export { XML_SCHEMA_INSTANCE_URI };
        export { createElementNS };
        export { getAllTextContent };
        export { getAllTextContent_ };
        export { getAttributeNS };
        export { getDocument };
        export { getXMLSerializer };
        export { isDocument };
        export { makeArrayExtender };
        export { makeArrayPusher };
        export { makeArraySerializer };
        export { makeChildAppender };
        export { makeObjectPropertyPusher };
        export { makeObjectPropertySetter };
        export { makeReplacer };
        export { makeSequence };
        export { makeSimpleNodeFactory };
        export { makeStructureNS };
        export { parse };
        export { parseNode };
        export { pushParseAndPop };
        export { pushSerializeAndPop };
        export { registerDocument };
        export { registerXMLSerializer };
        export { serialize };
    }
}
//# sourceMappingURL=ol.d.ts.map
declare var map: ol.Map;
